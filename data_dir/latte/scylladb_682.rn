// Latte script for ScyllaDB Schema 682 - Payment Processing System
// This script creates and populates a complex payment processing schema with:
// - 6 keyspaces (pay_euw1, pay_eu, pay_euc1, pay_use1, pay_us, pay)
// - 251 UDTs (User Defined Types)
// - 168 base tables + 39 CDC log tables
// - 63 secondary indexes
// - 16 materialized views
//
// Usage:
//   Create schema: latte schema data_dir/latte/scylladb_682.rn <IP>
//   Run workload:  latte run data_dir/latte/scylladb_682.rn <IP> -f populate -d 1h

use latte::*;

/////////////////////////////////
///// Configuration Parameters /////
/////////////////////////////////

// Schema creation parameters
const CREATE_ALL_KEYSPACES = latte::param!("create_all_keyspaces", true);
const CREATE_KEYSPACE_PAY = latte::param!("create_keyspace_pay", true);
const CREATE_KEYSPACE_PAY_EU = latte::param!("create_keyspace_pay_eu", false);
const CREATE_KEYSPACE_PAY_US = latte::param!("create_keyspace_pay_us", false);
const CREATE_KEYSPACE_PAY_EUW1 = latte::param!("create_keyspace_pay_euw1", false);
const CREATE_KEYSPACE_PAY_EUC1 = latte::param!("create_keyspace_pay_euc1", false);
const CREATE_KEYSPACE_PAY_USE1 = latte::param!("create_keyspace_pay_use1", false);

// Replication and compaction settings
const REPLICATION_FACTOR = latte::param!("replication_factor", 3);
const COMPACTION_STRATEGY = latte::param!("compaction_strategy", "IncrementalCompactionStrategy");
const COMPRESSION = latte::param!("compression", "LZ4Compressor");

// Data population parameters
const ROW_COUNT_PER_TABLE = latte::param!("row_count_per_table", 1000);
const DATA_VALIDATION = latte::param!("data_validation", true);

// Workload distribution parameters
const GAUSS_MEAN = latte::param!("gauss_mean", 0);
const GAUSS_STDDEV = latte::param!("gauss_stddev", 0);

// Table windowing parameters â€” control which subset of tables is active at any time.
// 'table_group_size' tables are used at once, then every 'table_shift_interval_s' seconds
// the window shifts by 'table_shift_count' tables (wrapping around).
// Example: 130 tables, group_size=20, shift_count=5, shift_interval_s=10:
//   t=0s:  tables [0..20)
//   t=10s: tables [5..25)
//   t=20s: tables [10..30)
//   ...wraps around to beginning
// Set shift_count=0 and shift_interval_s=0 to disable windowing (all tables active).
const TABLE_GROUP_SIZE = latte::param!("table_group_size", 0);
const TABLE_SHIFT_COUNT = latte::param!("table_shift_count", 0);
const TABLE_SHIFT_INTERVAL_S = latte::param!("table_shift_interval_s", 0);

// CDC testing parameters
const ENABLE_CDC_VERIFICATION = latte::param!("enable_cdc_verification", false);

// Table selection for testing
const FOCUS_KEYSPACE = latte::param!("focus_keyspace", "pay");  // pay, pay_eu, pay_us, pay_euw1, pay_euc1, pay_use1
const TABLE_SUBSET = latte::param!("table_subset", "all");  // all, simple, udt_heavy, cdc_enabled

/////////////////////////////////
///// Schema Creation Functions /////
/////////////////////////////////

pub async fn schema(db) {
    println!("Creating ScyllaDB 682 Payment Processing Schema...");
    println!("  6 keyspaces, 251 UDTs, 168 tables, 63 indexes, 16 materialized views");
    println!("");

    // Create keyspaces
    if CREATE_ALL_KEYSPACES || CREATE_KEYSPACE_PAY_EUW1 {
        create_keyspace_pay_euw1(db).await;
    }
    if CREATE_ALL_KEYSPACES || CREATE_KEYSPACE_PAY_EU {
        create_keyspace_pay_eu(db).await;
    }
    if CREATE_ALL_KEYSPACES || CREATE_KEYSPACE_PAY_EUC1 {
        create_keyspace_pay_euc1(db).await;
    }
    if CREATE_ALL_KEYSPACES || CREATE_KEYSPACE_PAY_USE1 {
        create_keyspace_pay_use1(db).await;
    }
    if CREATE_ALL_KEYSPACES || CREATE_KEYSPACE_PAY_US {
        create_keyspace_pay_us(db).await;
    }
    if CREATE_ALL_KEYSPACES || CREATE_KEYSPACE_PAY {
        create_keyspace_pay(db).await;
    }

    println!("Schema creation complete!");
}

/////////////////////////////////
///// Keyspace Creation /////
/////////////////////////////////

async fn create_keyspace_pay_euw1(db) {
    println!("Creating keyspace: pay_euw1");
    let cql = "CREATE KEYSPACE IF NOT EXISTS pay_euw1 WITH replication = { 'class': 'NetworkTopologyStrategy', 'eu-west-1': '" + REPLICATION_FACTOR.to_string() + "' } AND durable_writes = true AND tablets = {'enabled': false};";
    db.execute(cql).await;

    // Create tables for pay_euw1 (9 tables)
    create_tables_pay_euw1(db).await;
}

async fn create_keyspace_pay_eu(db) {
    println!("Creating keyspace: pay_eu");
    let cql = "CREATE KEYSPACE IF NOT EXISTS pay_eu WITH replication = { 'class': 'NetworkTopologyStrategy', 'eu-west-1': '" + REPLICATION_FACTOR.to_string() + "', 'eu-west-2': '" + REPLICATION_FACTOR.to_string() + "' } AND durable_writes = true AND tablets = {'enabled': false};";
    db.execute(cql).await;

    // Create UDTs for pay_eu (30 UDTs)
    create_udts_pay_eu(db).await;

    // Create tables for pay_eu (4 tables)
    create_tables_pay_eu(db).await;
}

async fn create_keyspace_pay_euc1(db) {
    println!("Creating keyspace: pay_euc1");
    let cql = "CREATE KEYSPACE IF NOT EXISTS pay_euc1 WITH replication = { 'class': 'NetworkTopologyStrategy', 'eu-west-2': '" + REPLICATION_FACTOR.to_string() + "' } AND durable_writes = true AND tablets = {'enabled': false};";
    db.execute(cql).await;

    // Create tables for pay_euc1 (2 tables)
    create_tables_pay_euc1(db).await;
}

async fn create_keyspace_pay_use1(db) {
    println!("Creating keyspace: pay_use1");
    let cql = "CREATE KEYSPACE IF NOT EXISTS pay_use1 WITH replication = { 'class': 'NetworkTopologyStrategy', 'eu-north-1': '" + REPLICATION_FACTOR.to_string() + "' } AND durable_writes = true AND tablets = {'enabled': false};";
    db.execute(cql).await;

    // Create tables for pay_use1 (1 table)
    create_tables_pay_use1(db).await;
}

async fn create_keyspace_pay_us(db) {
    println!("Creating keyspace: pay_us");
    let cql = "CREATE KEYSPACE IF NOT EXISTS pay_us WITH replication = { 'class': 'NetworkTopologyStrategy', 'eu-north-1': '" + REPLICATION_FACTOR.to_string() + "' } AND durable_writes = true AND tablets = {'enabled': false};";
    db.execute(cql).await;

    // Create UDTs for pay_us (30 UDTs)
    create_udts_pay_us(db).await;

    // Create tables for pay_us (4 tables)
    create_tables_pay_us(db).await;
}

async fn create_keyspace_pay(db) {
    println!("Creating keyspace: pay (main payment processing schema)");
    let cql = "CREATE KEYSPACE IF NOT EXISTS pay WITH replication = { 'class': 'NetworkTopologyStrategy', 'eu-west-1': '" + REPLICATION_FACTOR.to_string() + "',  'eu-west-2': '" + REPLICATION_FACTOR.to_string() + "',  'eu-north-1': '" + REPLICATION_FACTOR.to_string() + "' } AND durable_writes = true AND tablets = {'enabled': false};";
    db.execute(cql).await;

    // Create UDTs for pay (191 UDTs) - this is the largest set
    println!("  Creating 191 UDTs in dependency order (7 levels)...");
    create_udts_pay(db).await;

    // Create tables for pay (148 tables)
    println!("  Creating 148 tables...");
    create_tables_pay(db).await;

    // Create indexes for pay (63 indexes)
    println!("  Creating 63 secondary indexes...");
    create_indexes_pay(db).await;

    // Create materialized views for pay (16 MVs)
    println!("  Creating 16 materialized views...");
    create_materialized_views_pay(db).await;
}

/////////////////////////////////
///// Placeholder Functions /////
/////////////////////////////////

// These will be implemented in phases

// UDTs for pay_eu keyspace
async fn create_udts_pay_eu(db) {
    // Level 1
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.onboarding_provider_error (
        value text, provider_name text, field_path text, error_message text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.note (
        added_at text, added_by text, message text, section text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.implementation (
        predefined_types list<text>, custom_type text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.exposure_risk (
        category text, calculated_exposure text, percent_held_back text, rolling_reserve_days int
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.infinicept_category (
        value text, status text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.check_sub_type (
        type text, result text, sub_categories map<text, text>, check_sub_result text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.aml_risk (
        category text, total_score text, high_risk_reason text, description text, renewal_date text, renewal_date_reason text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.decline_details (
        decline_reason text, comment text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.country_volume_share (
        region text, percentage text, countries frozen<list<text>>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.onboarding_channel (
        channel text, solicitor text, solicitor_email text, solicitor_name text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.business_processing_info (
        is_website_pci_compliant boolean, saq_type text, third_party_integration boolean, third_party_integration_description text, email_receipts boolean, orders_fulfilled_directly boolean, customer_access_type text, fraud_prevention_service_used boolean, fraud_prevention_service_description text, chargeback_procedure_description text, platform_requires_test_user boolean, test_username text, test_password text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.address_v2 (
        address_line text, address_line2 text, zip text, city text, state text, country_alpha2 text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.onboarding_schedule_config_settlement (
        schedule text, day int
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.social_media (
        type text, value text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.underwriting_info (
        close_relation_with_pay_employees boolean, close_relation_with_pay_employees_description text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.verification_comment (
        added_at text, added_by text, message text, updated_at text, updated_by text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.fulfillment_details (
        physical_goods boolean, fulfillment_method text, delivery_timeframe text
    );").await;

    // Level 2
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.onboarding_provider_errors (
        application_error text, field_errors frozen<list<frozen<onboarding_provider_error>>>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.onboarding_document (
        id text, name text, category text, type text, uploaded_on text, uploaded_by text, archive_status text, notes list<frozen<note>>, expiry_date text, issuing_date text, status text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.provider_method_infinicept (
        acceptable_use frozen<infinicept_category>, credit frozen<infinicept_category>, fraud frozen<infinicept_category>, kyc_business frozen<infinicept_category>, kyc_personal frozen<infinicept_category>, social frozen<infinicept_category>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.risk (
        aml_risk frozen<aml_risk>, exposure_risk frozen<exposure_risk>, processing_risk_score text, is_overridden boolean, renewal_date text, renewal_date_reason text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.onboarding_business_activity (
        reason text, product_description text, physical_products_origins list<text>, origins_of_funds list<text>, customers_abroad_countries list<text>, high_risk_countries list<text>, requires_authorization_from_authority boolean, payment_channels list<text>, product_supply_time_range text, subscription_based_service boolean, moto_options boolean, yearly_volume_currency text, yearly_volume text, minimum_transaction_currency text, minimum_transaction_amount text, average_transaction_currency text, average_transaction_amount text, maximum_transaction_currency text, maximum_transaction_amount text, sources_of_funds list<text>, customers_abroad boolean, product_company boolean, license_jurisdiction_country text, license_type text, projected_card_volume text, projected_card_volume_currency text, projected_card_turnover text, requires_authorization_from_authority_description text, monthly_card_volume_amount text, monthly_card_volume_currency text, monthly_average_volume_amount text, monthly_average_volume_currency text, volume_share_countries frozen<list<frozen<country_volume_share>>>, processing_currencies frozen<list<text>>, settlement_currencies frozen<list<text>>, blacklisted_countries frozen<list<text>>, current_payment_processor text, applying_reason text, special_products frozen<list<text>>, special_products_description text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.onboarding_settlement_details (
        settlement_currency text, bank_name text, bank_country text, beneficiary_name text, iban text, swift text, beneficiary_address frozen<address_v2>, id text, paired_currencies list<text>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.business_structure_details (
        business_structure text, business_registered_country text, registered_business_address frozen<address_v2>, business_phone_number text, number_of_employees text, date_of_incorporation text, physical_business_address frozen<address_v2>, companies_group boolean, group_name text, group_website text, public_company boolean, bankruptcy_proceedings boolean, business_email text, business_conduction_location text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.customer_support (
        statement_descriptor text, phone text, email text, address frozen<address_v2>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.entity_settlement_terms (
        rolling_reserve_type text, rolling_reserve_duration int, rolling_reserve_amount text, maximum_held_reserve text, schedule_config frozen<onboarding_schedule_config_settlement>, funding_delay int, security_deposit_amount text, currency text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.onboarding_business_details (
        legal_business_name text, doing_business_as text, employer_id_number text, company_registration_number text, industry text, website text, product_description text, monthly_processing_volume text, vat_number text, issuing_authority text, no_website boolean, social_media list<frozen<social_media>>, website_under_construction boolean, no_online_presence boolean, implementation frozen<implementation>, monthly_processing_volume_currency text, business_license_number text, industry_description text, special_products frozen<set<text>>, special_products_description text, no_vat_number boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.verification_check (
        check_stage text, check_type text, provider_name text, status text, check_sub_types list<frozen<check_sub_type>>, comments list<frozen<verification_comment>>, manual boolean, check_date text, updated_by text, added_by text, updated_at text
    );").await;

    // Level 3
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.provider_data (
        provider text, provider_errors frozen<onboarding_provider_errors>, provider_ma_id text, provider_status text, provider_merchant_id text, underwriting_results_url text, infinicept frozen<provider_method_infinicept>, last_updated text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_eu.onboarding_bank_details (
        routing_number text, account_number text, iban text, account_holder_name text, dda_type text, settlement_details list<frozen<onboarding_settlement_details>>
    );").await;
}

// UDTs for pay_us keyspace
async fn create_udts_pay_us(db) {
    // Level 1
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.onboarding_provider_error (
        value text, provider_name text, field_path text, error_message text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.note (
        added_at text, added_by text, message text, section text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.implementation (
        predefined_types list<text>, custom_type text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.exposure_risk (
        category text, calculated_exposure text, percent_held_back text, rolling_reserve_days int
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.infinicept_category (
        value text, status text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.check_sub_type (
        type text, result text, sub_categories map<text, text>, check_sub_result text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.aml_risk (
        category text, total_score text, high_risk_reason text, description text, renewal_date text, renewal_date_reason text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.decline_details (
        decline_reason text, comment text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.country_volume_share (
        region text, percentage text, countries frozen<list<text>>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.onboarding_channel (
        channel text, solicitor text, solicitor_email text, solicitor_name text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.business_processing_info (
        is_website_pci_compliant boolean, saq_type text, third_party_integration boolean, third_party_integration_description text, email_receipts boolean, orders_fulfilled_directly boolean, customer_access_type text, fraud_prevention_service_used boolean, fraud_prevention_service_description text, chargeback_procedure_description text, platform_requires_test_user boolean, test_username text, test_password text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.address_v2 (
        address_line text, address_line2 text, zip text, city text, state text, country_alpha2 text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.onboarding_schedule_config_settlement (
        schedule text, day int
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.social_media (
        type text, value text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.underwriting_info (
        close_relation_with_pay_employees boolean, close_relation_with_pay_employees_description text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.verification_comment (
        added_at text, added_by text, message text, updated_at text, updated_by text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.fulfillment_details (
        physical_goods boolean, fulfillment_method text, delivery_timeframe text
    );").await;

    // Level 2
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.onboarding_provider_errors (
        application_error text, field_errors frozen<list<frozen<onboarding_provider_error>>>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.onboarding_document (
        id text, name text, category text, type text, uploaded_on text, uploaded_by text, archive_status text, notes list<frozen<note>>, expiry_date text, issuing_date text, status text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.provider_method_infinicept (
        acceptable_use frozen<infinicept_category>, credit frozen<infinicept_category>, fraud frozen<infinicept_category>, kyc_business frozen<infinicept_category>, kyc_personal frozen<infinicept_category>, social frozen<infinicept_category>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.risk (
        aml_risk frozen<aml_risk>, exposure_risk frozen<exposure_risk>, processing_risk_score text, is_overridden boolean, renewal_date text, renewal_date_reason text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.onboarding_business_activity (
        reason text, product_description text, physical_products_origins list<text>, origins_of_funds list<text>, customers_abroad_countries list<text>, high_risk_countries list<text>, requires_authorization_from_authority boolean, payment_channels list<text>, product_supply_time_range text, subscription_based_service boolean, moto_options boolean, yearly_volume_currency text, yearly_volume text, minimum_transaction_currency text, minimum_transaction_amount text, average_transaction_currency text, average_transaction_amount text, maximum_transaction_currency text, maximum_transaction_amount text, sources_of_funds list<text>, customers_abroad boolean, product_company boolean, license_jurisdiction_country text, license_type text, projected_card_volume text, projected_card_volume_currency text, projected_card_turnover text, requires_authorization_from_authority_description text, monthly_card_volume_amount text, monthly_card_volume_currency text, monthly_average_volume_amount text, monthly_average_volume_currency text, volume_share_countries frozen<list<frozen<country_volume_share>>>, processing_currencies frozen<list<text>>, settlement_currencies frozen<list<text>>, blacklisted_countries frozen<list<text>>, current_payment_processor text, applying_reason text, special_products frozen<list<text>>, special_products_description text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.onboarding_settlement_details (
        settlement_currency text, bank_name text, bank_country text, beneficiary_name text, iban text, swift text, beneficiary_address frozen<address_v2>, id text, paired_currencies list<text>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.business_structure_details (
        business_structure text, business_registered_country text, registered_business_address frozen<address_v2>, business_phone_number text, number_of_employees text, date_of_incorporation text, physical_business_address frozen<address_v2>, companies_group boolean, group_name text, group_website text, public_company boolean, bankruptcy_proceedings boolean, business_email text, business_conduction_location text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.customer_support (
        statement_descriptor text, phone text, email text, address frozen<address_v2>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.entity_settlement_terms (
        rolling_reserve_type text, rolling_reserve_duration int, rolling_reserve_amount text, maximum_held_reserve text, schedule_config frozen<onboarding_schedule_config_settlement>, funding_delay int, security_deposit_amount text, currency text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.onboarding_business_details (
        legal_business_name text, doing_business_as text, employer_id_number text, company_registration_number text, industry text, website text, product_description text, monthly_processing_volume text, vat_number text, issuing_authority text, no_website boolean, social_media list<frozen<social_media>>, website_under_construction boolean, no_online_presence boolean, implementation frozen<implementation>, monthly_processing_volume_currency text, business_license_number text, industry_description text, special_products frozen<set<text>>, special_products_description text, no_vat_number boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.verification_check (
        check_stage text, check_type text, provider_name text, status text, check_sub_types list<frozen<check_sub_type>>, comments list<frozen<verification_comment>>, manual boolean, check_date text, updated_by text, added_by text, updated_at text
    );").await;

    // Level 3
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.provider_data (
        provider text, provider_errors frozen<onboarding_provider_errors>, provider_ma_id text, provider_status text, provider_merchant_id text, underwriting_results_url text, infinicept frozen<provider_method_infinicept>, last_updated text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay_us.onboarding_bank_details (
        routing_number text, account_number text, iban text, account_holder_name text, dda_type text, settlement_details list<frozen<onboarding_settlement_details>>
    );").await;
}

// UDTs for pay keyspace - 191 UDTs in 7 dependency levels
async fn create_udts_pay(db) {
    // Level 1 - Base UDTs with no dependencies
    db.execute("CREATE TYPE IF NOT EXISTS pay.note (
        added_at text, added_by text, message text, section text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.after_completion_redirect (
        url text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.report_frequency (
        type text, amount int, value text, timestamp_from text, timestamp_to text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.network_specific_fields (
        transaction_identifier text, banknet_reference text, trace_id text, advice_code text, ucaf text, aci_code text, par text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.aps_tokens (
        merchant_guid text, method_guid text, app_token text, app_secret text, callback_secret_key text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.logic_fields_additional_settings (
        depends_on_external_risk_engine boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.logic_field_options (
        label text, value text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.gumballpay_tokens (
        endpoint_id text, endpoint_group_id text, private_key text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.filter_field (
        name text, operator text, value text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.finance_commission_setup (
        id text, basis_points text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.expiry_options (
        type text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.finance_rev_share_tiers (
        basis_points text, from_volume text, to_volume text, name text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.evidence_references (
        proof_of_delivery_or_service text, invoice_or_receipt text, invoice_showing_distinct_transactions text, customer_communication text, refund_or_cancellation_policy text, recurring_transaction_agreement text, additional_evidence text, proof_of_delivery_or_service_date text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.entity_fields (
        entity text, fields set<text>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.entity_contact_info (
        phone text, email text, name text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.flow_directions (
        payment boolean, payout boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.email_notification_config (
        email_id text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.ecp_tokens (
        cvv_on text, cvv_off text, moto text, three_ds text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.contact_info (
        phone text, email text, first_name text, last_name text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.decline_details (
        decline_reason text, comment text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.ani_verification_details (
        match_performed text, provider text, full_name_match text, first_name_match text, middle_name_match text, last_name_match text, action_code text, match_details text, provider_transaction_id text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_skrill (
        email text, first_name text, last_name text, customer_id text, mb_transaction_id text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.custom_text_shipping_address (
        message text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.custom_text_submit (
        message text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.bank_details (
        iban text, currency_code text, country_alpha2 text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.fonix_services_credentials (
        sid text, api_key text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.apm_frontend_content (
        type text, content text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.fees_detail (
        processed_amount text, processed_count int, processing_fees text, interchange_fees text, network_fees text, total_fees text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.card_method_options_network_token_authorization_v2 (
        enabled boolean, full_pan_fallback boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_options_providers (
        settlement_account_id text, provider text, routing_key text, retryable_decline_codes list<text>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.after_completion_hosted_confirmation (
        custom_message text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.dropdown_options (
        label text, value text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.chargeback_detail (
        chargeback_amount text, chargeback_count int, chargeback_fees text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payout_us_bank_account_options (
        rail text, ach_payment_type text, fallback_to_ach boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.business_details (
        company_registration_number text, vat_number text, website text, mcc int, business_description text, country_alpha2 text, email text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.card_method_options_security_checks_v2 (
        address_line1_check boolean, address_postal_code_check boolean, cvv_check boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.cybersource_risk_interval (
        start int, end int, decision text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.common_settings_interval (
        interval text, interval_count int
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.onboarding_schedule_config_settlement (
        schedule text, day int
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.address (
        first_name text, last_name text, phone text, email text, address text, zip text, city text, state text, country_alpha text, country_number text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.customer_details_match_options (
        first_name boolean, last_name boolean, country boolean, postal_code boolean, line1 boolean, dob boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.common_settings_retries (
        attempts int, interval text, interval_count int
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.browser_details (
        accept_header text, javascript_enabled boolean, language text, user_agent text, screen_width int, screen_height int, timezone_offset text, java_enabled boolean, color_depth int
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.worldpay_three_ds_credentials (
        worldpay_mac_key text, worldpay_api_id text, worldpay_org_unit_id text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.acquirer_details (
        mid text, acquirer_bin text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.fallback_config (
        default_config boolean, settlement_account_id text, failure_codes frozen<list<text>>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.accepted_ani_results_breakdown (
        first_name list<text>, last_name list<text>, middle_name list<text>, full_name list<text>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.businessdetails (
        company_number text, vat_number text, website text, mcc int, business_description text, country text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.worldpay_merchant_credentials (
        worldpay_username text, worldpay_password text, worldpay_merchant_id map<text, text>, worldpay_mid_type text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.cvv_whitelist (
        enabled boolean, duration text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.custom_fields_validation (
        required boolean, max int, min int, max_length int, min_length int, pattern text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.rename_fields_type (
        rename_map frozen<map<text, text>>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.silverflow_merchant_acceptor_key (
        visa text, mastercard text, amex text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.card_method_options_security_checks (
        address_line1_check boolean, address_postal_code_check boolean, cvv_check boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.decline_recovery_setting (
        enabled boolean, settlement_account_id text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.paypal_method_options_v2 (
        name_verification boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.card_method_options_security_checks_limits (
        address_line1_check text, address_postal_code_check text, cvv_check text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_zimpler (
        country text, user_id text, national_identification_number text, account_number text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.collection_param_settings (
        enabled boolean, allowed_countries list<text>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.custom_fields_label (
        custom text, type text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.common_settings_amount (
        type text, amount text, dynamic_amount_url text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.routing_details_initial_mit (
        transaction_id text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.common_settings_subscription_status (
        current_subscription text, other_subscriptions text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.partial_approval_finalize (
        status text, amount_requested text, amount_authorized text, amount_charged text, product_id text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.sms_notification_config (
        content text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.routing_details_rule_engine (
        rule_id text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.task_note (
        id text, note text, created_at text, created_by text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.partial_approval_products (
        amount text, description text, id text, image text, title text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_link_amount_limits (
        max text, min text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.card_method_options_network_token_provision_v2 (
        enabled boolean, decline_on_failure boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.three_ds_type_options (
        type text, allow_frictionless boolean, sca_exemption_type text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.notification_subscription_delivery_config (
        email_enabled boolean, sms_enabled boolean, phone text, email text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_bank_account (
        country text, currency text, last4 text, account_holder_name text, account_holder_type text, routing_number text, fingerprint text, account_type text, bank_name text, source text, details map<text, text>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.pricing_additional_configuration (
        return_interchange_for_refunds boolean, markup_network_fees text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_card (
        name text, expiry_month text, expiry_year text, bin text, last_four_digits text, issuer_name text, national_identification_number text, brand text, issuer_country text, card_type text, card_category text, fingerprint text, cvc_check text, address_line1_check text, address_postal_code_check text, network text, raw_details_provided boolean, duplicate_card boolean, wallet text, cardholder_currency text, wallet_tokenized_card_last4 text, payout text, wallet_tokenized_card_bin text, wallet_tokenized_card_expiry_month text, wallet_tokenized_card_expiry_year text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.reconciliation_config_params (
        boolean boolean, string text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.routing_details_stored_processor_token (
        processor_token text, processor_account_id text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.workflow_param (
        key text, description text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_netbanking (
        bank_code text, bank_name text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_generic (
        type text, details map<text, text>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_neteller (
        email text, first_name text, last_name text, customer_id text, country text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_options_bank_v2 (
        allowed_countries list<text>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.processor_config (
        default_processor text, default_processor_map map<text, text>, default3_ds_processor text, routing_key text, retry_providers frozen<list<text>>, transacting_mid_country text, settlement_account_id text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_options_collection_item_v2 (
        enabled boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.recurringpayments (
        is_repeated_transaction boolean, total_number_of_payments int, number_of_payment_made int, single_payment_amount float, transaction_amount_charged float, transaction_amount_left_to_charge float
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_paypal (
        email text, payer_id text, first_name text, last_name text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.task_list_value (
        string_value text, bool_value boolean, json_value text, number_value int
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_paypal_billing_agreement (
        ba_token text, ba_id text, email text, first_name text, last_name text, payer_id text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_paysafecard (
        customer_id text, serial text, currency text, amount text, country text, email text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.report_config_s3 (
        enabled boolean, bucket text, folder text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.validation_config (
        key text, error_message text, required boolean, min_length int, max_length int, pattern text, min_value double, max_value double
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.additional_pricing_actions (
        approval list<text>, decline list<text>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_upi (
        vpa text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.custom_fields_options (
        label text, value text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.risk_calculation_details (
        parameter text, value text, type text, source text, score int
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payout_prepaid_card_options (
        product text, verification_type text, distribution_method text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.request_sca_exemption (
        sca_exemption_type text, soft_decline_loop boolean, soft_decline_loop_decline_codes list<text>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.paypal_method_options (
        name_verification boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.pinless_debit_options (
        enabled boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_options_googlepay_shipping_address_v2 (
        enabled boolean, include_phone_number boolean, allowed_countries list<text>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.receipt_delivery_record (
        emails set<text>, sent_at text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.task_fields_options (
        label text, value text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.master_account_details (
        iban text, swift_bic text, account_identifier text, currency text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.recurring_time_settings (
        days_of_week text, days_of_month text, day_time text, last_day_of_month boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.report_config_sftp (
        enabled boolean, host text, port text, username text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.address_v2 (
        address_line text, address_line2 text, zip text, city text, state text, country_alpha2 text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.risk_control_payment_method_options (
        start int, end int, outcome text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payout_interac_name_verification_options (
        enabled boolean, similarity_acceptance text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.report_config_email (
        enabled boolean, emails list<text>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.schedule_config_settlement (
        schedule text, day int
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.sftp_upload_credentials (
        host text, port int, username text, userpass text, public_key text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.statement_delivery_record (
        emails set<text>, sent_at text, email_id text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.suspicion_reporter (
        name text, phone_number text, email text, department text, position text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_options_applepay_shipping_address_v2 (
        enabled boolean, include_phone_number boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.three_ds (
        version text, eci text, cavv text, ds_trans_id text, xid text, mpi_processor_id text, trxid text, method_completion_ind text, status text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.three_ri_options (
        indicator text, require_issuer_liability_shift boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.tier_object (
        from_value text, to_value text, fixed_fee text, basis_points text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.underwriting_info (
        close_relation_with_pay_employees boolean, close_relation_with_pay_employees_description text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.us_bank_account_method_options (
        ach_payment_type text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_paysafecash (
        email text, first_name text, last_name text, customer_id text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.us_bank_account_method_options_limits (
        ach_payment_type list<text>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.task_category (
        value text, title text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.us_bank_account_method_options_v2 (
        ach_payment_type text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.evaluation_report (
        evaluation_report_id text, enquiries_undertaken text, decision_of_the_amlco text, decision_description text, external_report_reference text, evaluation_date text, last_updated_by text, last_updated_on text, attached_document_ids frozen<list<text>>
    );").await;

    // Level 2 - UDTs depending on Level 1
    db.execute("CREATE TYPE IF NOT EXISTS pay.risk_alert_status_details (
        status text, notes list<frozen<note>>, documents frozen<list<text>>, assignee text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.recurring_options (
        amount int, interval text, interval_count int, expiry frozen<expiry_options>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.installment_options (
        number int, amount int, interval text, interval_count int, expiry frozen<expiry_options>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.custom_text (
        shipping_address frozen<custom_text_shipping_address>, submit frozen<custom_text_submit>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.processing_fees_breakdown_by_card_product (
        consumer frozen<fees_detail>, business frozen<fees_detail>, unknown frozen<fees_detail>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.processing_fees_breakdown_by_scheme (
        visa frozen<fees_detail>, mastercard frozen<fees_detail>, amex frozen<fees_detail>, discover frozen<fees_detail>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.after_completion (
        hosted_confirmation frozen<after_completion_hosted_confirmation>, redirect frozen<after_completion_redirect>, type text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.custom_fields_dropdown (
        options list<frozen<dropdown_options>>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.chargeback_breakdown_by_scheme (
        visa frozen<chargeback_detail>, mastercard frozen<chargeback_detail>, amex frozen<chargeback_detail>, discover frozen<chargeback_detail>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.entity_settlement_terms (
        rolling_reserve_type text, rolling_reserve_duration int, rolling_reserve_amount text, maximum_held_reserve text, schedule_config frozen<onboarding_schedule_config_settlement>, funding_delay int, security_deposit_amount text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.apm_verification_options (
        enabled boolean, accepted_verification_level_values list<text>, require_match_for_customer_details frozen<customer_details_match_options>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.verification_options (
        enabled boolean, accepted_verification_level_values list<text>, require_match_for_customer_details frozen<customer_details_match_options>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.authentication_context (
        customer_ip_address text, browser_details frozen<browser_details>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.silverflow_credentials_payout (
        silverflow_merchant_acceptor_key frozen<silverflow_merchant_acceptor_key>, silverflow_credentials_by_currency frozen<map<text, frozen<silverflow_merchant_acceptor_key>>>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.card_method_options (
        accepted_card_brands list<text>, accepted_card_funding list<text>, request_threed_secure text, enforce_customer_name_as_cardholder_name boolean, accepted_card_jurisdictions list<text>, security_checks frozen<card_method_options_security_checks>, duplicate_card_check boolean, accepted_card_categories list<text>, accepted_card_countries list<text>, moto boolean, accepted_eci_values list<text>, dynamic_currency_conversion boolean, providers frozen<list<text>>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.decline_recovery_settings (
        flex_factor frozen<decline_recovery_setting>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.card_method_options_limits (
        accepted_card_brands list<text>, accepted_card_funding list<text>, accepted_card_jurisdictions list<text>, enforce_customer_name_as_cardholder_name text, request_threed_secure list<text>, security_checks frozen<card_method_options_security_checks_limits>, duplicate_card_check text, accepted_card_categories list<text>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.collection (
        billing_address frozen<collection_param_settings>, shipping_address frozen<collection_param_settings>, phone_number frozen<collection_param_settings>, tax_id frozen<collection_param_settings>, full_name frozen<collection_param_settings>, email_address frozen<collection_param_settings>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.common_settings_dispute (
        created frozen<common_settings_subscription_status>, lost frozen<common_settings_subscription_status>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.finalize (
        issuer_response_code int, issuer_response_text text, result_source text, auth_code text, transaction_rrn text, transaction_result text, transaction_timestamp text, network_code text, system_trace_audit_number text, eci text, network_specific_fields frozen<network_specific_fields>, issuer_response_code_string text, rrn text, funding boolean, ani_verification_details frozen<ani_verification_details>, partial_approval frozen<partial_approval_finalize>, payout_type text, funding_type text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.notification_delivery_config (
        email_enabled boolean, sms_enabled boolean, email_config frozen<email_notification_config>, sms_config frozen<sms_notification_config>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.card_method_options_partial_approval_v2 (
        accept boolean, allow_top_up boolean, percentage_threshold int, amount_threshold text, require_full_amount boolean, approved_by_default boolean, products list<frozen<partial_approval_products>>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.card_method_options_network_token_v2 (
        provision frozen<card_method_options_network_token_provision_v2>, authorization frozen<card_method_options_network_token_authorization_v2>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.three_ds_flow_indicator_options (
        type text, challenge frozen<three_ds_type_options>, frictionless frozen<three_ds_type_options>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.routing_details (
        selected_methodology text, initial_mit frozen<routing_details_initial_mit>, stored_processor_token frozen<routing_details_stored_processor_token>, rule_engine frozen<routing_details_rule_engine>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.processor_transaction_type_config (
        default_processor text, default_processor_map map<text, text>, default3_ds_processor text, currency map<text, frozen<processor_config>>, retry_providers frozen<list<text>>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.task_field_value (
        string_value text, bool_value boolean, list_value list<frozen<task_list_value>>, json_value text, number_value int
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.task_template_action (
        signal text, style text, label text, validation_configs frozen<list<frozen<validation_config>>>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.custom_fields_v2 (
        id text, placeholder text, label text, type text, input_type text, options list<frozen<custom_fields_options>>, description text, validation frozen<custom_fields_validation>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_options_collection_googlepay_v2 (
        billing_address frozen<payment_method_options_collection_item_v2>, email frozen<payment_method_options_collection_item_v2>, name frozen<payment_method_options_collection_item_v2>, phone_number frozen<payment_method_options_collection_item_v2>, shipping_address frozen<payment_method_options_googlepay_shipping_address_v2>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.task_template_field (
        id text, created_at text, type text, label text, placeholder text, options list<frozen<task_fields_options>>, readonly boolean, external_id text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.customer_support (
        statement_descriptor text, phone text, email text, address frozen<address_v2>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.risk_alert_customer (
        name text, address frozen<address_v2>, contact_number text, date_of_incorporation text, email text, country_of_incorporation text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.advanced_fraud_screening_payment_method_options (
        enabled boolean, learn_mode boolean, thresholds list<frozen<risk_control_payment_method_options>>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payout_interac_options (
        name_verification frozen<payout_interac_name_verification_options>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.report_config (
        email frozen<report_config_email>, s3 frozen<report_config_s3>, sftp frozen<report_config_sftp>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.report_distribution_method (
        type text, is_enabled boolean, items set<text>, sftp_upload_credentials frozen<sftp_upload_credentials>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.suspicion_report (
        id text, reporter frozen<suspicion_reporter>, suspicion_description text, suspicion_reason text, last_updated_by text, last_updated_on text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_options_collection_applepay_v2 (
        billing_address frozen<payment_method_options_collection_item_v2>, email frozen<payment_method_options_collection_item_v2>, name frozen<payment_method_options_collection_item_v2>, phone_number frozen<payment_method_options_collection_item_v2>, shipping_address frozen<payment_method_options_applepay_shipping_address_v2>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.tiering_object (
        strategy_id text, tiers list<frozen<tier_object>>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method (
        type text, id text, unique_identifier text, card frozen<payment_method_card>, paypal frozen<payment_method_paypal>, paypal_billing_agreement frozen<payment_method_paypal_billing_agreement>, paysafecard frozen<payment_method_paysafecard>, neteller frozen<payment_method_neteller>, paysafecash frozen<payment_method_paysafecash>, zimpler frozen<payment_method_zimpler>, skrill frozen<payment_method_skrill>, us_bank_account frozen<payment_method_bank_account>, applepay frozen<payment_method_card>, googlpay frozen<payment_method_card>, googlepay frozen<payment_method_card>, in_bank_account frozen<payment_method_bank_account>, upi frozen<payment_method_upi>, netbanking frozen<payment_method_netbanking>, generic frozen<payment_method_generic>, reference text, bank_account frozen<payment_method_bank_account>
    );").await;

    // Level 3 - UDTs depending on Levels 1-2
    db.execute("CREATE TYPE IF NOT EXISTS pay.future_usage_options (
        type text, installment frozen<installment_options>, recurring frozen<recurring_options>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.processing_fees_breakdown_by_card_type (
        debit frozen<processing_fees_breakdown_by_card_product>, credit frozen<processing_fees_breakdown_by_card_product>, prepaid frozen<processing_fees_breakdown_by_card_product>, unknown frozen<processing_fees_breakdown_by_card_product>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.custom_fields (
        dropdown frozen<custom_fields_dropdown>, key text, label frozen<custom_fields_label>, optional boolean, type text, regex text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payout_skrill_neteller_method_options (
        verification frozen<apm_verification_options>, email_subject text, email_message text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.skrill_neteller_payment_method_options (
        verification frozen<verification_options>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_options (
        card frozen<card_method_options>, us_bank_account frozen<us_bank_account_method_options>, types list<text>, paypal frozen<paypal_method_options>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_methods_options_limits (
        card frozen<card_method_options_limits>, us_bank_account frozen<us_bank_account_method_options_limits>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.subscriptions_common_settings (
        amount frozen<common_settings_amount>, currency text, retries frozen<common_settings_retries>, schedule frozen<common_settings_interval>, trial frozen<common_settings_interval>, cancel frozen<common_settings_interval>, failure text, pause text, dispute frozen<common_settings_dispute>, fraud_warning frozen<common_settings_subscription_status>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.three_ds_options (
        accepted_eci_values list<text>, flow_indicator frozen<three_ds_flow_indicator_options>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_control_hours (
        default_processor text, default_processor_map map<text, text>, default3_ds_processor text, currency map<text, frozen<processor_config>>, transaction_types map<text, frozen<processor_transaction_type_config>>, retry_providers frozen<list<text>>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.task_value (
        key text, value frozen<task_field_value>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_options_googleplay_v2 (
        collection frozen<payment_method_options_collection_googlepay_v2>, require_cryptogram_threed_secure boolean
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.branding (
        display_name text, logo text, color text, fallback_url text, cta_text text, customer_support frozen<customer_support>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.card_method_options_v2 (
        accepted_card_brands list<text>, accepted_card_funding list<text>, accepted_card_jurisdictions list<text>, accepted_card_categories list<text>, enforce_customer_name_as_cardholder_name boolean, request_threed_secure text, security_checks frozen<card_method_options_security_checks_v2>, duplicate_card_check boolean, accepted_card_countries list<text>, moto boolean, accepted_eci_values list<text>, dynamic_currency_conversion boolean, providers frozen<list<text>>, exemption_type text, partial_approval frozen<card_method_options_partial_approval_v2>, instant_refund boolean, network_token frozen<card_method_options_network_token_v2>, funding boolean, retry_providers frozen<list<frozen<payment_method_options_providers>>>, advanced_fraud_screening frozen<advanced_fraud_screening_payment_method_options>, accepted_ani_results list<text>, accepted_ani_results_breakdown frozen<accepted_ani_results_breakdown>, request_ani boolean, use_customer_name_ani boolean, request_sca_exemption frozen<request_sca_exemption>, pinless_debit frozen<pinless_debit_options>, cvv_whitelist frozen<cvv_whitelist>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_options_applepay_v2 (
        collection frozen<payment_method_options_collection_applepay_v2>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.pricing_action_object (
        basis_points text, fixed_fee text, basis_fee_description text, fixed_fee_description text, gross_fixed boolean, gross_basis_points boolean, tiering frozen<tiering_object>, apply_as_application_fee boolean, apply_as_network_fee boolean, precision int, alias text, cost_provider text, once_per_payment_attempt boolean
    );").await;

    // Level 4 - UDTs depending on Levels 1-3
    db.execute("CREATE TYPE IF NOT EXISTS pay.processing_fees_breakdown_by_jurisdiction (
        domestic frozen<processing_fees_breakdown_by_card_type>, international frozen<processing_fees_breakdown_by_card_type>, intraregional frozen<processing_fees_breakdown_by_card_type>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payout_method_options (
        skrill frozen<payout_skrill_neteller_method_options>, us_bank_account frozen<payout_us_bank_account_options>, prepaid_card frozen<payout_prepaid_card_options>, interac frozen<payout_interac_options>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.subscriptions_custom_settings (
        id text, reference text, description text, overwritten boolean, settings frozen<subscriptions_common_settings>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.authentication_options (
        type text, three_ds frozen<three_ds_options>, three_ri frozen<three_ri_options>, setup_future_usage frozen<future_usage_options>, submit text
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.pricing_alternative_payment_methods (
        actions map<text, frozen<pricing_action_object>>, blended boolean
    );").await;

    // Level 5 - UDTs depending on Levels 1-4
    db.execute("CREATE TYPE IF NOT EXISTS pay.processing_fees_breakdown_by_scheme_detailed (
        visa frozen<processing_fees_breakdown_by_jurisdiction>, mastercard frozen<processing_fees_breakdown_by_jurisdiction>, amex frozen<processing_fees_breakdown_by_jurisdiction>, discover frozen<processing_fees_breakdown_by_jurisdiction>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.payment_method_options_v2 (
        card frozen<card_method_options_v2>, us_bank_account frozen<us_bank_account_method_options_v2>, types list<text>, paypal frozen<paypal_method_options_v2>, googlepay frozen<payment_method_options_googleplay_v2>, applepay frozen<payment_method_options_applepay_v2>, bank_account frozen<payment_method_options_bank_v2>, disabled_payment_methods_types list<text>, skrill frozen<skrill_neteller_payment_method_options>, neteller frozen<skrill_neteller_payment_method_options>, authentication_options frozen<authentication_options>, decline_recovery frozen<decline_recovery_settings>, payout_method_options frozen<payout_method_options>
    );").await;
    db.execute("CREATE TYPE IF NOT EXISTS pay.pricing_alternative_currencies_v2 (
        actions map<text, frozen<pricing_action_object>>, alternative_payment_methods map<text, frozen<pricing_alternative_payment_methods>>, settlement_fees map<text, frozen<pricing_action_object>>
    );").await;

    // Level 6 - UDTs depending on Levels 1-5
    db.execute("CREATE TYPE IF NOT EXISTS pay.outcome_details (
        processor_config frozen<processor_config>, payment_methods_options frozen<payment_method_options_v2>, payment_method_config_id text, deprecated_fallback_config frozen<fallback_config>, fallback_config frozen<list<frozen<fallback_config>>>
    );").await;

    // Level 7 - Final level, deepest dependency
    db.execute("CREATE TYPE IF NOT EXISTS pay.outcome_details_by_range (
        outcome_details frozen<outcome_details>, start int, end int
    );").await;
}

// Tables for pay_euw1 keyspace (9 tables)
async fn create_tables_pay_euw1(db) {
    // Note: 5 tables have CDC enabled
    db.execute("CREATE TABLE IF NOT EXISTS pay_euw1.cdc_progress_table ( generation timestamp, application_name text, table_name text, stream_id blob, current_generation timestamp, last_timestamp timeuuid, PRIMARY KEY ((generation, application_name, table_name, stream_id)) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay_euw1.cdc_progress_table_v2 ( generation timestamp, application_name text, table_name text, stream_id blob, current_generation timestamp, last_timestamp timeuuid, PRIMARY KEY ((generation, application_name, table_name, stream_id)) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay_euw1.counter ( counter_id text, type text, id text, PRIMARY KEY (counter_id, type, id) ) WITH CLUSTERING ORDER BY (type ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay_euw1.rules_run_cache ( key text, rule_id text, PRIMARY KEY (key, rule_id) ) WITH CLUSTERING ORDER BY (rule_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 86400 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay_euw1.temporal_actions_2 ( identifier text, unique_key text, action text, body text, namespace text, signal_body text, signal_type text, task_queue text, workflow_type text, PRIMARY KEY (identifier, unique_key) ) WITH CLUSTERING ORDER BY (unique_key ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'ZstdWithDictsCompressor'} AND crc_check_chance = 1 AND default_time_to_live = 86400 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'keys', 'enabled': 'true', 'postimage': 'true', 'preimage': 'false', 'ttl': '86400'} AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay_euw1.temporal_actions_webhooks_0 ( identifier text, unique_key text, action text, body text, namespace text, signal_body text, signal_type text, task_queue text, workflow_type text, PRIMARY KEY (identifier, unique_key) ) WITH CLUSTERING ORDER BY (unique_key ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 86400 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'false', 'ttl': '86400'} AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay_euw1.temporal_actions_webhooks_1 ( identifier text, unique_key text, action text, body text, namespace text, signal_body text, signal_type text, task_queue text, workflow_type text, PRIMARY KEY (identifier, unique_key) ) WITH CLUSTERING ORDER BY (unique_key ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 86400 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'false', 'ttl': '86400'} AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay_euw1.temporal_actions_webhooks_2 ( identifier text, unique_key text, action text, body text, namespace text, signal_body text, signal_type text, task_queue text, workflow_type text, PRIMARY KEY (identifier, unique_key) ) WITH CLUSTERING ORDER BY (unique_key ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 86400 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'false', 'ttl': '86400'} AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay_euw1.temporal_actions_webhooks_3 ( identifier text, unique_key text, action text, body text, namespace text, signal_body text, signal_type text, task_queue text, workflow_type text, PRIMARY KEY (identifier, unique_key) ) WITH CLUSTERING ORDER BY (unique_key ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 86400 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'false', 'ttl': '86400'} AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
}

// Tables for pay_eu keyspace (4 tables)
async fn create_tables_pay_eu(db) {
    // Note: 1 tables have CDC enabled
    db.execute("CREATE TABLE IF NOT EXISTS pay_eu.document_types ( type text, value text, archived boolean, label text, regions list<text>, PRIMARY KEY (type, value) ) WITH CLUSTERING ORDER BY (value ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay_eu.individuals ( id text, annual_income text, annual_income_currency text, archived boolean, company_country text, company_country_of_incorporation text, company_date_of_incorporation text, company_legal_name text, company_physical_address frozen<address_v2>, company_registered_address frozen<address_v2>, company_registration_number text, country text, date_of_birth text, document_country_of_issue text, document_expiration_date text, document_issue_date text, documents list<frozen<onboarding_document>>, email text, first_name text, id_number text, identification_document_type text, individuals list<text>, is_business_representative boolean, is_director boolean, is_nominee_shareholder boolean, is_shareholder boolean, last_name text, middle_name text, nationality text, other_activities_details text, pep boolean, percentage_of_shares text, phone_number text, place_of_birth text, proof_of_residence_document_type text, residential_address frozen<address_v2>, significant_responsibility boolean, size_of_wealth text, size_of_wealth_currency text, social_media list<frozen<social_media>>, source_of_income text, source_of_wealth text, ssn text, title text, type text, verification_checks list<frozen<verification_check>>, PRIMARY KEY (id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay_eu.individuals_v2 ( company_id text, merchant_id text, id text, annual_income text, annual_income_currency text, archived boolean, company_country text, company_country_of_incorporation text, company_date_of_incorporation text, company_legal_name text, company_physical_address frozen<address_v2>, company_registered_address frozen<address_v2>, company_registration_number text, country text, date_of_birth text, document_country_of_issue text, document_expiration_date text, document_issue_date text, documents list<frozen<onboarding_document>>, email text, first_name text, id_number text, identification_document_type text, individuals list<text>, is_business_representative boolean, is_director boolean, is_nominee_shareholder boolean, is_shareholder boolean, is_ubo boolean, last_name text, middle_name text, nationality text, other_activities_details text, pep boolean, percentage_of_shares text, phone_number text, place_of_birth text, proof_of_residence_document_type text, residential_address frozen<address_v2>, significant_responsibility boolean, size_of_wealth text, size_of_wealth_currency text, social_media list<frozen<social_media>>, source_of_income text, source_of_income_other text, source_of_wealth text, source_of_wealth_other text, ssn text, title text, type text, verification_checks list<frozen<verification_check>>, PRIMARY KEY (company_id, merchant_id, id) ) WITH CLUSTERING ORDER BY (merchant_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay_eu.merchant_applications ( company_id text, merchant_id text, version int, acquiring_services list<text>, approval_date text, authorized_business_representative text, automatic_review boolean, bank_details frozen<onboarding_bank_details>, business_activity frozen<onboarding_business_activity>, business_details frozen<onboarding_business_details>, business_processing_info frozen<business_processing_info>, business_review text, business_structure_details frozen<business_structure_details>, channel text, contract_agreement_date text, created_at text, created_by text, created_by_system text, customer_support frozen<customer_support>, decline_details frozen<decline_details>, documents list<frozen<onboarding_document>>, enrollment_date text, fulfillment_details frozen<fulfillment_details>, heard_of_pay_from text, individuals list<text>, last_updated text, notes list<frozen<note>>, onboarding_channel frozen<onboarding_channel>, other_communications boolean, owner text, pay_legal_entity frozen<set<text>>, payment_requirements text, paypass_link_created_at text, paypass_link_created_by text, paypass_link_created_by_system text, paypass_submitted_at text, priority tinyint, privacy_policy_agreement boolean, provider_data frozen<provider_data>, risk frozen<risk>, risk_score text, sales_assignee text, settlement_terms frozen<entity_settlement_terms>, shadow_purchase text, short_descriptor text, stage tinyint, status text, test boolean, underwriting_assignee text, underwriting_info frozen<underwriting_info>, verification_checks list<frozen<verification_check>>, PRIMARY KEY (company_id, merchant_id, version) ) WITH CLUSTERING ORDER BY (merchant_id DESC, version DESC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
}

// Tables for pay_euc1 keyspace (2 tables)
async fn create_tables_pay_euc1(db) {
    // Note: 1 tables have CDC enabled
    db.execute("CREATE TABLE IF NOT EXISTS pay_euc1.cdc_progress_table ( generation timestamp, application_name text, table_name text, stream_id blob, current_generation timestamp, last_timestamp timeuuid, PRIMARY KEY ((generation, application_name, table_name, stream_id)) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay_euc1.temporal_actions ( identifier text, unique_key text, action text, body text, namespace text, signal_body text, signal_type text, task_queue text, workflow_type text, PRIMARY KEY (identifier, unique_key) ) WITH CLUSTERING ORDER BY (unique_key ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 86400 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'keys', 'enabled': 'true', 'postimage': 'true', 'preimage': 'false', 'ttl': '86400'} AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
}

// Tables for pay_use1 keyspace (1 tables)
async fn create_tables_pay_use1(db) {
    // Note: 1 tables have CDC enabled
    db.execute("CREATE TABLE IF NOT EXISTS pay_use1.temporal_actions ( identifier text, unique_key text, action text, body text, namespace text, signal_body text, signal_type text, task_queue text, workflow_type text, PRIMARY KEY (identifier, unique_key) ) WITH CLUSTERING ORDER BY (unique_key ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 86400 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'keys', 'enabled': 'true', 'postimage': 'true', 'preimage': 'false', 'ttl': '86400'} AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
}

// Tables for pay_us keyspace (4 tables)
async fn create_tables_pay_us(db) {
    // Note: 1 tables have CDC enabled
    db.execute("CREATE TABLE IF NOT EXISTS pay_us.document_types ( type text, value text, archived boolean, label text, regions list<text>, PRIMARY KEY (type, value) ) WITH CLUSTERING ORDER BY (value ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay_us.individuals ( id text, annual_income text, annual_income_currency text, archived boolean, company_country text, company_country_of_incorporation text, company_date_of_incorporation text, company_legal_name text, company_physical_address frozen<address_v2>, company_registered_address frozen<address_v2>, company_registration_number text, country text, date_of_birth text, document_country_of_issue text, document_expiration_date text, document_issue_date text, documents list<frozen<onboarding_document>>, email text, first_name text, id_number text, identification_document_type text, individuals list<text>, is_business_representative boolean, is_director boolean, is_nominee_shareholder boolean, is_shareholder boolean, last_name text, middle_name text, nationality text, other_activities_details text, pep boolean, percentage_of_shares text, phone_number text, place_of_birth text, proof_of_residence_document_type text, residential_address frozen<address_v2>, significant_responsibility boolean, size_of_wealth text, size_of_wealth_currency text, social_media list<frozen<social_media>>, source_of_income text, source_of_wealth text, ssn text, title text, type text, verification_checks list<frozen<verification_check>>, PRIMARY KEY (id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay_us.individuals_v2 ( company_id text, merchant_id text, id text, annual_income text, annual_income_currency text, archived boolean, company_country text, company_country_of_incorporation text, company_date_of_incorporation text, company_legal_name text, company_physical_address frozen<address_v2>, company_registered_address frozen<address_v2>, company_registration_number text, country text, date_of_birth text, document_country_of_issue text, document_expiration_date text, document_issue_date text, documents list<frozen<onboarding_document>>, email text, first_name text, id_number text, identification_document_type text, individuals list<text>, is_business_representative boolean, is_director boolean, is_nominee_shareholder boolean, is_shareholder boolean, last_name text, middle_name text, nationality text, other_activities_details text, pep boolean, percentage_of_shares text, phone_number text, place_of_birth text, proof_of_residence_document_type text, residential_address frozen<address_v2>, significant_responsibility boolean, size_of_wealth text, size_of_wealth_currency text, social_media list<frozen<social_media>>, source_of_income text, source_of_income_other text, source_of_wealth text, source_of_wealth_other text, ssn text, title text, type text, verification_checks list<frozen<verification_check>>, PRIMARY KEY (company_id, merchant_id, id) ) WITH CLUSTERING ORDER BY (merchant_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay_us.merchant_applications ( company_id text, merchant_id text, version int, acquiring_services list<text>, approval_date text, authorized_business_representative text, automatic_review boolean, bank_details frozen<onboarding_bank_details>, business_activity frozen<onboarding_business_activity>, business_details frozen<onboarding_business_details>, business_processing_info frozen<business_processing_info>, business_review text, business_structure_details frozen<business_structure_details>, channel text, contract_agreement_date text, created_at text, created_by text, created_by_system text, customer_support frozen<customer_support>, decline_details frozen<decline_details>, documents list<frozen<onboarding_document>>, enrollment_date text, fulfillment_details frozen<fulfillment_details>, heard_of_pay_from text, individuals list<text>, last_updated text, notes list<frozen<note>>, onboarding_channel frozen<onboarding_channel>, other_communications boolean, owner text, pay_legal_entity frozen<set<text>>, payment_requirements text, paypass_link_created_at text, paypass_link_created_by text, paypass_link_created_by_system text, paypass_submitted_at text, priority tinyint, privacy_policy_agreement boolean, provider_data frozen<provider_data>, risk frozen<risk>, risk_score text, sales_assignee text, settlement_terms frozen<entity_settlement_terms>, shadow_purchase text, short_descriptor text, stage tinyint, status text, test boolean, underwriting_assignee text, underwriting_info frozen<underwriting_info>, verification_checks list<frozen<verification_check>>, PRIMARY KEY (company_id, merchant_id, version) ) WITH CLUSTERING ORDER BY (merchant_id DESC, version DESC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
}

async fn create_tables_pay(db) {
    // Note: 30 tables have CDC enabled
    db.execute("CREATE TABLE IF NOT EXISTS pay.acquirer_bins ( acquirer text, scheme text, bin text, PRIMARY KEY (acquirer, scheme) ) WITH CLUSTERING ORDER BY (scheme ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.addresses ( consumer_id text, id text, address frozen<address_v2>, company_id text, hash text, merchant_id text, PRIMARY KEY (consumer_id, id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'ZstdWithDictsCompressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.adjustments ( company_id text, merchant_id text, id text, amount text, assigned_to_settlement text, bank_transfer_reference text, category text, currency text, date_time text, description text, identifier text, provider text, quantity int, settlement_id text, total text, vatable boolean, PRIMARY KEY ((company_id, merchant_id), id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'false', 'preimage': 'false', 'ttl': '86400'} AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.aircash_credentials ( merchant_id text, aircash_partner_id text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.api_keys ( id text, api_key_hash text, company_id text, ip_ranges text, merchant_id text, site_id text, PRIMARY KEY (id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.api_keys_v2 ( id text, allowed_endpoints map<text, text>, api_key_encrypted text, company_id text, enabled boolean, ip_ranges text, last_six_digits text, merchant_id text, name text, pci_compliant boolean, PRIMARY KEY (id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.apm_configurations ( payment_method_type text, provider text, call_gateway boolean, call_initialize_on_stored_pm boolean, color text, fields list<frozen<custom_fields_v2>>, footer frozen<apm_frontend_content>, grid_icon text, grid_selected_background_color text, header frozen<apm_frontend_content>, icon text, name text, redirect boolean, type text, PRIMARY KEY (payment_method_type, provider) ) WITH CLUSTERING ORDER BY (provider ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.applepay_credentials ( merchant_id text, applepay_cert text, applepay_key text, applepay_merchant_identifier text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.approvals ( id text, allowed_approvers_group text, approver text, description text, signal_name text, status text, status_date text, status_reason text, temporal_namespace text, title text, workflow_id text, PRIMARY KEY (id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.aps_credentials ( merchant_id text, aps_credentials_by_currency frozen<map<text, frozen<aps_tokens>>>, aps_payout_credentials_by_currency frozen<map<text, frozen<aps_tokens>>>, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.bank_accounts ( company_id text, merchant_id text, id text, account_identifier text, account_number text, account_type text, archived boolean, bank text, bank_country text, bank_name text, currency text, iban text, master frozen<master_account_details>, provider text, region text, routing_number text, sort_code text, swift_bic text, type text, virtual boolean, PRIMARY KEY ((company_id, merchant_id), id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.bank_holidays ( provider text, currency text, date text, name text, PRIMARY KEY (provider, currency, date) ) WITH CLUSTERING ORDER BY (currency ASC, date ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.bank_transfers ( id text, account_id text, account_identifier text, account_number text, amount text, bank text, charge_bearer text, company_id text, counterparty_account_id text, counterparty_account_identifier text, counterparty_account_number text, counterparty_bank text, counterparty_company_id text, counterparty_currency text, counterparty_iban text, counterparty_master frozen<master_account_details>, counterparty_merchant_id text, counterparty_provider text, counterparty_region text, counterparty_routing_number text, counterparty_sort_code text, counterparty_swift_bic text, counterparty_type text, created_at text, currency text, direction text, iban text, master frozen<master_account_details>, merchant_id text, operation text, provider text, rail text, region text, routing_number text, sort_code text, status text, swift_bic text, transfer_reference text, transfer_type text, type text, updated_at text, value_date text, PRIMARY KEY (id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.banks ( currency text, country text, provider text, provider_bank_id text, bank_name text, custom_fields list<frozen<custom_fields_v2>>, enabled boolean, id text, logo_url text, priority int, qr_code text, requires_consent boolean, show_qr boolean, supported_types list<text>, PRIMARY KEY (currency, country, provider, provider_bank_id) ) WITH CLUSTERING ORDER BY (country ASC, provider ASC, provider_bank_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.bins ( display_bin text, card_product text, is_oct_support boolean, is_visa_direct_ff_support boolean, issuer_name text, range_high text, range_low text, PRIMARY KEY (display_bin) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.braintree_credentials ( merchant_id text, account_id_by_currency frozen<map<text, text>>, braintree_merchant_id text, private_key text, public_key text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.cardinal_credentials ( merchant_id text, org_unit_id text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.cards ( merchant_id text, consumer_id text, method_token text, billing_details frozen<address>, bin text, expiry_month text, expiry_year text, issuer_name text, last_four_digits text, name text, PRIMARY KEY ((merchant_id, consumer_id), method_token) ) WITH CLUSTERING ORDER BY (method_token ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.cdc_progress_table ( generation timestamp, application_name text, table_name text, stream_id blob, current_generation timestamp, last_timestamp timeuuid, PRIMARY KEY ((generation, application_name, table_name, stream_id)) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.cdc_to_workflow_configs ( table_name text, workflow_name text, id text, condition_params text, signal_condition_params text, signal_name text, signal_values list<text>, workflow_id_unique_key text, workflow_task_queue text, workflow_values list<text>, PRIMARY KEY (table_name, workflow_name, id) ) WITH CLUSTERING ORDER BY (workflow_name ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.centrobill_credentials ( merchant_id text, centrobill_api_key text, centrobill_merchant_id text, centrobill_site_id text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.channels ( channel_code text, aml_rank_eu tinyint, aml_rank_us tinyint, channel_description text, PRIMARY KEY (channel_code) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.chargeback_reasons ( network text, code text, category text, code_usa_or_ca text, reason_description text, reason_title text, required_documentation text, PRIMARY KEY (network, code) ) WITH CLUSTERING ORDER BY (code ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.checkout_credentials ( merchant_id text, api_key text, currency_account_id_by_currency frozen<map<text, text>>, processing_channel_id text, webhook_secret_key text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.coinify_credentials ( merchant_id text, api_key text, sub_account_id text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.collaborations ( company_id text, date text, id text, amount text, created_at text, currency text, merchant_id text, network text, processor text, processor_reference_id text, refundable_until_date text, source text, status text, transaction_date_time text, transaction_id text, updated_at text, PRIMARY KEY ((company_id, date), id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.commissions ( id text, default_commission_basis_points text, email text, name text, PRIMARY KEY (id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.companies ( id text, bank_details frozen<bank_details>, billing_details frozen<address_v2>, business_details frozen<business_details>, contact_info frozen<contact_info>, mailing_address frozen<address_v2>, name text, PRIMARY KEY (id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.connections ( merchant_id text, partner_key text, completed boolean, enabled boolean, enabled_at text, error_message text, partner_account_identifier text, updated_at text, PRIMARY KEY (merchant_id, partner_key) ) WITH CLUSTERING ORDER BY (partner_key ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.connections_v1 ( merchant_id text, partner_key text, provider text, routing_key text, completed boolean, enabled boolean, enabled_at text, error_message text, partner_account_identifier text, updated_at text, PRIMARY KEY (merchant_id, partner_key, provider, routing_key) ) WITH CLUSTERING ORDER BY (partner_key ASC, provider ASC, routing_key ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.consumers ( time text, id text, merchant_id text, site_id text, billing_details_ids list<text>, company_id text, default_source text, email text, first_name text, last_name text, last_transaction_date timestamp, merchant_consumer_id text, phone text, shipping_details_ids list<text>, terms_and_conditions_accepted_on_transaction text, PRIMARY KEY (time, id, merchant_id, site_id) ) WITH CLUSTERING ORDER BY (id ASC, merchant_id ASC, site_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.consumers_v2 ( merchant_id text, time text, id text, billing_details_ids list<text>, company_id text, default_source text, deleted boolean, dob text, email text, excluded_rules_ids list<text>, first_name text, first_transaction_date text, ignored_rules_ids list<text>, internal_metadata map<text, text>, last_name text, last_transaction_date text, merchant_consumer_id text, metadata map<text, text>, national_identification_number text, phone text, shipping_details_ids list<text>, tax_id text, terms_and_conditions_accepted_on_transaction text, PRIMARY KEY ((merchant_id, time), id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'ZstdWithDictsCompressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'false', 'preimage': 'false', 'ttl': '86400'} AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.costs ( provider text, action text, basis_fee_description text, basis_points text, cost_type_basis_points text, cost_type_fixed text, currency text, fixed_fee text, fixed_fee_description text, rev_share_fixed_percentage text, PRIMARY KEY (provider, action) ) WITH CLUSTERING ORDER BY (action ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.costs_v2 ( provider text, payment_method_type text, action text, currency text, basis_fee_description text, basis_points text, cost_type_basis_points text, cost_type_fixed text, fixed_fee text, fixed_fee_description text, rev_share_basis_points_percentage text, rev_share_fixed_percentage text, PRIMARY KEY ((provider, payment_method_type), action, currency) ) WITH CLUSTERING ORDER BY (action ASC, currency ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.countries ( alpha2 text, enabled boolean, high_risk_bin boolean, high_risk_ip boolean, name text, numeric int, ofac_sanction_program boolean, phone_prefix int, prohibited boolean, region text, risk_level tinyint, subcontinent text, supported_merchant_jurisdiction boolean, PRIMARY KEY (alpha2) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.credorax_credentials ( merchant_id text, credorax_merchant_id text, credorax_secret text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.crm_fields ( id text, created_at text, description text, form_type text, input_type text, label text, options list<frozen<custom_fields_options>>, placeholder text, type text, validation frozen<custom_fields_validation>, PRIMARY KEY (id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.crm_fields_values ( company_id text, merchant_id text, key text, boolean_value boolean, created_at text, json_value text, list_value list<text>, number_value int, string_value text, updated_at text, PRIMARY KEY ((company_id, merchant_id), key) ) WITH CLUSTERING ORDER BY (key ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.currencies ( alpha3 text, digits_after_point int, exponent int, locations_using text, name text, numeric int, PRIMARY KEY (alpha3) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.declines ( company_id text, merchant_id text, card_token text, transaction_id text, attempt_id text, category text, created_at text, decline_code text, PRIMARY KEY ((company_id, merchant_id), card_token, transaction_id, attempt_id) ) WITH CLUSTERING ORDER BY (card_token ASC, transaction_id ASC, attempt_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.disputes ( merchant_id text, date text, id text, accepted_reason text, amount text, arn text, attempt int, company_id text, consumer_id text, currency text, dispute_network_reference text, disputed_payment text, disputed_transaction text, evidence evidence_references, evidence_required_by text, is_partial boolean, last_update text, mid text, network text, network_dispute_id text, processor text, processor_dispute_id text, reason text, reason_code text, received_on text, status text, PRIMARY KEY ((merchant_id, date), id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.document_types ( type text, value text, archived boolean, default_document_tags frozen<set<text>>, label text, regions list<text>, PRIMARY KEY (type, value) ) WITH CLUSTERING ORDER BY (value ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.documents ( merchant_id text, path text, id text, company_id text, content_length int, content_type text, last_modified text, original_filename text, reference text, status text, type text, PRIMARY KEY ((merchant_id, path), id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.ecp_credentials ( merchant_id text, ecp_password text, ecp_tokens_by_currency frozen<map<text, frozen<ecp_tokens>>>, ecp_username text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.email_templates ( id text, content text, created_at text, name text, parent_id text, subject text, updated_at text, PRIMARY KEY (id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.epx_credentials ( merchant_id text, epx_cust_number text, epx_dba_number text, epx_merchant_number text, epx_terminal_number text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.evidences ( dispute_id text, id text, files frozen<set<text>>, received_on text, text text, type text, PRIMARY KEY (dispute_id, id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.exchange_rates ( base_currency text, quote_currency text, close_ask int, close_bid int, close_midpoint int, close_time timestamp, PRIMARY KEY (base_currency, quote_currency) ) WITH CLUSTERING ORDER BY (quote_currency ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.export_fields ( table_name text, field_key text, category text, field_description text, field_name text, is_default boolean, priority tinyint, PRIMARY KEY (table_name, field_key) ) WITH CLUSTERING ORDER BY (field_key ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.fees ( transaction_key text, id text, apply_as_network_fee boolean, bank_transfer_reference text, basis_points text, blended boolean, clearing_date text, collected boolean, commission_id text, company_id text, conversion_rate text, cost_type text, created_at text, estimated boolean, fee_description text, fee_identifier text, fee_type text, gross boolean, gross_invoice_id text, internal_metadata map<text, text>, is_basis_points boolean, merchant_excluded boolean, merchant_id text, payment_id text, payment_method_type text, pricing_segment_code text, processing_currency text, processing_currency_amount text, provider text, recurring boolean, referral_buy_rate_basis_points text, referral_buy_rate_basis_points_amount text, referral_buy_rate_fixed text, referral_exchange_rate text, referral_id text, referral_rev_share_tier_basis_points text, referral_rev_share_tier_name text, reseller_id text, settlement_account_id text, settlement_currency text, settlement_currency_amount text, settlement_id text, tier_strategy_id text, time_hourly text, transaction_attempt_id text, transaction_id text, transaction_provider text, transaction_settlement_currency_amount text, transaction_timestamp text, transaction_type text, updated_at text, PRIMARY KEY (transaction_key, id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'ZstdWithDictsCompressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'false', 'preimage': 'false', 'ttl': '86400'} AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.finance_settings ( company_id text, merchant_id text, commission_setup set<frozen<finance_commission_setup>>, referral_id text, PRIMARY KEY (company_id, merchant_id) ) WITH CLUSTERING ORDER BY (merchant_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.fonix_credentials ( merchant_id text, fonix_api_key text, fonix_credentials frozen<map<text, frozen<fonix_services_credentials>>>, fonix_originator_number text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.global_kv_store ( key text, value text, PRIMARY KEY (key) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.googlepay_credentials ( merchant_id text, googlepay_merchant_id text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.gumballpay_credentials ( merchant_id text, control_key text, endpoint_group_id text, endpoint_id text, gumballpay_payout_credentials frozen<gumballpay_tokens>, username text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.idempotency_keys ( idemp_key text, request text, response text, route text, status text, PRIMARY KEY (idemp_key) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'TimeWindowCompactionStrategy'} AND compression = {'sstable_compression': 'ZstdWithDictsCompressor'} AND crc_check_chance = 1 AND default_time_to_live = 86400 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.jti_blacklist ( token_jti text, PRIMARY KEY (token_jti) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.legal_entities ( company_id text, id text, application_status text, billing_address frozen<address_v2>, company_number text, contact_info list<frozen<entity_contact_info>>, continent text, created_at text, dba_name text, mcc int, name text, registered_address frozen<address_v2>, tax_identifier text, updated_at text, PRIMARY KEY (company_id, id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.limits ( company_id text, merchant_id text, maximum_payment_amount text, minimum_payment_amount text, payment_methods_options frozen<payment_methods_options_limits>, PRIMARY KEY (company_id, merchant_id) ) WITH CLUSTERING ORDER BY (merchant_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.logic_fields ( identifier text, key text, additional_settings frozen<logic_fields_additional_settings>, category_name text, created_at text, default_value text, internal boolean, label text, list_types frozen<set<text>>, only_for_outcomes_categories frozen<set<text>>, options frozen<list<frozen<logic_field_options>>>, placeholder text, regex text, sub_key boolean, updated_at text, value_field_type text, PRIMARY KEY (identifier, key) ) WITH CLUSTERING ORDER BY (key ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.mcc ( mcc int, aml_rank tinyint, description text, enabled boolean, exposure_factor double, exposure_risk_category text, primary_category text, risk_tier tinyint, PRIMARY KEY (mcc) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.merchant_default_export_fields ( company_id text, merchant_id text, table_name text, export_fields_keys list<text>, PRIMARY KEY (company_id, merchant_id, table_name) ) WITH CLUSTERING ORDER BY (merchant_id ASC, table_name ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.merchant_mids ( acquirer text, company_id text, merchant_id text, scheme text, acquirer_mid text, scheme_mid text, PRIMARY KEY (acquirer, company_id, merchant_id, scheme) ) WITH CLUSTERING ORDER BY (company_id ASC, merchant_id ASC, scheme ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.merchants ( company_id text, id text, acquirer list<text>, activation_date text, api_resources_gates map<text, boolean>, application_status text, assignee text, automatic_review boolean, billing_details frozen<address_v2>, branding frozen<branding>, business_details frozen<business_details>, consumer_payouts_enabled boolean, contact_info frozen<contact_info>, continent text, costs_provider_override map<text, text>, country text, currency_code text, currency_to_settlement_account map<text, text>, default_3ds_processor text, default_processor text, default_processor_amex text, default_processor_discover text, default_processor_map map<text, text>, default_processor_mastercard text, default_processor_visa text, default_settlement_account_id text, descriptor text, doing_business_as text, entity_id text, feature_flags map<text, boolean>, frontegg_tenant_id text, gateway list<text>, last_updated text, merchant_status text, metadata map<text, text>, name text, override_onboarding_merchant_id text, payfac list<text>, payment_methods_options_defaults frozen<payment_method_options>, processing_currency_codes list<text>, processing_risk_score text, processing_to_settlements_currency_codes frozen<map<text, text>>, reference text, settlement_currency_codes list<text>, stage int, status text, tenant text, test_merchant boolean, PRIMARY KEY (company_id, id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.monek_credentials ( merchant_id text, monek_merchant_id text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.nets_credentials ( merchant_id text, nets_merchant_id text, nets_merchant_secret text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.notes ( company_id text, merchant_id text, transaction_id text, note_id text, content text, created_at text, modified_at text, pinned boolean, user_display_name text, user_id text, PRIMARY KEY ((company_id, merchant_id, transaction_id), note_id) ) WITH CLUSTERING ORDER BY (note_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.notification_subscriptions ( company_id text, merchant_id text, user_id text, notification_type text, created_at text, delivery_config frozen<notification_subscription_delivery_config>, updated_at text, PRIMARY KEY (company_id, merchant_id, user_id, notification_type) ) WITH CLUSTERING ORDER BY (merchant_id ASC, user_id ASC, notification_type ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.notifications ( notification_type text, active boolean, created_at text, delivery_config frozen<notification_delivery_config>, description text, name text, updated_at text, PRIMARY KEY (notification_type) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.nuvei_credentials ( merchant_id text, nuvei_dispute_password text, nuvei_dispute_secret text, nuvei_dispute_username text, nuvei_merchant_host text, nuvei_merchant_id text, nuvei_merchant_secret_key text, nuvei_merchant_site_id text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.okto_credentials ( merchant_id text, okto_api_key text, okto_url_host text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.onboarding_approvals ( merchant_id text, company_id text, id text, aml_risk_category text, comments text, conditions text, created_at text, group_assigned text, name text, record_type text, requested_by_task text, role text, status text, submitted_by text, submitted_date text, PRIMARY KEY ((merchant_id, company_id), id) ) WITH CLUSTERING ORDER BY (id DESC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.openfinance_credentials ( merchant_id text, api_key text, api_secret text, open_finance_merchant text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.partners ( category_id text, partner_key text, countries frozen<set<text>>, description_long text, description_micro text, description_short text, documentation_uri text, enable_all_countries boolean, icon text, partner_display_name text, PRIMARY KEY (category_id, partner_key) ) WITH CLUSTERING ORDER BY (partner_key ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.partners_categories ( category_id text, category_description text, category_name text, PRIMARY KEY (category_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.payfuture_credentials ( merchant_id text, midcode text, midsecret text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.payment_control ( company_id text, merchant_id text, currency map<text, frozen<processor_config>>, hours map<text, frozen<payment_control_hours>>, transaction_types map<text, frozen<processor_transaction_type_config>>, PRIMARY KEY (company_id, merchant_id) ) WITH CLUSTERING ORDER BY (merchant_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.payment_control_snapshots ( key text, id text, attempt_id text, default_3ds_processor text, default_processor text, default_processor_amex text, default_processor_discover text, default_processor_map map<text, text>, default_processor_mastercard text, default_processor_visa text, retry_providers list<text>, PRIMARY KEY (key, id, attempt_id) ) WITH CLUSTERING ORDER BY (id ASC, attempt_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'ZstdWithDictsCompressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.payment_control_v2 ( company_id text, settlement_account_id text, merchant_id text, currency map<text, frozen<processor_config>>, hours map<text, frozen<payment_control_hours>>, transaction_types map<text, frozen<processor_transaction_type_config>>, PRIMARY KEY (company_id, settlement_account_id, merchant_id) ) WITH CLUSTERING ORDER BY (settlement_account_id ASC, merchant_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.payment_method_options ( key text, id text, attempt_id text, applepay frozen<payment_method_options_applepay_v2>, authentication_options frozen<authentication_options>, bank_account frozen<payment_method_options_bank_v2>, card frozen<card_method_options_v2>, decline_recovery frozen<decline_recovery_settings>, disabled_payment_methods_types list<text>, googlepay frozen<payment_method_options_googleplay_v2>, payout_method_options frozen<payout_method_options>, paypal frozen<paypal_method_options_v2>, risk_control list<frozen<risk_control_payment_method_options>>, routing_methodologies list<text>, types list<text>, us_bank_account frozen<us_bank_account_method_options_v2>, PRIMARY KEY (key, id, attempt_id) ) WITH CLUSTERING ORDER BY (id ASC, attempt_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'ZstdWithDictsCompressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.payment_method_options_configs ( company_id text, merchant_id text, id text, applepay frozen<payment_method_options_applepay_v2>, authentication_options frozen<authentication_options>, bank_account frozen<payment_method_options_bank_v2>, card frozen<card_method_options_v2>, created_at text, default_config boolean, disabled_payment_methods_types list<text>, googlepay frozen<payment_method_options_googleplay_v2>, name text, neteller frozen<skrill_neteller_payment_method_options>, payout_method_options frozen<payout_method_options>, paypal frozen<paypal_method_options_v2>, routing_methodologies list<text>, skrill frozen<skrill_neteller_payment_method_options>, types list<text>, updated_at text, us_bank_account frozen<us_bank_account_method_options_v2>, PRIMARY KEY (company_id, merchant_id, id) ) WITH CLUSTERING ORDER BY (merchant_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.paymentlinks ( company_id text, merchant_id text, id text, after_completion frozen<after_completion>, amount text, amount_limits frozen<payment_link_amount_limits>, available_payment_methods list<text>, collection frozen<collection>, created_at text, currency text, custom_fields list<frozen<custom_fields_v2>>, custom_text frozen<custom_text>, description text, duration int, is_deleted boolean, link text, max_attempts int, name text, payment_method_options frozen<payment_method_options>, send_receipt boolean, statement_descriptor_suffix text, type text, updated_at text, PRIMARY KEY (company_id, merchant_id, id) ) WITH CLUSTERING ORDER BY (merchant_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.paynt_credentials ( merchant_id text, account_id text, api_key text, entity_id text, password text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.paypal_credentials ( merchant_id text, paypal_merchant_email text, paypal_merchant_id text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.paypal_payers ( merchant_id text, consumer_id text, email text, address frozen<address>, dob text, first_name text, last_name text, payer_id text, phone text, PRIMARY KEY ((merchant_id, consumer_id), email) ) WITH CLUSTERING ORDER BY (email ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.paysafe_credentials ( merchant_id text, account_id_by_currency map<text, frozen<map<text, text>>>, paysafe_password text, paysafe_username text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.paysafecard_credentials ( merchant_id text, paysafecard_submerchant_id text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.permissions ( key text, category text, created_at text, name text, updated_at text, PRIMARY KEY (key) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.ppro_credentials ( merchant_id text, contract_id text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.pricing ( company_id text, merchant_id text, actions map<text, frozen<pricing_action_object>>, blended boolean, created_at text, currency text, funding_delay text, maximum_held_reserve text, rolling_reserve_amount text, rolling_reserve_duration text, rolling_reserve_enabled boolean, rolling_reserve_type text, PRIMARY KEY (company_id, merchant_id) ) WITH CLUSTERING ORDER BY (merchant_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.pricing_actions ( action text, created_at text, description text, forbidden_with frozen<set<text>>, updated_at text, PRIMARY KEY (action) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.pricing_v2 ( company_id text, merchant_id text, provider text, actions map<text, frozen<pricing_action_object>>, additional_configuration frozen<pricing_additional_configuration>, additional_cost_providers list<text>, alternative_currencies map<text, frozen<pricing_alternative_currencies_v2>>, alternative_payment_methods map<text, frozen<pricing_alternative_payment_methods>>, blended boolean, created_at text, currency text, funding_delay text, maximum_held_reserve text, monthly_merchant_fee text, monthly_minimum_fee text, override_gross_fixed_currency text, rolling_reserve_amount text, rolling_reserve_duration text, rolling_reserve_enabled boolean, rolling_reserve_type text, settlement_day int, settlement_fees map<text, frozen<pricing_action_object>>, settlement_schedule text, updated_at text, PRIMARY KEY (company_id, merchant_id, provider) ) WITH CLUSTERING ORDER BY (merchant_id ASC, provider ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.pricing_v3 ( company_id text, settlement_account_id text, currency text, payment_method_type text, merchant_id text, actions map<text, frozen<pricing_action_object>>, additional_configuration frozen<pricing_additional_configuration>, additional_cost_providers list<text>, alternative_currencies map<text, frozen<pricing_alternative_currencies_v2>>, alternative_payment_methods map<text, frozen<pricing_alternative_payment_methods>>, blended boolean, created_at text, funding_delay text, maximum_held_reserve text, monthly_merchant_fee text, monthly_minimum_fee text, override_gross_fixed_currency text, provider text, rolling_reserve_amount text, rolling_reserve_duration text, rolling_reserve_enabled boolean, rolling_reserve_type text, settlement_day int, settlement_fees map<text, frozen<pricing_action_object>>, settlement_schedule text, updated_at text, PRIMARY KEY (company_id, settlement_account_id, currency, payment_method_type, merchant_id) ) WITH CLUSTERING ORDER BY (settlement_account_id ASC, currency ASC, payment_method_type ASC, merchant_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.providers ( key text, address text, disable_ssl boolean, port text, PRIMARY KEY (key) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.providers_features ( provider text, amex boolean, authorization boolean, cancel_multiple boolean, cancel_partial boolean, capture_multiple boolean, capture_partial boolean, default_precision text, discover boolean, external_settlement boolean, incremental_authorization boolean, interchange_fee_cost_type text, internal_settlement boolean, mastercard boolean, network_fee_cost_type text, payout boolean, processing_currency_codes list<text>, processing_to_settlements_currency_codes frozen<map<text, text>>, refund_multiple boolean, refund_partial boolean, sale boolean, settlement_currency_codes list<text>, verification boolean, visa boolean, PRIMARY KEY (provider) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.providers_features_v2 ( provider text, payment_method_type text, acquiring_setup text, amex boolean, authorization boolean, cancel_multiple boolean, cancel_partial boolean, capture_multiple boolean, capture_partial boolean, clearing_date_correction text, declines_recovery_map frozen<map<text, text>>, default_precision text, discover boolean, external_settlement boolean, incremental_authorization boolean, interchange_fee_cost_type text, internal_exemption boolean, internal_exemption_trigger_issuer_codes list<text>, internal_settlement boolean, mastercard boolean, max_amount text, min_amount text, network_fee_cost_type text, network_tokens boolean, network_tokens_fallback_decline_codes list<text>, payout boolean, processing_currency_codes list<text>, processing_to_settlements_currency_codes frozen<map<text, text>>, refund boolean, refund_multiple boolean, refund_partial boolean, retryable_decline_codes list<text>, sale boolean, settlement_currency_codes list<text>, skip_new_attempt boolean, timezone text, valid_for text, valid_for_since text, verification boolean, visa boolean, PRIMARY KEY (provider, payment_method_type) ) WITH CLUSTERING ORDER BY (payment_method_type ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.providers_mapping ( short_value text, field_name text, provider text, original_value text, PRIMARY KEY (short_value, field_name, provider) ) WITH CLUSTERING ORDER BY (field_name ASC, provider ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.receipts ( transaction_id text, company_id text, id text, amount_received text, amount_refunded text, created_at text, deliveries set<frozen<receipt_delivery_record>>, filename text, funds_status text, PRIMARY KEY ((transaction_id, company_id), id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.reconciliation_config ( regex text, enabled boolean, example text, namespace text, params map<text, frozen<reconciliation_config_params>>, provider text, queue boolean, reconciliation_type text, successor_workflow text, task_queue text, unique_id_regex text, workflow text, PRIMARY KEY (regex) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.reconciliations ( provider text, id text, dry_run boolean, end_date text, failure_reason text, filename text, reconciliation_type text, start_date text, status text, transactions_count text, transactions_count_failure text, transactions_count_success text, PRIMARY KEY (provider, id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.referrals ( id text, actions map<text, frozen<pricing_action_object>>, alternative_currencies map<text, frozen<pricing_alternative_currencies_v2>>, alternative_payment_methods map<text, frozen<pricing_alternative_payment_methods>>, commission_setup set<frozen<finance_commission_setup>>, currency text, enabled boolean, expires_in_years int, name text, period_count_starts_from text, rev_share_tiers set<frozen<finance_rev_share_tiers>>, settlement_fees map<text, frozen<pricing_action_object>>, PRIMARY KEY (id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.refresh_token_blacklist ( refresh_token text, PRIMARY KEY (refresh_token) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.report_pull_config ( provider text, id text, access_type text, company_id text, created_at text, credentials text, destination_folder text, enabled boolean, file_date_regex text, file_type_filter text, format_file boolean, host text, merchant_ids list<text>, merge_files boolean, params map<text, frozen<reconciliation_config_params>>, password text, port text, private_key text, raw_data_folder text, source_folder text, type text, updated_at text, username text, PRIMARY KEY (provider, id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.reports ( company_id text, merchant_id text, id text, active boolean, columns map<text, frozen<list<text>>>, created_at text, distribution_method text, emails list<text>, end_period text, filters set<frozen<filter_field>>, format text, frequency text, last_update text, name text, recurrence_period recurring_time_settings, start_period text, type text, PRIMARY KEY (company_id, merchant_id, id) ) WITH CLUSTERING ORDER BY (merchant_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.reports_config ( company_id text, merchant_id text, custom_fields frozen<map<text, frozen<list<text>>>>, default_config frozen<report_config>, enabled_reports list<text>, exclude_fields frozen<map<text, frozen<list<text>>>>, per_report_config_override map<text, frozen<report_config>>, rename_fields frozen<map<text, frozen<rename_fields_type>>>, PRIMARY KEY (company_id, merchant_id) ) WITH CLUSTERING ORDER BY (merchant_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.reserves ( company_id text, merchant_id text, settlement_id text, id text, created_at text, currency text, current_amount text, duration text, original_amount text, percentage text, planned_release_date text, released_at text, released_settlement_id text, status text, updated_at text, PRIMARY KEY (company_id, merchant_id, settlement_id, id) ) WITH CLUSTERING ORDER BY (merchant_id ASC, settlement_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.reserves_v1 ( company_id text, settlement_config_id text, id text, amount text, bank_transfer_reference text, created_at text, currency text, merchant_id text, planned_release_date text, released boolean, released_at text, released_settlement_id text, settlement_id text, status text, updated_at text, PRIMARY KEY (company_id, settlement_config_id, id) ) WITH CLUSTERING ORDER BY (settlement_config_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.risk_alerts ( company_id text, merchant_id text, id text, actions_to_be_taken text, alert_name text, alert_notes list<frozen<note>>, category text, customer frozen<risk_alert_customer>, escalation_reason text, evaluated_at text, evaluation_report frozen<evaluation_report>, issue_link text, last_updated_by text, last_updated_on text, priority text, resolve_reason text, rule_id text, seen boolean, status_list list<frozen<risk_alert_status_details>>, suspicion_report frozen<suspicion_report>, triggered_previously int, triggering_transaction_id text, uniqueness_params map<text, text>, PRIMARY KEY (company_id, merchant_id, id) ) WITH CLUSTERING ORDER BY (merchant_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.risk_calculations ( company_id text, merchant_id text, id text, calculated_at text, calculated_by text, details list<frozen<risk_calculation_details>>, reason text, score text, score_type text, PRIMARY KEY ((company_id, merchant_id), id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.risk_lists ( company_id text, merchant_id text, id text, alias text, allow_updates_to_groups list<text>, created_at text, created_by text, is_user_generated boolean, items int, name text, type text, updated_at text, updated_by text, PRIMARY KEY ((company_id, merchant_id), id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.risk_lists_values ( company_id text, merchant_id text, list_id text, id text, created_at text, created_by text, metadata map<text, text>, updated_at text, updated_by text, value text, PRIMARY KEY ((company_id, merchant_id, list_id), id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.roles ( company_id text, merchant_id text, name text, created_at text, description text, permissions list<text>, updated_at text, PRIMARY KEY (company_id, merchant_id, name) ) WITH CLUSTERING ORDER BY (merchant_id ASC, name ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.rules ( company_id text, merchant_id text, id text, alert_frequency text, alert_uniqueness_params list<text>, allow_updates_to_groups list<text>, archived boolean, category text, created_by text, default_risk_alert_category text, description text, dry_run boolean, enabled boolean, excludable boolean, failure_code text, failure_reason text, fallback_config frozen<fallback_config>, global_aggregation boolean, internal_rule boolean, last_updated text, logic text, logic_client text, outcome text, outcome_details_by_range frozen<list<frozen<outcome_details_by_range>>>, outcomes list<text>, payment_method_config_id text, payment_methods_options frozen<payment_method_options>, payment_methods_options_v2 frozen<payment_method_options_v2>, post_external_risk_check boolean, priority text, processor_config frozen<processor_config>, risk_score_modifier text, routing_priority int, rule_level text, rule_priority float, scoping_logic text, system_rule boolean, PRIMARY KEY (company_id, merchant_id, id) ) WITH CLUSTERING ORDER BY (merchant_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.rules_run_cache ( key text, rule_id text, PRIMARY KEY (key, rule_id) ) WITH CLUSTERING ORDER BY (rule_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 86400 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.safecharge_credentials ( site_id text, sfc_merchant_id text, sfc_secret text, sfc_site_id text, PRIMARY KEY (site_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.service_fees ( company_id text, merchant_id text, id text, amount text, collected boolean, commission_id text, cost_type text, created_at text, currency text, fee_description text, fee_identifier text, fee_type text, gross boolean, gross_invoice_id text, provider text, referral_id text, reseller_id text, settlement_id text, updated_at text, PRIMARY KEY (company_id, merchant_id, id) ) WITH CLUSTERING ORDER BY (merchant_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.settings ( company_id text, merchant_id text, checkout_sdk_config text, collection_defaults frozen<collection>, cta_text text, cybersource_risk_config list<frozen<cybersource_risk_interval>>, default_payment_method_options_id text, default_risk_control list<frozen<risk_control_payment_method_options>>, fallback_url text, locale text, metadata_quick_search_keys list<text>, payment_methods_options_defaults frozen<payment_method_options>, payment_methods_options_defaults_v2 frozen<payment_method_options_v2>, providers_config map<text, text>, PRIMARY KEY (company_id, merchant_id) ) WITH CLUSTERING ORDER BY (merchant_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.settlement_account_balances ( settlement_account_id text, currency text, net_amount text, updated_at text, PRIMARY KEY (settlement_account_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.settlement_account_mids ( company_id text, settlement_account_id text, scheme text, currency text, bin text, caid text, created_at text, mcc text, updated_at text, PRIMARY KEY (company_id, settlement_account_id, scheme, currency) ) WITH CLUSTERING ORDER BY (settlement_account_id ASC, scheme ASC, currency ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.settlement_config ( company_id text, id text, acceptance_currencies set<text>, bank_account_id text, bank_account_merchant_id text, billing_address frozen<address_v2>, conversion_price_per_currency map<text, text>, country text, created_at text, currency text, default_processor text, descriptor text, enabled boolean, enabled_transfer_types set<text>, entity_id text, entity_name text, fallback_failure_codes set<text>, fallback_settlement_account_id text, funding_delay int, global_conversion_price text, intermediary_bank_account_id text, intermediary_bank_account_merchant_id text, intermediary_provider text, maximum_held_reserve text, mcc text, merchant_ids list<text>, metadata map<text, text>, name text, parent_settlement_account text, payment_method_processor_map map<text, text>, processors set<text>, provider text, provider_reference text, rolling_reserve_amount text, rolling_reserve_duration int, rolling_reserve_enabled boolean, rolling_reserve_type text, routing_key text, schedule_config frozen<schedule_config_settlement>, settlement_transfer_type text, suspended boolean, three_ds_processor text, three_ds_processor_map map<text, text>, updated_at text, vat_number text, virtual boolean, PRIMARY KEY (company_id, id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.settlements ( company_id text, merchant_id text, id text, currency text, bank_reference_number text, blended boolean, card_settlement_bank_cleared boolean, card_settlement_bank_clearing_date text, card_settlement_bank_transfer_reference text, card_settlement_cleared boolean, card_settlement_clearing_date text, charge_amount text, charge_count int, chargeback_amount text, chargeback_breakdown frozen<chargeback_breakdown_by_scheme>, chargeback_count int, chargeback_fees text, created_at text, date_from text, date_to text, decline_count int, general_adjustments text, interchange_fees text, interchange_returned text, merchant_bank_account text, merchant_bank_name text, merchant_ids list<text>, merchant_statement_file text, net_amount text, network_fees text, payment_date text, payout_amount text, payout_count int, processed_amount text, processed_count int, processing_fees text, processing_fees_breakdown frozen<processing_fees_breakdown_by_scheme>, processing_fees_breakdown_detailed frozen<processing_fees_breakdown_by_scheme_detailed>, refund_amount text, refund_count int, rolling_reserve_adjustment text, rolling_reserve_amount text, rolling_reserve_released_amount text, service_fees text, settlement_config_id text, settlement_fee text, settlement_method text, settling_entity text, settling_entity_id text, status text, sub_transfers_data map<text, text>, total_fees text, transaction_max_datetime text, transaction_min_datetime text, updated_at text, vat text, PRIMARY KEY (company_id, merchant_id, id, currency) ) WITH CLUSTERING ORDER BY (merchant_id ASC, id ASC, currency ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.sftp ( company_id text, merchant_id text, ip_ranges text, public_key text, PRIMARY KEY (company_id, merchant_id) ) WITH CLUSTERING ORDER BY (merchant_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.shopify_credentials ( merchant_id text, access_token text, credentials map<text, text>, credentials_by_app map<text, frozen<map<text, text>>>, shop text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.silverflow_credentials ( merchant_id text, funding frozen<silverflow_credentials_payout>, payout frozen<silverflow_credentials_payout>, silverflow_api_key text, silverflow_api_secret text, silverflow_credentials_by_currency frozen<map<text, frozen<silverflow_merchant_acceptor_key>>>, silverflow_merchant_acceptor_key frozen<silverflow_merchant_acceptor_key>, silverflow_region text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.sites ( merchant_id text, id text, notify_url text, site text, website text, PRIMARY KEY (merchant_id, id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.sources ( merchant_id text, type text, unique_identifier text, billing_details frozen<address_v2>, billing_details_id text, card frozen<payment_method_card>, company_id text, consumer_id text, id text, last_transaction_date timestamp, paypal frozen<payment_method_paypal>, paypal_billing_agreement frozen<payment_method_paypal_billing_agreement>, paysafecard frozen<payment_method_paysafecard>, reusable_payments boolean, reusable_payouts boolean, site_id text, PRIMARY KEY ((merchant_id, type), unique_identifier) ) WITH CLUSTERING ORDER BY (unique_identifier ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.sources_v2 ( merchant_id text, consumer_id text, type text, unique_identifier text, applepay frozen<payment_method_card>, bank_account frozen<payment_method_bank_account>, billing_details frozen<address_v2>, billing_details_id text, card frozen<payment_method_card>, company_id text, created_at text, disable_duplicate_check boolean, generic frozen<payment_method_generic>, googlepay frozen<payment_method_card>, id text, in_bank_account frozen<payment_method_bank_account>, initial_successful_settlement_account text, last_transaction_date text, metadata map<text, text>, netbanking frozen<payment_method_netbanking>, network_transaction_id text, network_transaction_tx_id text, paypal frozen<payment_method_paypal>, paypal_billing_agreement frozen<payment_method_paypal_billing_agreement>, paysafecard frozen<payment_method_paysafecard>, previous_successful_settlement_account text, reference text, reusable_payments boolean, reusable_payouts boolean, site_id text, updated_at text, upi frozen<payment_method_upi>, us_bank_account frozen<payment_method_bank_account>, PRIMARY KEY ((merchant_id, consumer_id), type, unique_identifier) ) WITH CLUSTERING ORDER BY (type ASC, unique_identifier ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'ZstdWithDictsCompressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'false', 'preimage': 'false', 'ttl': '86400'} AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.statements ( company_id text, date text, id text, created_at text, data map<text, text>, deliveries set<frozen<statement_delivery_record>>, filename text, identifier text, merchant_id text, type text, updated_at text, PRIMARY KEY ((company_id, date), id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.stripe_credentials ( merchant_id text, standalone_3ds_acquirer_bin text, standalone_3ds_acquirer_country text, standalone_3ds_acquirer_merchant_id text, standalone_3ds_mcc text, standalone_3ds_use_connected_account boolean, stripe_api_key text, stripe_billing_account_id text, stripe_connected_account_id text, stripe_reporting_api_key text, stripe_reporting_webhook_secret text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.structures ( country_alpha2 text, key text, aml_risk_score tinyint, description text, enabled boolean, local_name text, name text, region text, PRIMARY KEY (country_alpha2, key) ) WITH CLUSTERING ORDER BY (key ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.subscription_packages ( company_id text, merchant_id text, id text, active boolean, created_at text, description text, reference text, settings frozen<subscriptions_common_settings>, updated_at text, PRIMARY KEY (company_id, merchant_id, id) ) WITH CLUSTERING ORDER BY (merchant_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'false', 'preimage': 'false', 'ttl': '86400'} AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.subscriptions ( company_id text, date text, id text, cancel_at text, cancel_at_period_end boolean, cancellation_reason text, consumer_id text, consumer_region text, created_at text, current_period_end_date text, current_period_start_date text, ended_at text, failed_charging_attempts int, failed_next_charge_attempt_date text, initial_subscription_session text, latest_successful_amount text, latest_successful_charge text, merchant_id text, metadata map<text, text>, reference text, settings frozen<subscriptions_custom_settings>, source_id text, status text, trial_period_end_date text, trial_period_start_date text, updated_at text, PRIMARY KEY ((company_id, date), id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'false', 'preimage': 'false', 'ttl': '86400'} AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.superset_dashboards ( id text, dashboard_id text, dashboard_ui_config text, enabled boolean, groups list<text>, merchant_ids frozen<set<text>>, name text, rls text, type text, url text, PRIMARY KEY (id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.tabapay_credentials ( merchant_id text, tabapay_additional_sub_client_ids map<text, text>, tabapay_api_key text, tabapay_client_id text, tabapay_settlement_account_id text, tabapay_sub_client_id text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.task_categories ( value text, title text, PRIMARY KEY (value) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.task_templates ( id text, actions list<frozen<task_template_action>>, category frozen<task_category>, created_at text, created_by text, fields list<frozen<task_template_field>>, is_deleted boolean, slug text, title text, type text, updated_at text, workflow text, PRIMARY KEY (id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.tasks ( partition_key text, id text, actions list<frozen<task_template_action>>, assignee text, cancel_reason text, canceled_at text, category frozen<task_category>, company_id text, completed_at text, created_at text, created_by text, creator_note text, description text, expires_on text, fields list<frozen<task_template_field>>, group_assignee text, merchant_group_assignee text, merchant_id text, metadata map<text, text>, notes list<frozen<task_note>>, parent_id text, signal text, status text, task_template_id text, title text, type text, values list<frozen<task_value>>, workflow text, PRIMARY KEY (partition_key, id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'full', 'ttl': '86400'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.temporal_actions_webhooks_0 ( identifier text, unique_key text, action text, body text, namespace text, signal_body text, signal_type text, task_queue text, workflow_type text, PRIMARY KEY (identifier, unique_key) ) WITH CLUSTERING ORDER BY (unique_key ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 86400 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'true', 'preimage': 'false', 'ttl': '86400'} AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.tiered_pricing_strategies ( id text, name text, query text, timeframe text, type text, PRIMARY KEY (id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.transactions ( key text, id text, attempt_id text, acquirer_bin text, acquirer_mid text, acquiring_setup text, additional_pricing_actions frozen<additional_pricing_actions>, after_completion frozen<after_completion>, allocation_bank_transfer_reference text, allocation_cleared_transactional_fees_bank_transfer_id text, allocation_fx_fees_bank_transfer_id text, allocation_net_amount_bank_transfer_id text, allocation_non_cleared_transactional_fees_bank_transfer_id text, allow_partial_approval boolean, amount_cancelled text, amount_capturable text, amount_eur text, amount_gbp text, amount_received text, amount_refunded text, amount_usd text, anonymous_proxy boolean, apm_metadata frozen<map<text, text>>, approved_amount text, at_least_one_capture boolean, attempt int, authentication_context frozen<authentication_context>, available_payment_methods list<text>, bank_cleared boolean, bank_clearing_date text, bank_settlement_summable_amount text, bank_settlement_summable_amount_currency text, bank_transfer_reference text, billing_details frozen<address_v2>, billing_details_address_id text, blended_pricing boolean, blocked_by_rule_id text, calculated_statement_descriptor text, capture_delay text, chargeback_reason_code text, checkout boolean, checkout_cashier boolean, checkout_cashier_balance text, checkout_cashier_deposit_limit text, checkout_cashier_preset_amounts list<text>, checkout_cashier_withdraw_limit text, checkout_link text, checkout_locale text, checkout_session_duration int, checkout_session_type text, checkout_setup_future_usage boolean, checkout_submit_type text, cleared boolean, cleared_at text, clearing_date text, clearing_file_identifier text, client_country text, client_ip text, client_ipcity text, client_ipcontinent text, client_ipcountry text, client_iplatitud text, client_iplongitud text, client_ipstate text, client_posta text, client_region text, client_region_code text, client_subdivision text, client_timezone text, collaboration_id text, collection frozen<collection>, commission text, commission_id text, company_id text, confirm_related_transaction boolean, consumer_dob text, consumer_email text, consumer_first_name text, consumer_id text, consumer_last_name text, consumer_merchant_consumer_id text, consumer_national_identification_number text, consumer_phone text, continent text, conversion_bank_to_settlement_margin text, conversion_bank_to_settlement_provider text, conversion_bank_to_settlement_rate text, conversion_provider_to_bank_margin text, conversion_provider_to_bank_provider text, conversion_provider_to_bank_rate text, currency text, custom_fields frozen<custom_fields>, custom_fields_list list<frozen<custom_fields_v2>>, custom_fields_values frozen<map<text, text>>, custom_text frozen<custom_text>, date_after_funding_delay text, date_time text, dcc_accepted boolean, dcc_enabled boolean, dcc_revenue text, description text, descriptor text, dispute_accepted_lose_at text, dispute_amount text, dispute_id text, dispute_status text, dispute_won_at text, dr_enabled boolean, dr_finalize frozen<finalize>, end_user_amount text, end_user_conversion_margin text, end_user_conversion_rate text, end_user_currency text, entity_id text, estimated_settlement_date text, exemption_location text, exemption_type text, exemption_used boolean, external_settlement boolean, fee_currency text, finalize frozen<finalize>, flow_directions frozen<flow_directions>, fraud boolean, fraud_actionable boolean, fraud_date_time text, fraud_input_method text, fraud_raw_code text, fraud_raw_sub_code text, fraud_sub_type text, fraud_type text, global_settlement_id text, gross_fee text, gross_invoice_id text, initial_dispute_status text, initialize_url text, interchange_currency text, interchange_fee_estimated text, interchange_fee_final text, internal_bank_amount text, internal_bank_currency text, internal_block boolean, internal_clearing_date text, internal_cost text, internal_cost_acquiring text, internal_cost_acquiring_basis_points text, internal_cost_commission text, internal_cost_fixed text, internal_cost_fixed_processor text, internal_cost_provider text, internal_cost_referral text, internal_metadata frozen<map<text, text>>, internal_revenue_estimated text, internal_revenue_final text, internal_source text, is_partial_chunk boolean, jurisdiction text, last_visited_step text, mandate_id text, manual_review boolean, manual_review_approver_identifier text, manual_review_approver_origin text, manual_review_expires_at text, manual_review_status text, manual_review_status_reason text, max_attempts int, merchant_country text, merchant_dba_name text, merchant_fee text, merchant_id text, merchant_legal_name text, merchant_onboarding_stage int, metadata map<text, text>, mit boolean, mit_reason text, net_amount_currency text, net_amount_estimated text, net_amount_final text, network_fee_currency text, network_fee_estimated text, network_fee_final text, network_token_provision_response_code text, network_token_used boolean, network_transaction_id text, notification_url text, original_transaction boolean, parent_settlement_account_id text, partial boolean, partial_approval boolean, partially_refunded boolean, payment_attempt int, payment_id text, payment_link_id text, payment_method frozen<payment_method>, payment_method_options frozen<payment_method_options>, payment_status text, pricing_segment_code text, processor text, processor_transaction_id text, proxy_processor text, receipt_email text, receipt_number text, receipt_url text, reconciliation_date text, reconciliation_failure_reason text, reconciliation_id text, reconciliation_status text, recurring_expiry text, recurring_frequency text, redirect_url_failure text, redirect_url_success text, reference text, referral_fee text, referral_id text, refunded boolean, related_recurring_transaction text, related_transaction text, requested_amount text, requestor_country text, requestor_identifier text, requestor_ip text, requestor_origin text, retry_of_attempt_id text, risk_assessed boolean, risk_assessment_decision text, risk_assessment_decision_details text, risk_assessment_decision_external_rules text, risk_assessment_decision_internal_rules text, risk_assessment_decision_reasons list<text>, risk_assessment_id text, risk_assessment_rule_id text, risk_assessment_rule_id_configuration text, risk_assessment_rule_id_external text, risk_assessment_rule_id_internal text, risk_assessment_rule_id_routing text, risk_assessment_score text, risk_engine_id text, rolling_reserve_amount text, rolling_reserve_config_amount text, rolling_reserve_config_duration text, rolling_reserve_config_type text, rolling_reserve_currency text, rolling_reserve_enabled boolean, rolling_reserve_id text, rolling_reserve_release_date text, routing_details frozen<routing_details>, routing_key text, scheme_fee_estimated text, scheme_fee_final text, session_date_time text, settled boolean, settlement_account_id text, settlement_conversion_rate text, settlement_conversion_rate_margin text, settlement_conversion_rate_provider text, settlement_currency text, settlement_currency_amount text, settlement_date text, settlement_id text, settlement_net_amount_final text, setup_future_usage_type text, shipping_details frozen<address_v2>, shipping_details_address_id text, shipping_first_name text, shipping_last_name text, shipping_phone text, site_id text, source_id text, statement_descriptor_suffix text, status text, sub_type text, subscription_id text, summable_amount text, tax_amount text, tax_collection_enabled boolean, tax_inclusive boolean, tax_percentage text, tax_product_code text, terms_and_conditions_accepted boolean, terms_and_conditions_accepted_on_transaction text, three_ds_acs_operator_id text, three_ds_acs_reference_number text, three_ds_acs_transaction_id text, three_ds_acs_url text, three_ds_ares text, three_ds_authentication_flow text, three_ds_card_holder_info text, three_ds_cavv text, three_ds_challenge_indicator text, three_ds_challenge_required boolean, three_ds_challenge_url text, three_ds_ds_transaction_id text, three_ds_eci text, three_ds_enrolled boolean, three_ds_error_code text, three_ds_error_description text, three_ds_metadata frozen<map<text, text>>, three_ds_method_completed boolean, three_ds_method_payload text, three_ds_method_url text, three_ds_pa_res_status text, three_ds_payload text, three_ds_processor text, three_ds_reason_code text, three_ds_reason_description text, three_ds_result text, three_ds_result_extended text, three_ds_rreq text, three_ds_server_transaction_id text, three_ds_status_reason text, three_ds_timestamp text, three_ds_used boolean, three_ds_version text, three_ds_xid text, three_ri_indicator text, three_ri_initial_authentication_acs_trans_id text, three_ri_initial_authentication_date_time text, three_ri_initial_authentication_ds_trans_id text, three_ri_initial_authentication_flow text, three_ri_initial_authentication_transaction_id text, trace_ids list<text>, transaction_fee_estimated text, transaction_fee_final text, type text, updated_at text, updated_by text, user_agent text, PRIMARY KEY (key, id, attempt_id) ) WITH CLUSTERING ORDER BY (id ASC, attempt_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'ZstdWithDictsCompressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND cdc = {'delta': 'full', 'enabled': 'true', 'postimage': 'false', 'preimage': 'false', 'ttl': '86400'} AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.users ( company_id text, merchant_id text, id text, country_alpha2 text, created_at text, description text, email text, first_name text, last_login text, last_name text, metadata map<text, text>, mfa_enrolled boolean, phone text, role text, status text, super_user boolean, updated_at text, PRIMARY KEY (company_id, merchant_id, id) ) WITH CLUSTERING ORDER BY (merchant_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.visa_click_to_pay_credentials ( merchant_id text, visa_dpa_client_id text, visa_merchant_id text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.visa_decision_manager_credentials ( merchant_id text, cybersource_key text, cybersource_mid text, cybersource_secret text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.volt_credentials ( merchant_id text, volt_customer_ids_by_currency frozen<map<text, text>>, volt_merchant_password text, volt_merchant_username text, volt_payout_notification_secret text, volt_signature_private_key text, volt_signature_public_key_id text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.vyne_credentials ( merchant_id text, destination_accounts map<text, text>, vyne_merchant_id text, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.webhooks ( merchant_id text, id text, company_id text, enabled boolean, event_types list<text>, initial_delay text, name text, secret_key text, url text, PRIMARY KEY (merchant_id, id) ) WITH CLUSTERING ORDER BY (id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.workflows ( name text, description text, enabled boolean, friendly_name text, namespace text, params frozen<list<frozen<workflow_param>>>, signals set<text>, task_queue text, PRIMARY KEY (name) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE TABLE IF NOT EXISTS pay.worldpay_credentials ( merchant_id text, merchant_sub_id text, payfac_ids map<text, text>, worldpay_chargeback_password text, worldpay_chargeback_username text, worldpay_contract_type text, worldpay_credentials frozen<set<frozen<worldpay_merchant_credentials>>>, worldpay_three_ds_credentials frozen<worldpay_three_ds_credentials>, PRIMARY KEY (merchant_id) ) WITH bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
}

async fn create_indexes_pay(db) {
    db.execute("CREATE INDEX IF NOT EXISTS hash_addresses_idx ON pay.addresses(hash);").await;
    db.execute("CREATE INDEX IF NOT EXISTS bank_transfer_reference_adjustments_idx ON pay.adjustments(bank_transfer_reference);").await;
    db.execute("CREATE INDEX IF NOT EXISTS api_keys_by_api_key_hash ON pay.api_keys(api_key_hash);").await;
    db.execute("CREATE INDEX IF NOT EXISTS api_keys_by_site_id ON pay.api_keys(site_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS api_keys_v2_by_api_key_encrypted ON pay.api_keys_v2(api_key_encrypted);").await;
    db.execute("CREATE INDEX IF NOT EXISTS api_keys_v2_by_company_id ON pay.api_keys_v2(company_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS api_keys_v2_by_merchant_id ON pay.api_keys_v2(merchant_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS account_identifier_bank_accounts_idx ON pay.bank_accounts(account_identifier);").await;
    db.execute("CREATE INDEX IF NOT EXISTS id_banks_idx ON pay.banks(id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS provider_banks_idx ON pay.banks(provider);").await;
    db.execute("CREATE INDEX IF NOT EXISTS transaction_id_collaborations_idx ON pay.collaborations(transaction_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS partner_key_connections_idx ON pay.connections(partner_key);").await;
    db.execute("CREATE INDEX IF NOT EXISTS partner_account_identifier_connections_v1_idx ON pay.connections_v1(partner_account_identifier);").await;
    db.execute("CREATE INDEX IF NOT EXISTS partner_key_connections_v1_idx ON pay.connections_v1(partner_key);").await;
    db.execute("CREATE INDEX IF NOT EXISTS email_consumers_idx ON pay.consumers(email);").await;
    db.execute("CREATE INDEX IF NOT EXISTS merchant_id_consumers_idx ON pay.consumers(merchant_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS email_consumers_v2_idx ON pay.consumers_v2(email);").await;
    db.execute("CREATE INDEX IF NOT EXISTS numeric_currencies_index ON pay.currencies(numeric);").await;
    db.execute("CREATE INDEX IF NOT EXISTS consumer_id_disputes_idx ON pay.disputes(consumer_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS disputed_payment_disputes_idx ON pay.disputes(disputed_payment);").await;
    db.execute("CREATE INDEX IF NOT EXISTS id_documents_idx ON pay.documents(id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS name_email_templates_idx ON pay.email_templates(name);").await;
    db.execute("CREATE INDEX IF NOT EXISTS payment_id_fees_idx ON pay.fees(payment_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS transaction_id_fees_idx ON pay.fees(transaction_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS referral_id_finance_settings_idx ON pay.finance_settings(referral_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS frontegg_tenant_id_merchants_idx ON pay.merchants(frontegg_tenant_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS id_merchants_idx ON pay.merchants(id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS override_onboarding_merchant_id_merchants_idx ON pay.merchants(override_onboarding_merchant_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS partner_key_partners_idx ON pay.partners(partner_key);").await;
    db.execute("CREATE INDEX IF NOT EXISTS id_paymentlinks_idx ON pay.paymentlinks(id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS original_value_idx ON pay.providers_mapping(original_value);").await;
    db.execute("CREATE INDEX IF NOT EXISTS merchant_ids_report_pull_config_idx ON pay.report_pull_config(values(merchant_ids));").await;
    db.execute("CREATE INDEX IF NOT EXISTS type_report_pull_config_idx ON pay.report_pull_config(type);").await;
    db.execute("CREATE INDEX IF NOT EXISTS id_reserves_idx ON pay.reserves(id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS released_settlement_id_reserves_idx ON pay.reserves(released_settlement_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS settlement_id_reserves_idx ON pay.reserves(settlement_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS id_reserves_v1_idx ON pay.reserves_v1(id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS released_settlement_id_reserves_v1_idx ON pay.reserves_v1(released_settlement_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS settlement_id_reserves_v1_idx ON pay.reserves_v1(settlement_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS risk_lists_alias_idx ON pay.risk_lists(alias);").await;
    db.execute("CREATE INDEX IF NOT EXISTS settlement_id_service_fees_idx ON pay.service_fees(settlement_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS merchant_ids_settlement_config_idx ON pay.settlement_config(values(merchant_ids));").await;
    db.execute("CREATE INDEX IF NOT EXISTS provider_reference_settlement_config_idx ON pay.settlement_config(provider_reference);").await;
    db.execute("CREATE INDEX IF NOT EXISTS bank_reference_number_settlements_idx ON pay.settlements(bank_reference_number);").await;
    db.execute("CREATE INDEX IF NOT EXISTS card_settlement_bank_transfer_reference_idx ON pay.settlements(card_settlement_bank_transfer_reference);").await;
    db.execute("CREATE INDEX IF NOT EXISTS id_settlements_idx ON pay.settlements(id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS settlements_settling_entity_id_idx ON pay.settlements(settling_entity_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS id_sites_idx ON pay.sites(id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS consumer_id_sources_idx ON pay.sources(consumer_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS id_sources_idx ON pay.sources(id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS id_sources_v2_idx ON pay.sources_v2(id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS statements_identifier_idx ON pay.statements(identifier);").await;
    db.execute("CREATE INDEX IF NOT EXISTS slug_task_templates_idx ON pay.task_templates(slug);").await;
    db.execute("CREATE INDEX IF NOT EXISTS idx_created_by ON pay.tasks(created_by);").await;
    db.execute("CREATE INDEX IF NOT EXISTS idx_group_assignee ON pay.tasks(group_assignee);").await;
    db.execute("CREATE INDEX IF NOT EXISTS idx_merchant_id ON pay.tasks(merchant_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS id_transactions_idx ON pay.transactions(id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS payment_id_transactions_idx ON pay.transactions(payment_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS processor_transaction_id_transactions_idx ON pay.transactions(processor_transaction_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS reconciliation_id_transactions_idx ON pay.transactions(reconciliation_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS related_transaction_transactions_idx ON pay.transactions(related_transaction);").await;
    db.execute("CREATE INDEX IF NOT EXISTS source_id_transactions_idx ON pay.transactions(source_id);").await;
    db.execute("CREATE INDEX IF NOT EXISTS users_id_idx ON pay.users(id);").await;
}

async fn create_materialized_views_pay(db) {
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.adjustments_by_assigned_to_settlement AS SELECT * FROM pay.adjustments WHERE company_id IS NOT null AND merchant_id IS NOT null AND id IS NOT null AND assigned_to_settlement IS NOT null PRIMARY KEY ((company_id, merchant_id), assigned_to_settlement, id) WITH CLUSTERING ORDER BY (assigned_to_settlement ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.adjustments_by_settlement_id AS SELECT * FROM pay.adjustments WHERE company_id IS NOT null AND merchant_id IS NOT null AND id IS NOT null AND settlement_id IS NOT null PRIMARY KEY ((company_id, merchant_id), settlement_id, id) WITH CLUSTERING ORDER BY (settlement_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.bank_accounts_by_type AS SELECT company_id, merchant_id, type, id FROM pay.bank_accounts WHERE company_id IS NOT null AND merchant_id IS NOT null AND type IS NOT null AND id IS NOT null PRIMARY KEY ((company_id, merchant_id), type, id) WITH CLUSTERING ORDER BY (type ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.banks_by_provider_bank_id AS SELECT provider_bank_id, provider, currency, country, id FROM pay.banks WHERE currency IS NOT null AND country IS NOT null AND provider IS NOT null AND provider_bank_id IS NOT null PRIMARY KEY ((provider_bank_id, provider), currency, country) WITH CLUSTERING ORDER BY (currency ASC, country ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.consumers_by_merchant_consumer_id AS SELECT merchant_consumer_id, merchant_id, site_id, time, id FROM pay.consumers WHERE merchant_consumer_id IS NOT null AND merchant_id IS NOT null AND site_id IS NOT null AND time IS NOT null AND id IS NOT null PRIMARY KEY (merchant_consumer_id, merchant_id, site_id, time, id) WITH CLUSTERING ORDER BY (merchant_id ASC, site_id ASC, time ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.consumers_by_merchant_consumer_id_v2 AS SELECT merchant_consumer_id, merchant_id, time, id FROM pay.consumers_v2 WHERE merchant_consumer_id IS NOT null AND merchant_id IS NOT null AND time IS NOT null AND id IS NOT null PRIMARY KEY (merchant_consumer_id, merchant_id, time, id) WITH CLUSTERING ORDER BY (merchant_id ASC, time ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.declines_by_category AS SELECT company_id, merchant_id, category, card_token, transaction_id, attempt_id FROM pay.declines WHERE company_id IS NOT null AND merchant_id IS NOT null AND card_token IS NOT null AND transaction_id IS NOT null AND attempt_id IS NOT null AND category IS NOT null PRIMARY KEY ((company_id, merchant_id), category, card_token, transaction_id, attempt_id) WITH CLUSTERING ORDER BY (category ASC, card_token ASC, transaction_id ASC, attempt_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.merchant_mids_by_acquirer_mid AS SELECT acquirer_mid, acquirer, company_id, merchant_id, scheme FROM pay.merchant_mids WHERE acquirer_mid IS NOT null AND acquirer IS NOT null AND company_id IS NOT null AND merchant_id IS NOT null AND scheme IS NOT null PRIMARY KEY ((acquirer_mid, acquirer), company_id, merchant_id, scheme) WITH CLUSTERING ORDER BY (company_id ASC, merchant_id ASC, scheme ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.merchants_by_reference AS SELECT reference, company_id, id FROM pay.merchants WHERE reference IS NOT null AND id IS NOT null AND company_id IS NOT null PRIMARY KEY (reference, company_id, id) WITH CLUSTERING ORDER BY (company_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.notification_subscriptions_by_notification_type AS SELECT * FROM pay.notification_subscriptions WHERE company_id IS NOT null AND merchant_id IS NOT null AND user_id IS NOT null AND notification_type IS NOT null PRIMARY KEY (notification_type, company_id, merchant_id, user_id) WITH CLUSTERING ORDER BY (company_id ASC, merchant_id ASC, user_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.risk_lists_values_by_value AS SELECT company_id, merchant_id, list_id, value, id FROM pay.risk_lists_values WHERE company_id IS NOT null AND merchant_id IS NOT null AND list_id IS NOT null AND id IS NOT null AND value IS NOT null PRIMARY KEY ((company_id, merchant_id, list_id), value, id) WITH CLUSTERING ORDER BY (value ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.settlements_by_merchant_id AS SELECT merchant_id, status, currency, company_id, id FROM pay.settlements WHERE merchant_id IS NOT null AND status IS NOT null AND currency IS NOT null AND company_id IS NOT null AND id IS NOT null PRIMARY KEY (merchant_id, status, currency, company_id, id) WITH CLUSTERING ORDER BY (status ASC, currency ASC, company_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.sources_v2_by_unique_identifier AS SELECT unique_identifier, merchant_id, type, consumer_id FROM pay.sources_v2 WHERE unique_identifier IS NOT null AND merchant_id IS NOT null AND type IS NOT null AND consumer_id IS NOT null PRIMARY KEY (unique_identifier, merchant_id, type, consumer_id) WITH CLUSTERING ORDER BY (merchant_id ASC, type ASC, consumer_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.sources_v2_by_unique_identifier_extended AS SELECT unique_identifier, merchant_id, type, consumer_id, reusable_payments, reusable_payouts FROM pay.sources_v2 WHERE unique_identifier IS NOT null AND merchant_id IS NOT null AND type IS NOT null AND consumer_id IS NOT null PRIMARY KEY (unique_identifier, merchant_id, type, consumer_id) WITH CLUSTERING ORDER BY (merchant_id ASC, type ASC, consumer_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.sources_v2_by_unique_identifier_extended_v2 AS SELECT unique_identifier, merchant_id, type, consumer_id, disable_duplicate_check, reusable_payments, reusable_payouts FROM pay.sources_v2 WHERE unique_identifier IS NOT null AND merchant_id IS NOT null AND type IS NOT null AND consumer_id IS NOT null PRIMARY KEY (unique_identifier, merchant_id, type, consumer_id) WITH CLUSTERING ORDER BY (merchant_id ASC, type ASC, consumer_id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE' AND tombstone_gc = {'mode': 'timeout', 'propagation_delay_in_seconds': '3600'};").await;
    db.execute("CREATE MATERIALIZED VIEW IF NOT EXISTS pay.transactions_by_reference AS SELECT reference, key, attempt_id, id, company_id, merchant_id FROM pay.transactions WHERE id IS NOT null AND attempt_id IS NOT null AND key IS NOT null AND reference IS NOT null PRIMARY KEY (reference, key, attempt_id, id) WITH CLUSTERING ORDER BY (key ASC, attempt_id ASC, id ASC) AND bloom_filter_fp_chance = 0.01 AND caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'} AND comment = '' AND compaction = {'class': 'IncrementalCompactionStrategy'} AND compression = {'sstable_compression': 'org.apache.cassandra.io.compress.LZ4Compressor'} AND crc_check_chance = 1 AND default_time_to_live = 0 AND gc_grace_seconds = 864000 AND max_index_interval = 2048 AND memtable_flush_period_in_ms = 0 AND min_index_interval = 128 AND speculative_retry = '99.0PERCENTILE';").await;
}

/////////////////////////////////
///// Data Generation Utils /////
/////////////////////////////////

/// Generate a value for a given CQL type based on a deterministic seed.
/// Type codes: T=text, I=int, B=boolean, D=double, TI=tinyint,
///             TS=timestamp, TU=timeuuid, BL=blob, LT=list<text>, MT=map<text,text>
async fn gen_value(type_code, seed) {
    if type_code == "T" {
        text(seed, 32)
    } else if type_code == "I" {
        hash_range(seed, 2_147_483_647)
    } else if type_code == "B" {
        hash_range(seed, 2) == 1
    } else if type_code == "D" {
        (hash_range(seed, 1_000_000) as f64) / 1000.0
    } else if type_code == "TI" {
        hash_range(seed, 127)
    } else if type_code == "TS" {
        // Timestamp as bigint millis since epoch (around year 2020-2025)
        1_577_836_800_000 + hash_range(seed, 157_680_000_000)
    } else if type_code == "TU" {
        uuid(seed)
    } else if type_code == "BL" {
        blob(seed, 64)
    } else if type_code == "LT" {
        // list<text> with 1-3 elements
        let count = hash_range(seed, 3) + 1;
        let result = [];
        let list_i = 0;
        while list_i < count {
            result.push(text(hash2(seed, list_i), 16));
            list_i += 1;
        }
        result
    } else if type_code == "MT" {
        // map<text, text> with 1-3 entries
        let count = hash_range(seed, 3) + 1;
        let result = #{};
        let map_i = 0;
        while map_i < count {
            let k = `key_${text(hash2(seed, map_i), 8)}`;
            let v = text(hash2(seed, map_i + 100), 16);
            result[k] = v;
            map_i += 1;
        }
        result
    } else {
        // Fallback to text
        text(seed, 16)
    }
}

/// Generate a row of values for a table based on the table metadata and row index.
/// Returns an array of values matching the column order in the table registry.
async fn gen_row_values(table_meta, row_idx) {
    let values = [];
    let col_idx = 0;
    while col_idx < table_meta.col_types.len() {
        let type_code = table_meta.col_types[col_idx];
        let seed = hash2(row_idx, col_idx);
        values.push(gen_value(type_code, seed).await);
        col_idx += 1;
    }
    values
}

/// Utility function that enables and validates the gauss/normal distribution
async fn prepare_gauss_distribution(db) {
    if GAUSS_MEAN > 0 && GAUSS_STDDEV > 0 {
        db.data.gauss_mean = GAUSS_MEAN as f64;
        db.data.gauss_stddev = GAUSS_STDDEV as f64;
        db.data.gauss_enabled = true;
        println!(
            "debug: Gauss/normal distribution is enabled: mean='{mean}', stddev='{stddev}'",
            mean=db.data.gauss_mean, stddev=db.data.gauss_stddev);
    } else if GAUSS_MEAN == 0 && GAUSS_STDDEV == 0 {
        db.data.gauss_enabled = false;
        println!("debug: Gauss/normal distribution is disabled");
    } else {
        panic!(
            "'gauss_mean' and 'gauss_stddev' both must be either '0' (disabled) " +
            "or both be positive values")
    }
}

/// Utility function which generates partition index based on the cycle id and distribution type
async fn get_partition_idx(db, i) {
    if db.data.gauss_enabled {
        let current_idx = normal(i, db.data.gauss_mean, db.data.gauss_stddev) as i64;
        if current_idx < 0 {
            current_idx = 0;
        } else if current_idx >= ROW_COUNT_PER_TABLE {
            current_idx = ROW_COUNT_PER_TABLE - 1;
        }
        return current_idx;
    } else {
        return i % ROW_COUNT_PER_TABLE;
    }
}

/////////////////////////////////
///// Simple Tables Registry ////
/////////////////////////////////

/// Returns the registry of all simple (non-UDT) tables in the pay keyspace.
/// Each entry: #{"name": table_name, "pk": pk_count, "ck": ck_count,
///              "col_names": [col_names...], "col_types": [type_codes...]}
/// Type codes: T=text, I=int, B=boolean, D=double, TI=tinyint,
///             TS=timestamp, TU=timeuuid, BL=blob, LT=list<text>, MT=map<text,text>
fn get_simple_tables_registry() {
    [
        #{"name": "acquirer_bins", "pk": 1, "ck": 1, "col_names": ["acquirer", "scheme", "bin"], "col_types": ["T", "T", "T"]},
        #{"name": "aircash_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "aircash_partner_id"], "col_types": ["T", "T"]},
        #{"name": "api_keys", "pk": 1, "ck": 0, "col_names": ["id", "api_key_hash", "company_id", "ip_ranges", "merchant_id", "site_id"], "col_types": ["T", "T", "T", "T", "T", "T"]},
        #{"name": "api_keys_v2", "pk": 1, "ck": 0, "col_names": ["id", "allowed_endpoints", "api_key_encrypted", "company_id", "enabled", "ip_ranges", "last_six_digits", "merchant_id", "name", "pci_compliant"], "col_types": ["T", "MT", "T", "T", "B", "T", "T", "T", "T", "B"]},
        #{"name": "applepay_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "applepay_cert", "applepay_key", "applepay_merchant_identifier"], "col_types": ["T", "T", "T", "T"]},
        #{"name": "approvals", "pk": 1, "ck": 0, "col_names": ["id", "allowed_approvers_group", "approver", "description", "signal_name", "status", "status_date", "status_reason", "temporal_namespace", "title", "workflow_id"], "col_types": ["T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T"]},
        #{"name": "bank_holidays", "pk": 1, "ck": 2, "col_names": ["provider", "currency", "date", "name"], "col_types": ["T", "T", "T", "T"]},
        #{"name": "bins", "pk": 1, "ck": 0, "col_names": ["display_bin", "card_product", "is_oct_support", "is_visa_direct_ff_support", "issuer_name", "range_high", "range_low"], "col_types": ["T", "T", "B", "B", "T", "T", "T"]},
        #{"name": "cardinal_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "org_unit_id"], "col_types": ["T", "T"]},
        #{"name": "cdc_to_workflow_configs", "pk": 1, "ck": 2, "col_names": ["table_name", "workflow_name", "id", "condition_params", "signal_condition_params", "signal_name", "signal_values", "workflow_id_unique_key", "workflow_task_queue", "workflow_values"], "col_types": ["T", "T", "T", "T", "T", "T", "LT", "T", "T", "LT"]},
        #{"name": "centrobill_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "centrobill_api_key", "centrobill_merchant_id", "centrobill_site_id"], "col_types": ["T", "T", "T", "T"]},
        #{"name": "channels", "pk": 1, "ck": 0, "col_names": ["channel_code", "aml_rank_eu", "aml_rank_us", "channel_description"], "col_types": ["T", "TI", "TI", "T"]},
        #{"name": "chargeback_reasons", "pk": 1, "ck": 1, "col_names": ["network", "code", "category", "code_usa_or_ca", "reason_description", "reason_title", "required_documentation"], "col_types": ["T", "T", "T", "T", "T", "T", "T"]},
        #{"name": "coinify_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "api_key", "sub_account_id"], "col_types": ["T", "T", "T"]},
        #{"name": "commissions", "pk": 1, "ck": 0, "col_names": ["id", "default_commission_basis_points", "email", "name"], "col_types": ["T", "T", "T", "T"]},
        #{"name": "connections", "pk": 1, "ck": 1, "col_names": ["merchant_id", "partner_key", "completed", "enabled", "enabled_at", "error_message", "partner_account_identifier", "updated_at"], "col_types": ["T", "T", "B", "B", "T", "T", "T", "T"]},
        #{"name": "connections_v1", "pk": 1, "ck": 3, "col_names": ["merchant_id", "partner_key", "provider", "routing_key", "completed", "enabled", "enabled_at", "error_message", "partner_account_identifier", "updated_at"], "col_types": ["T", "T", "T", "T", "B", "B", "T", "T", "T", "T"]},
        #{"name": "consumers", "pk": 1, "ck": 3, "col_names": ["time", "id", "merchant_id", "site_id", "billing_details_ids", "company_id", "default_source", "email", "first_name", "last_name", "last_transaction_date", "merchant_consumer_id", "phone", "shipping_details_ids", "terms_and_conditions_accepted_on_transaction"], "col_types": ["T", "T", "T", "T", "LT", "T", "T", "T", "T", "T", "TS", "T", "T", "LT", "T"]},
        #{"name": "costs", "pk": 1, "ck": 1, "col_names": ["provider", "action", "basis_fee_description", "basis_points", "cost_type_basis_points", "cost_type_fixed", "currency", "fixed_fee", "fixed_fee_description", "rev_share_fixed_percentage"], "col_types": ["T", "T", "T", "T", "T", "T", "T", "T", "T", "T"]},
        #{"name": "countries", "pk": 1, "ck": 0, "col_names": ["alpha2", "enabled", "high_risk_bin", "high_risk_ip", "name", "numeric", "ofac_sanction_program", "phone_prefix", "prohibited", "region", "risk_level", "subcontinent", "supported_merchant_jurisdiction"], "col_types": ["T", "B", "B", "B", "T", "I", "B", "I", "B", "T", "TI", "T", "B"]},
        #{"name": "credorax_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "credorax_merchant_id", "credorax_secret"], "col_types": ["T", "T", "T"]},
        #{"name": "currencies", "pk": 1, "ck": 0, "col_names": ["alpha3", "digits_after_point", "exponent", "locations_using", "name", "numeric"], "col_types": ["T", "I", "I", "T", "T", "I"]},
        #{"name": "email_templates", "pk": 1, "ck": 0, "col_names": ["id", "content", "created_at", "name", "parent_id", "subject", "updated_at"], "col_types": ["T", "T", "T", "T", "T", "T", "T"]},
        #{"name": "epx_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "epx_cust_number", "epx_dba_number", "epx_merchant_number", "epx_terminal_number"], "col_types": ["T", "T", "T", "T", "T"]},
        #{"name": "exchange_rates", "pk": 1, "ck": 1, "col_names": ["base_currency", "quote_currency", "close_ask", "close_bid", "close_midpoint", "close_time"], "col_types": ["T", "T", "I", "I", "I", "TS"]},
        #{"name": "export_fields", "pk": 1, "ck": 1, "col_names": ["table_name", "field_key", "category", "field_description", "field_name", "is_default", "priority"], "col_types": ["T", "T", "T", "T", "T", "B", "TI"]},
        #{"name": "fees", "pk": 1, "ck": 1, "col_names": ["transaction_key", "id", "apply_as_network_fee", "bank_transfer_reference", "basis_points", "blended", "clearing_date", "collected", "commission_id", "company_id", "conversion_rate", "cost_type", "created_at", "estimated", "fee_description", "fee_identifier", "fee_type", "gross", "gross_invoice_id", "internal_metadata", "is_basis_points", "merchant_excluded", "merchant_id", "payment_id", "payment_method_type", "pricing_segment_code", "processing_currency", "processing_currency_amount", "provider", "recurring", "referral_buy_rate_basis_points", "referral_buy_rate_basis_points_amount", "referral_buy_rate_fixed", "referral_exchange_rate", "referral_id", "referral_rev_share_tier_basis_points", "referral_rev_share_tier_name", "reseller_id", "settlement_account_id", "settlement_currency", "settlement_currency_amount", "settlement_id", "tier_strategy_id", "time_hourly", "transaction_attempt_id", "transaction_id", "transaction_provider", "transaction_settlement_currency_amount", "transaction_timestamp", "transaction_type", "updated_at"], "col_types": ["T", "T", "B", "T", "T", "B", "T", "B", "T", "T", "T", "T", "T", "B", "T", "T", "T", "B", "T", "MT", "B", "B", "T", "T", "T", "T", "T", "T", "T", "B", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T"]},
        #{"name": "global_kv_store", "pk": 1, "ck": 0, "col_names": ["key", "value"], "col_types": ["T", "T"]},
        #{"name": "googlepay_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "googlepay_merchant_id"], "col_types": ["T", "T"]},
        #{"name": "idempotency_keys", "pk": 1, "ck": 0, "col_names": ["idemp_key", "request", "response", "route", "status"], "col_types": ["T", "T", "T", "T", "T"]},
        #{"name": "jti_blacklist", "pk": 1, "ck": 0, "col_names": ["token_jti"], "col_types": ["T"]},
        #{"name": "mcc", "pk": 1, "ck": 0, "col_names": ["mcc", "aml_rank", "description", "enabled", "exposure_factor", "exposure_risk_category", "primary_category", "risk_tier"], "col_types": ["I", "TI", "T", "B", "D", "T", "T", "TI"]},
        #{"name": "merchant_default_export_fields", "pk": 1, "ck": 2, "col_names": ["company_id", "merchant_id", "table_name", "export_fields_keys"], "col_types": ["T", "T", "T", "LT"]},
        #{"name": "merchant_mids", "pk": 1, "ck": 3, "col_names": ["acquirer", "company_id", "merchant_id", "scheme", "acquirer_mid", "scheme_mid"], "col_types": ["T", "T", "T", "T", "T", "T"]},
        #{"name": "monek_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "monek_merchant_id"], "col_types": ["T", "T"]},
        #{"name": "nets_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "nets_merchant_id", "nets_merchant_secret"], "col_types": ["T", "T", "T"]},
        #{"name": "nuvei_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "nuvei_dispute_password", "nuvei_dispute_secret", "nuvei_dispute_username", "nuvei_merchant_host", "nuvei_merchant_id", "nuvei_merchant_secret_key", "nuvei_merchant_site_id"], "col_types": ["T", "T", "T", "T", "T", "T", "T", "T"]},
        #{"name": "okto_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "okto_api_key", "okto_url_host"], "col_types": ["T", "T", "T"]},
        #{"name": "openfinance_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "api_key", "api_secret", "open_finance_merchant"], "col_types": ["T", "T", "T", "T"]},
        #{"name": "partners_categories", "pk": 1, "ck": 0, "col_names": ["category_id", "category_description", "category_name"], "col_types": ["T", "T", "T"]},
        #{"name": "payfuture_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "midcode", "midsecret"], "col_types": ["T", "T", "T"]},
        #{"name": "payment_control_snapshots", "pk": 1, "ck": 2, "col_names": ["key", "id", "attempt_id", "default_3ds_processor", "default_processor", "default_processor_amex", "default_processor_discover", "default_processor_map", "default_processor_mastercard", "default_processor_visa", "retry_providers"], "col_types": ["T", "T", "T", "T", "T", "T", "T", "MT", "T", "T", "LT"]},
        #{"name": "paynt_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "account_id", "api_key", "entity_id", "password"], "col_types": ["T", "T", "T", "T", "T"]},
        #{"name": "paypal_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "paypal_merchant_email", "paypal_merchant_id"], "col_types": ["T", "T", "T"]},
        #{"name": "paysafecard_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "paysafecard_submerchant_id"], "col_types": ["T", "T"]},
        #{"name": "permissions", "pk": 1, "ck": 0, "col_names": ["key", "category", "created_at", "name", "updated_at"], "col_types": ["T", "T", "T", "T", "T"]},
        #{"name": "ppro_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "contract_id"], "col_types": ["T", "T"]},
        #{"name": "providers", "pk": 1, "ck": 0, "col_names": ["key", "address", "disable_ssl", "port"], "col_types": ["T", "T", "B", "T"]},
        #{"name": "providers_mapping", "pk": 1, "ck": 2, "col_names": ["short_value", "field_name", "provider", "original_value"], "col_types": ["T", "T", "T", "T"]},
        #{"name": "reconciliations", "pk": 1, "ck": 1, "col_names": ["provider", "id", "dry_run", "end_date", "failure_reason", "filename", "reconciliation_type", "start_date", "status", "transactions_count", "transactions_count_failure", "transactions_count_success"], "col_types": ["T", "T", "B", "T", "T", "T", "T", "T", "T", "T", "T", "T"]},
        #{"name": "refresh_token_blacklist", "pk": 1, "ck": 0, "col_names": ["refresh_token"], "col_types": ["T"]},
        #{"name": "reserves", "pk": 1, "ck": 3, "col_names": ["company_id", "merchant_id", "settlement_id", "id", "created_at", "currency", "current_amount", "duration", "original_amount", "percentage", "planned_release_date", "released_at", "released_settlement_id", "status", "updated_at"], "col_types": ["T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "T"]},
        #{"name": "reserves_v1", "pk": 1, "ck": 2, "col_names": ["company_id", "settlement_config_id", "id", "amount", "bank_transfer_reference", "created_at", "currency", "merchant_id", "planned_release_date", "released", "released_at", "released_settlement_id", "settlement_id", "status", "updated_at"], "col_types": ["T", "T", "T", "T", "T", "T", "T", "T", "T", "B", "T", "T", "T", "T", "T"]},
        #{"name": "roles", "pk": 1, "ck": 2, "col_names": ["company_id", "merchant_id", "name", "created_at", "description", "permissions", "updated_at"], "col_types": ["T", "T", "T", "T", "T", "LT", "T"]},
        #{"name": "rules_run_cache", "pk": 1, "ck": 1, "col_names": ["key", "rule_id"], "col_types": ["T", "T"]},
        #{"name": "safecharge_credentials", "pk": 1, "ck": 0, "col_names": ["site_id", "sfc_merchant_id", "sfc_secret", "sfc_site_id"], "col_types": ["T", "T", "T", "T"]},
        #{"name": "service_fees", "pk": 1, "ck": 2, "col_names": ["company_id", "merchant_id", "id", "amount", "collected", "commission_id", "cost_type", "created_at", "currency", "fee_description", "fee_identifier", "fee_type", "gross", "gross_invoice_id", "provider", "referral_id", "reseller_id", "settlement_id", "updated_at"], "col_types": ["T", "T", "T", "T", "B", "T", "T", "T", "T", "T", "T", "T", "B", "T", "T", "T", "T", "T", "T"]},
        #{"name": "settlement_account_balances", "pk": 1, "ck": 0, "col_names": ["settlement_account_id", "currency", "net_amount", "updated_at"], "col_types": ["T", "T", "T", "T"]},
        #{"name": "settlement_account_mids", "pk": 1, "ck": 3, "col_names": ["company_id", "settlement_account_id", "scheme", "currency", "bin", "caid", "created_at", "mcc", "updated_at"], "col_types": ["T", "T", "T", "T", "T", "T", "T", "T", "T"]},
        #{"name": "sftp", "pk": 1, "ck": 1, "col_names": ["company_id", "merchant_id", "ip_ranges", "public_key"], "col_types": ["T", "T", "T", "T"]},
        #{"name": "sites", "pk": 1, "ck": 1, "col_names": ["merchant_id", "id", "notify_url", "site", "website"], "col_types": ["T", "T", "T", "T", "T"]},
        #{"name": "stripe_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "standalone_3ds_acquirer_bin", "standalone_3ds_acquirer_country", "standalone_3ds_acquirer_merchant_id", "standalone_3ds_mcc", "standalone_3ds_use_connected_account", "stripe_api_key", "stripe_billing_account_id", "stripe_connected_account_id", "stripe_reporting_api_key", "stripe_reporting_webhook_secret"], "col_types": ["T", "T", "T", "T", "T", "B", "T", "T", "T", "T", "T"]},
        #{"name": "structures", "pk": 1, "ck": 1, "col_names": ["country_alpha2", "key", "aml_risk_score", "description", "enabled", "local_name", "name", "region"], "col_types": ["T", "T", "TI", "T", "B", "T", "T", "T"]},
        #{"name": "tabapay_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "tabapay_additional_sub_client_ids", "tabapay_api_key", "tabapay_client_id", "tabapay_settlement_account_id", "tabapay_sub_client_id"], "col_types": ["T", "MT", "T", "T", "T", "T"]},
        #{"name": "task_categories", "pk": 1, "ck": 0, "col_names": ["value", "title"], "col_types": ["T", "T"]},
        #{"name": "temporal_actions_webhooks_0", "pk": 1, "ck": 1, "col_names": ["identifier", "unique_key", "action", "body", "namespace", "signal_body", "signal_type", "task_queue", "workflow_type"], "col_types": ["T", "T", "T", "T", "T", "T", "T", "T", "T"]},
        #{"name": "tiered_pricing_strategies", "pk": 1, "ck": 0, "col_names": ["id", "name", "query", "timeframe", "type"], "col_types": ["T", "T", "T", "T", "T"]},
        #{"name": "users", "pk": 1, "ck": 2, "col_names": ["company_id", "merchant_id", "id", "country_alpha2", "created_at", "description", "email", "first_name", "last_login", "last_name", "metadata", "mfa_enrolled", "phone", "role", "status", "super_user", "updated_at"], "col_types": ["T", "T", "T", "T", "T", "T", "T", "T", "T", "T", "MT", "B", "T", "T", "T", "B", "T"]},
        #{"name": "visa_click_to_pay_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "visa_dpa_client_id", "visa_merchant_id"], "col_types": ["T", "T", "T"]},
        #{"name": "visa_decision_manager_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "cybersource_key", "cybersource_mid", "cybersource_secret"], "col_types": ["T", "T", "T", "T"]},
        #{"name": "vyne_credentials", "pk": 1, "ck": 0, "col_names": ["merchant_id", "destination_accounts", "vyne_merchant_id"], "col_types": ["T", "MT", "T"]},
        #{"name": "webhooks", "pk": 1, "ck": 1, "col_names": ["merchant_id", "id", "company_id", "enabled", "event_types", "initial_delay", "name", "secret_key", "url"], "col_types": ["T", "T", "T", "B", "LT", "T", "T", "T", "T"]}
    ]
}

/////////////////////////////////
///// Workload Functions /////
/////////////////////////////////

pub async fn prepare(db) {
    println!("Preparing workload for simple tables...");
    assert!(ROW_COUNT_PER_TABLE > 0, "'row_count_per_table' cannot be less than '1'");

    let registry = get_simple_tables_registry();
    db.data.simple_tables = [];
    db.data.num_simple_tables = registry.len();
    println!("debug: Registering {n} simple tables for workload", n=registry.len());

    for table_meta in registry {
        let table_name = table_meta.name;
        let col_names = table_meta.col_names;
        let pk_count = table_meta.pk;
        let ck_count = table_meta.ck;

        // Build column name list and placeholder list for INSERT
        let col_list = "";
        let val_list = "";
        let col_i = 0;
        while col_i < col_names.len() {
            if col_i > 0 {
                col_list += ", ";
                val_list += ", ";
            }
            col_list += col_names[col_i];
            val_list += "?";
            col_i += 1;
        }

        // Build INSERT prepared statement
        let insert_name = `pay__${table_name}__insert`;
        let insert_cql = `INSERT INTO pay.${table_name} (${col_list}) VALUES (${val_list})`;
        db.prepare(insert_name, insert_cql).await?;

        // Build SELECT prepared statement (WHERE clause uses PK + CK columns)
        let where_clause = "";
        let where_i = 0;
        while where_i < pk_count + ck_count {
            if where_i > 0 {
                where_clause += " AND ";
            }
            where_clause += `${col_names[where_i]} = ?`;
            where_i += 1;
        }

        let sel_name = `pay__${table_name}__sel`;
        let sel_cql = `SELECT * FROM pay.${table_name} WHERE ${where_clause}`;
        db.prepare(sel_name, sel_cql).await?;

        // Build DELETE prepared statement (same WHERE clause as SELECT)
        let del_name = `pay__${table_name}__del`;
        let del_cql = `DELETE FROM pay.${table_name} WHERE ${where_clause}`;
        db.prepare(del_name, del_cql).await?;

        // Build UPDATE prepared statement (update first non-PK/CK column if any)
        let upd_name = "";
        let key_count = pk_count + ck_count;
        if col_names.len() > key_count {
            upd_name = `pay__${table_name}__upd`;
            // Update the first non-key column
            let upd_col = col_names[key_count];
            let upd_cql = `UPDATE pay.${table_name} SET ${upd_col} = ? WHERE ${where_clause}`;
            db.prepare(upd_name, upd_cql).await?;
        }

        // Store table info for write/read/delete/update functions
        db.data.simple_tables.push(#{
            "name": table_name,
            "insert": insert_name,
            "sel": sel_name,
            "del": del_name,
            "upd": upd_name,
            "col_types": table_meta.col_types,
            "col_names": col_names,
            "pk_count": pk_count,
            "ck_count": ck_count,
        });
    }

    println!("debug: All {n} simple tables prepared successfully", n=db.data.num_simple_tables);
    prepare_gauss_distribution(db).await;

    // Phase 4: Also prepare UDT tables
    prepare_udt_tables(db).await;
    db.data.total_tables = db.data.num_simple_tables + db.data.num_udt_tables;
    println!("debug: Total tables registered: {n}", n=db.data.total_tables);

    // Phase 6: Table windowing setup
    prepare_table_windowing(db).await;
}

/// Populate tables with initial data. Distributes inserts across all simple tables evenly.
/// Each call inserts one row into one table. Table is selected by: i % num_tables.
/// Row index within the table is: i / num_tables.
pub async fn populate(db, i) {
    let table_idx = i % db.data.num_simple_tables;
    let row_idx = i / db.data.num_simple_tables;

    if row_idx >= ROW_COUNT_PER_TABLE {
        return; // Already populated enough rows for this table
    }

    let table = db.data.simple_tables[table_idx];
    let values = gen_row_values(table, row_idx).await;
    db.execute_prepared(table.insert, values).await?
}

/// Write workload function. Inserts/upserts rows across simple tables.
/// Supports Gaussian distribution for row index selection.
pub async fn write(db, i) {
    let table_idx = i % db.data.num_simple_tables;
    let row_idx = get_partition_idx(db, i / db.data.num_simple_tables).await;

    let table = db.data.simple_tables[table_idx];
    let values = gen_row_values(table, row_idx).await;
    db.execute_prepared(table.insert, values).await?
}

/// Read workload function. Reads rows from simple tables using primary key lookups.
/// Supports Gaussian distribution and optional data validation.
pub async fn read(db, i) {
    let table_idx = i % db.data.num_simple_tables;
    let row_idx = get_partition_idx(db, i / db.data.num_simple_tables).await;

    let table = db.data.simple_tables[table_idx];

    // Generate PK + CK values for the WHERE clause
    let key_count = table.pk_count + table.ck_count;
    let key_values = [];
    let key_i = 0;
    while key_i < key_count {
        let seed = hash2(row_idx, key_i);
        key_values.push(gen_value(table.col_types[key_i], seed).await);
        key_i += 1;
    }

    if !DATA_VALIDATION {
        db.execute_prepared(table.sel, key_values).await?
    } else {
        let rows = db.execute_prepared_with_result(table.sel, key_values).await?;
        let rows_len = rows.len();
        if rows_len != 1 {
            db.signal_failure(
                `Expected 1 row from pay.${table.name}, got ${rows_len}. ` +
                `row_idx=${row_idx}`
            ).await?;
        }
    }
}

pub async fn verify_cdc(db, i) {
    // TODO: Phase 5 - Implement CDC verification
    // CDC verification requires reading from CDC log tables after writes
    // to CDC-enabled tables. Simple tables in Phase 3 do not have CDC enabled.
}


///////////////////////////////////////////
///// Phase 4: UDT Data Generator /////////
///////////////////////////////////////////

/// CQL literal helpers - generate string representations for CQL VALUES clauses
/// Note: We use hash_range-based text to avoid special chars (single quotes)
/// that would break CQL literal syntax.
fn cql_text_raw(seed) {
    let h1 = hash_range(seed, 999999999);
    let h2 = hash_range(hash2(seed, 77), 999999999);
    "t" + h1.to_string() + h2.to_string()
}

fn cql_text(seed) {
    "'" + cql_text_raw(seed) + "'"
}

fn cql_int(seed) {
    (hash_range(seed, 10000)).to_string()
}

fn cql_bool(seed) {
    if hash_range(seed, 2) == 0 { "true" } else { "false" }
}

fn cql_double(seed) {
    let v = hash_range(seed, 1000000);
    let whole = v / 1000;
    let frac = v % 1000;
    whole.to_string() + "." + frac.to_string()
}

fn cql_tinyint(seed) {
    (hash_range(seed, 127)).to_string()
}

fn cql_timestamp(seed) {
    (1577836800000 + hash_range(seed, 157680000000)).to_string()
}

fn cql_timeuuid(seed) {
    // Use a deterministic UUID-like text value
    let u = uuid(seed);
    u.to_string()
}

fn cql_blob(seed) {
    // Generate a hex string for blob
    "0x" + text(seed, 32)
}

fn cql_float(seed) {
    cql_double(seed)
}

fn cql_list_text(seed) {
    "[" + cql_text(seed) + ", " + cql_text(hash2(seed, 1)) + "]"
}

fn cql_set_text(seed) {
    "{" + cql_text(seed) + ", " + cql_text(hash2(seed, 1)) + "}"
}

fn cql_map_tt(seed) {
    "{" + cql_text(seed) + ": " + cql_text(hash2(seed, 100)) + "}"
}

fn cql_map_tb(seed) {
    "{" + cql_text(seed) + ": " + cql_bool(hash2(seed, 100)) + "}"
}

fn cql_map_fmm(seed) {
    "{" + cql_text(seed) + ": {" + cql_text(hash2(seed, 50)) + ": " + cql_text(hash2(seed, 51)) + "}}"
}

fn cql_map_flt(seed) {
    "{" + cql_text(seed) + ": [" + cql_text(hash2(seed, 50)) + "]}"
}

/// UDT literal generators - one function per UDT type
fn cql_pay_additional_pricing_actions(s) {
    "{" +     "approval: " + cql_list_text(hash2(s, 0)) + ", " +     "decline: " + cql_list_text(hash2(s, 1)) + "}"
}
fn cql_pay_report_config_email(s) {
    "{" +     "enabled: " + cql_bool(hash2(s, 0)) + ", " +     "emails: " + cql_list_text(hash2(s, 1)) + "}"
}
fn cql_pay_payment_method_card(s) {
    "{" +
    "name: " + cql_text(hash2(s, 0)) + ", " +
    "expiry_month: " + cql_text(hash2(s, 1)) + ", " +
    "expiry_year: " + cql_text(hash2(s, 2)) + ", " +
    "bin: " + cql_text(hash2(s, 3)) + ", " +
    "last_four_digits: " + cql_text(hash2(s, 4)) + ", " +
    "issuer_name: " + cql_text(hash2(s, 5)) + ", " +
    "national_identification_number: " + cql_text(hash2(s, 6)) + ", " +
    "brand: " + cql_text(hash2(s, 7)) + ", " +
    "issuer_country: " + cql_text(hash2(s, 8)) + ", " +
    "card_type: " + cql_text(hash2(s, 9)) + ", " +
    "card_category: " + cql_text(hash2(s, 10)) + ", " +
    "fingerprint: " + cql_text(hash2(s, 11)) + ", " +
    "cvc_check: " + cql_text(hash2(s, 12)) + ", " +
    "address_line1_check: " + cql_text(hash2(s, 13)) + ", " +
    "address_postal_code_check: " + cql_text(hash2(s, 14)) + ", " +
    "network: " + cql_text(hash2(s, 15)) + ", " +
    "raw_details_provided: " + cql_bool(hash2(s, 16)) + ", " +
    "duplicate_card: " + cql_bool(hash2(s, 17)) + ", " +
    "wallet: " + cql_text(hash2(s, 18)) + ", " +
    "cardholder_currency: " + cql_text(hash2(s, 19)) + ", " +
    "wallet_tokenized_card_last4: " + cql_text(hash2(s, 20)) + ", " +
    "payout: " + cql_text(hash2(s, 21)) + ", " +
    "wallet_tokenized_card_bin: " + cql_text(hash2(s, 22)) + ", " +
    "wallet_tokenized_card_expiry_month: " + cql_text(hash2(s, 23)) + ", " +
    "wallet_tokenized_card_expiry_year: " + cql_text(hash2(s, 24)) +
    "}"
}
fn cql_pay_us_decline_details(s) {
    "{" +     "decline_reason: " + cql_text(hash2(s, 0)) + ", " +     "comment: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_chargeback_detail(s) {
    "{" +     "chargeback_amount: " + cql_text(hash2(s, 0)) + ", " +     "chargeback_count: " + cql_int(hash2(s, 1)) + ", " +     "chargeback_fees: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_eu_business_processing_info(s) {
    "{" +
    "is_website_pci_compliant: " + cql_bool(hash2(s, 0)) + ", " +
    "saq_type: " + cql_text(hash2(s, 1)) + ", " +
    "third_party_integration: " + cql_bool(hash2(s, 2)) + ", " +
    "third_party_integration_description: " + cql_text(hash2(s, 3)) + ", " +
    "email_receipts: " + cql_bool(hash2(s, 4)) + ", " +
    "orders_fulfilled_directly: " + cql_bool(hash2(s, 5)) + ", " +
    "customer_access_type: " + cql_text(hash2(s, 6)) + ", " +
    "fraud_prevention_service_used: " + cql_bool(hash2(s, 7)) + ", " +
    "fraud_prevention_service_description: " + cql_text(hash2(s, 8)) + ", " +
    "chargeback_procedure_description: " + cql_text(hash2(s, 9)) + ", " +
    "platform_requires_test_user: " + cql_bool(hash2(s, 10)) + ", " +
    "test_username: " + cql_text(hash2(s, 11)) + ", " +
    "test_password: " + cql_text(hash2(s, 12)) +
    "}"
}
fn cql_pay_us_bank_account_method_options_v2(s) {
    "{" +     "ach_payment_type: " + cql_text(hash2(s, 0)) + "}"
}
fn cql_pay_payment_method_options_collection_item_v2(s) {
    "{" +     "enabled: " + cql_bool(hash2(s, 0)) + "}"
}
fn cql_pay_us_exposure_risk(s) {
    "{" +
    "category: " + cql_text(hash2(s, 0)) + ", " +
    "calculated_exposure: " + cql_text(hash2(s, 1)) + ", " +
    "percent_held_back: " + cql_text(hash2(s, 2)) + ", " +
    "rolling_reserve_days: " + cql_int(hash2(s, 3)) +
    "}"
}
fn cql_pay_us_underwriting_info(s) {
    "{" +     "close_relation_with_pay_employees: " + cql_bool(hash2(s, 0)) + ", " +     "close_relation_with_pay_employees_description: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_payment_method_skrill(s) {
    "{" +
    "email: " + cql_text(hash2(s, 0)) + ", " +
    "first_name: " + cql_text(hash2(s, 1)) + ", " +
    "last_name: " + cql_text(hash2(s, 2)) + ", " +
    "customer_id: " + cql_text(hash2(s, 3)) + ", " +
    "mb_transaction_id: " + cql_text(hash2(s, 4)) +
    "}"
}
fn cql_pay_worldpay_three_ds_credentials(s) {
    "{" +     "worldpay_mac_key: " + cql_text(hash2(s, 0)) + ", " +     "worldpay_api_id: " + cql_text(hash2(s, 1)) + ", " +     "worldpay_org_unit_id: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_pinless_debit_options(s) {
    "{" +     "enabled: " + cql_bool(hash2(s, 0)) + "}"
}
fn cql_pay_eu_underwriting_info(s) {
    "{" +     "close_relation_with_pay_employees: " + cql_bool(hash2(s, 0)) + ", " +     "close_relation_with_pay_employees_description: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_card_method_options_security_checks_limits(s) {
    "{" +     "address_line1_check: " + cql_text(hash2(s, 0)) + ", " +     "address_postal_code_check: " + cql_text(hash2(s, 1)) + ", " +     "cvv_check: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_dropdown_options(s) {
    "{" +     "label: " + cql_text(hash2(s, 0)) + ", " +     "value: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_us_onboarding_provider_error(s) {
    "{" +
    "value: " + cql_text(hash2(s, 0)) + ", " +
    "provider_name: " + cql_text(hash2(s, 1)) + ", " +
    "field_path: " + cql_text(hash2(s, 2)) + ", " +
    "error_message: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_us_verification_comment(s) {
    "{" +
    "added_at: " + cql_text(hash2(s, 0)) + ", " +
    "added_by: " + cql_text(hash2(s, 1)) + ", " +
    "message: " + cql_text(hash2(s, 2)) + ", " +
    "updated_at: " + cql_text(hash2(s, 3)) + ", " +
    "updated_by: " + cql_text(hash2(s, 4)) +
    "}"
}
fn cql_pay_us_check_sub_type(s) {
    "{" +
    "type: " + cql_text(hash2(s, 0)) + ", " +
    "result: " + cql_text(hash2(s, 1)) + ", " +
    "sub_categories: " + cql_map_tt(hash2(s, 2)) + ", " +
    "check_sub_result: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_common_settings_amount(s) {
    "{" +     "type: " + cql_text(hash2(s, 0)) + ", " +     "amount: " + cql_text(hash2(s, 1)) + ", " +     "dynamic_amount_url: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_collection_param_settings(s) {
    "{" +     "enabled: " + cql_bool(hash2(s, 0)) + ", " +     "allowed_countries: " + cql_list_text(hash2(s, 1)) + "}"
}
fn cql_pay_card_method_options_security_checks(s) {
    "{" +     "address_line1_check: " + cql_bool(hash2(s, 0)) + ", " +     "address_postal_code_check: " + cql_bool(hash2(s, 1)) + ", " +     "cvv_check: " + cql_bool(hash2(s, 2)) + "}"
}
fn cql_pay_payment_method_bank_account(s) {
    "{" +
    "country: " + cql_text(hash2(s, 0)) + ", " +
    "currency: " + cql_text(hash2(s, 1)) + ", " +
    "last4: " + cql_text(hash2(s, 2)) + ", " +
    "account_holder_name: " + cql_text(hash2(s, 3)) + ", " +
    "account_holder_type: " + cql_text(hash2(s, 4)) + ", " +
    "routing_number: " + cql_text(hash2(s, 5)) + ", " +
    "fingerprint: " + cql_text(hash2(s, 6)) + ", " +
    "account_type: " + cql_text(hash2(s, 7)) + ", " +
    "bank_name: " + cql_text(hash2(s, 8)) + ", " +
    "source: " + cql_text(hash2(s, 9)) + ", " +
    "details: " + cql_map_tt(hash2(s, 10)) +
    "}"
}
fn cql_pay_accepted_ani_results_breakdown(s) {
    "{" +
    "first_name: " + cql_list_text(hash2(s, 0)) + ", " +
    "last_name: " + cql_list_text(hash2(s, 1)) + ", " +
    "middle_name: " + cql_list_text(hash2(s, 2)) + ", " +
    "full_name: " + cql_list_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_card_method_options_limits(s) {
    "{" +
    "accepted_card_brands: " + cql_list_text(hash2(s, 0)) + ", " +
    "accepted_card_funding: " + cql_list_text(hash2(s, 1)) + ", " +
    "accepted_card_jurisdictions: " + cql_list_text(hash2(s, 2)) + ", " +
    "enforce_customer_name_as_cardholder_name: " + cql_text(hash2(s, 3)) + ", " +
    "request_threed_secure: " + cql_list_text(hash2(s, 4)) + ", " +
    "security_checks: " + cql_pay_card_method_options_security_checks_limits(hash2(s, 5)) + ", " +
    "duplicate_card_check: " + cql_text(hash2(s, 6)) + ", " +
    "accepted_card_categories: " + cql_list_text(hash2(s, 7)) +
    "}"
}
fn cql_pay_note(s) {
    "{" +
    "added_at: " + cql_text(hash2(s, 0)) + ", " +
    "added_by: " + cql_text(hash2(s, 1)) + ", " +
    "message: " + cql_text(hash2(s, 2)) + ", " +
    "section: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_network_specific_fields(s) {
    "{" +
    "transaction_identifier: " + cql_text(hash2(s, 0)) + ", " +
    "banknet_reference: " + cql_text(hash2(s, 1)) + ", " +
    "trace_id: " + cql_text(hash2(s, 2)) + ", " +
    "advice_code: " + cql_text(hash2(s, 3)) + ", " +
    "ucaf: " + cql_text(hash2(s, 4)) + ", " +
    "aci_code: " + cql_text(hash2(s, 5)) + ", " +
    "par: " + cql_text(hash2(s, 6)) +
    "}"
}
fn cql_pay_collection(s) {
    "{" +
    "billing_address: " + cql_pay_collection_param_settings(hash2(s, 0)) + ", " +
    "shipping_address: " + cql_pay_collection_param_settings(hash2(s, 1)) + ", " +
    "phone_number: " + cql_pay_collection_param_settings(hash2(s, 2)) + ", " +
    "tax_id: " + cql_pay_collection_param_settings(hash2(s, 3)) + ", " +
    "full_name: " + cql_pay_collection_param_settings(hash2(s, 4)) + ", " +
    "email_address: " + cql_pay_collection_param_settings(hash2(s, 5)) +
    "}"
}
fn cql_pay_finance_commission_setup(s) {
    "{" +     "id: " + cql_text(hash2(s, 0)) + ", " +     "basis_points: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_reconciliation_config_params(s) {
    "{" +     "boolean: " + cql_bool(hash2(s, 0)) + ", " +     "string: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_suspicion_reporter(s) {
    "{" +
    "name: " + cql_text(hash2(s, 0)) + ", " +
    "phone_number: " + cql_text(hash2(s, 1)) + ", " +
    "email: " + cql_text(hash2(s, 2)) + ", " +
    "department: " + cql_text(hash2(s, 3)) + ", " +
    "position: " + cql_text(hash2(s, 4)) +
    "}"
}
fn cql_pay_address_v2(s) {
    "{" +
    "address_line: " + cql_text(hash2(s, 0)) + ", " +
    "address_line2: " + cql_text(hash2(s, 1)) + ", " +
    "zip: " + cql_text(hash2(s, 2)) + ", " +
    "city: " + cql_text(hash2(s, 3)) + ", " +
    "state: " + cql_text(hash2(s, 4)) + ", " +
    "country_alpha2: " + cql_text(hash2(s, 5)) +
    "}"
}
fn cql_pay_three_ri_options(s) {
    "{" +     "indicator: " + cql_text(hash2(s, 0)) + ", " +     "require_issuer_liability_shift: " + cql_bool(hash2(s, 1)) + "}"
}
fn cql_pay_card_method_options_network_token_provision_v2(s) {
    "{" +     "enabled: " + cql_bool(hash2(s, 0)) + ", " +     "decline_on_failure: " + cql_bool(hash2(s, 1)) + "}"
}
fn cql_pay_payout_prepaid_card_options(s) {
    "{" +     "product: " + cql_text(hash2(s, 0)) + ", " +     "verification_type: " + cql_text(hash2(s, 1)) + ", " +     "distribution_method: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_rename_fields_type(s) {
    "{" +     "rename_map: " + cql_map_tt(hash2(s, 0)) + "}"
}
fn cql_pay_report_config_s3(s) {
    "{" +     "enabled: " + cql_bool(hash2(s, 0)) + ", " +     "bucket: " + cql_text(hash2(s, 1)) + ", " +     "folder: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_filter_field(s) {
    "{" +     "name: " + cql_text(hash2(s, 0)) + ", " +     "operator: " + cql_text(hash2(s, 1)) + ", " +     "value: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_payout_interac_name_verification_options(s) {
    "{" +     "enabled: " + cql_bool(hash2(s, 0)) + ", " +     "similarity_acceptance: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_routing_details_stored_processor_token(s) {
    "{" +     "processor_token: " + cql_text(hash2(s, 0)) + ", " +     "processor_account_id: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_payment_method_options_googlepay_shipping_address_v2(s) {
    "{" +     "enabled: " + cql_bool(hash2(s, 0)) + ", " +     "include_phone_number: " + cql_bool(hash2(s, 1)) + ", " +     "allowed_countries: " + cql_list_text(hash2(s, 2)) + "}"
}
fn cql_pay_aps_tokens(s) {
    "{" +
    "merchant_guid: " + cql_text(hash2(s, 0)) + ", " +
    "method_guid: " + cql_text(hash2(s, 1)) + ", " +
    "app_token: " + cql_text(hash2(s, 2)) + ", " +
    "app_secret: " + cql_text(hash2(s, 3)) + ", " +
    "callback_secret_key: " + cql_text(hash2(s, 4)) +
    "}"
}
fn cql_pay_payment_method_paysafecard(s) {
    "{" +
    "customer_id: " + cql_text(hash2(s, 0)) + ", " +
    "serial: " + cql_text(hash2(s, 1)) + ", " +
    "currency: " + cql_text(hash2(s, 2)) + ", " +
    "amount: " + cql_text(hash2(s, 3)) + ", " +
    "country: " + cql_text(hash2(s, 4)) + ", " +
    "email: " + cql_text(hash2(s, 5)) +
    "}"
}
fn cql_pay_sms_notification_config(s) {
    "{" +     "content: " + cql_text(hash2(s, 0)) + "}"
}
fn cql_pay_business_details(s) {
    "{" +
    "company_registration_number: " + cql_text(hash2(s, 0)) + ", " +
    "vat_number: " + cql_text(hash2(s, 1)) + ", " +
    "website: " + cql_text(hash2(s, 2)) + ", " +
    "mcc: " + cql_int(hash2(s, 3)) + ", " +
    "business_description: " + cql_text(hash2(s, 4)) + ", " +
    "country_alpha2: " + cql_text(hash2(s, 5)) + ", " +
    "email: " + cql_text(hash2(s, 6)) +
    "}"
}
fn cql_pay_request_sca_exemption(s) {
    "{" +     "sca_exemption_type: " + cql_text(hash2(s, 0)) + ", " +     "soft_decline_loop: " + cql_bool(hash2(s, 1)) + ", " +     "soft_decline_loop_decline_codes: " + cql_list_text(hash2(s, 2)) + "}"
}
fn cql_pay_us_address_v2(s) {
    "{" +
    "address_line: " + cql_text(hash2(s, 0)) + ", " +
    "address_line2: " + cql_text(hash2(s, 1)) + ", " +
    "zip: " + cql_text(hash2(s, 2)) + ", " +
    "city: " + cql_text(hash2(s, 3)) + ", " +
    "state: " + cql_text(hash2(s, 4)) + ", " +
    "country_alpha2: " + cql_text(hash2(s, 5)) +
    "}"
}
fn cql_pay_paypal_method_options_v2(s) {
    "{" +     "name_verification: " + cql_bool(hash2(s, 0)) + "}"
}
fn cql_pay_silverflow_merchant_acceptor_key(s) {
    "{" +     "visa: " + cql_text(hash2(s, 0)) + ", " +     "mastercard: " + cql_text(hash2(s, 1)) + ", " +     "amex: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_flow_directions(s) {
    "{" +     "payment: " + cql_bool(hash2(s, 0)) + ", " +     "payout: " + cql_bool(hash2(s, 1)) + "}"
}
fn cql_pay_fees_detail(s) {
    "{" +
    "processed_amount: " + cql_text(hash2(s, 0)) + ", " +
    "processed_count: " + cql_int(hash2(s, 1)) + ", " +
    "processing_fees: " + cql_text(hash2(s, 2)) + ", " +
    "interchange_fees: " + cql_text(hash2(s, 3)) + ", " +
    "network_fees: " + cql_text(hash2(s, 4)) + ", " +
    "total_fees: " + cql_text(hash2(s, 5)) +
    "}"
}
fn cql_pay_address(s) {
    "{" +
    "first_name: " + cql_text(hash2(s, 0)) + ", " +
    "last_name: " + cql_text(hash2(s, 1)) + ", " +
    "phone: " + cql_text(hash2(s, 2)) + ", " +
    "email: " + cql_text(hash2(s, 3)) + ", " +
    "address: " + cql_text(hash2(s, 4)) + ", " +
    "zip: " + cql_text(hash2(s, 5)) + ", " +
    "city: " + cql_text(hash2(s, 6)) + ", " +
    "state: " + cql_text(hash2(s, 7)) + ", " +
    "country_alpha: " + cql_text(hash2(s, 8)) + ", " +
    "country_number: " + cql_text(hash2(s, 9)) +
    "}"
}
fn cql_pay_card_method_options(s) {
    "{" +
    "accepted_card_brands: " + cql_list_text(hash2(s, 0)) + ", " +
    "accepted_card_funding: " + cql_list_text(hash2(s, 1)) + ", " +
    "request_threed_secure: " + cql_text(hash2(s, 2)) + ", " +
    "enforce_customer_name_as_cardholder_name: " + cql_bool(hash2(s, 3)) + ", " +
    "accepted_card_jurisdictions: " + cql_list_text(hash2(s, 4)) + ", " +
    "security_checks: " + cql_pay_card_method_options_security_checks(hash2(s, 5)) + ", " +
    "duplicate_card_check: " + cql_bool(hash2(s, 6)) + ", " +
    "accepted_card_categories: " + cql_list_text(hash2(s, 7)) + ", " +
    "accepted_card_countries: " + cql_list_text(hash2(s, 8)) + ", " +
    "moto: " + cql_bool(hash2(s, 9)) + ", " +
    "accepted_eci_values: " + cql_list_text(hash2(s, 10)) + ", " +
    "dynamic_currency_conversion: " + cql_bool(hash2(s, 11)) + ", " +
    "providers: " + cql_list_text(hash2(s, 12)) +
    "}"
}
fn cql_pay_eu_exposure_risk(s) {
    "{" +
    "category: " + cql_text(hash2(s, 0)) + ", " +
    "calculated_exposure: " + cql_text(hash2(s, 1)) + ", " +
    "percent_held_back: " + cql_text(hash2(s, 2)) + ", " +
    "rolling_reserve_days: " + cql_int(hash2(s, 3)) +
    "}"
}
fn cql_pay_email_notification_config(s) {
    "{" +     "email_id: " + cql_text(hash2(s, 0)) + "}"
}
fn cql_pay_card_method_options_network_token_authorization_v2(s) {
    "{" +     "enabled: " + cql_bool(hash2(s, 0)) + ", " +     "full_pan_fallback: " + cql_bool(hash2(s, 1)) + "}"
}
fn cql_pay_notification_subscription_delivery_config(s) {
    "{" +
    "email_enabled: " + cql_bool(hash2(s, 0)) + ", " +
    "sms_enabled: " + cql_bool(hash2(s, 1)) + ", " +
    "phone: " + cql_text(hash2(s, 2)) + ", " +
    "email: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_suspicion_report(s) {
    "{" +
    "id: " + cql_text(hash2(s, 0)) + ", " +
    "reporter: " + cql_pay_suspicion_reporter(hash2(s, 1)) + ", " +
    "suspicion_description: " + cql_text(hash2(s, 2)) + ", " +
    "suspicion_reason: " + cql_text(hash2(s, 3)) + ", " +
    "last_updated_by: " + cql_text(hash2(s, 4)) + ", " +
    "last_updated_on: " + cql_text(hash2(s, 5)) +
    "}"
}
fn cql_pay_payment_method_paysafecash(s) {
    "{" +
    "email: " + cql_text(hash2(s, 0)) + ", " +
    "first_name: " + cql_text(hash2(s, 1)) + ", " +
    "last_name: " + cql_text(hash2(s, 2)) + ", " +
    "customer_id: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_processing_fees_breakdown_by_card_product(s) {
    "{" +     "consumer: " + cql_pay_fees_detail(hash2(s, 0)) + ", " +     "business: " + cql_pay_fees_detail(hash2(s, 1)) + ", " +     "unknown: " + cql_pay_fees_detail(hash2(s, 2)) + "}"
}
fn cql_pay_fonix_services_credentials(s) {
    "{" +     "sid: " + cql_text(hash2(s, 0)) + ", " +     "api_key: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_cybersource_risk_interval(s) {
    "{" +     "start: " + cql_int(hash2(s, 0)) + ", " +     "end: " + cql_int(hash2(s, 1)) + ", " +     "decision: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_tier_object(s) {
    "{" +
    "from_value: " + cql_text(hash2(s, 0)) + ", " +
    "to_value: " + cql_text(hash2(s, 1)) + ", " +
    "fixed_fee: " + cql_text(hash2(s, 2)) + ", " +
    "basis_points: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_us_aml_risk(s) {
    "{" +
    "category: " + cql_text(hash2(s, 0)) + ", " +
    "total_score: " + cql_text(hash2(s, 1)) + ", " +
    "high_risk_reason: " + cql_text(hash2(s, 2)) + ", " +
    "description: " + cql_text(hash2(s, 3)) + ", " +
    "renewal_date: " + cql_text(hash2(s, 4)) + ", " +
    "renewal_date_reason: " + cql_text(hash2(s, 5)) +
    "}"
}
fn cql_pay_eu_aml_risk(s) {
    "{" +
    "category: " + cql_text(hash2(s, 0)) + ", " +
    "total_score: " + cql_text(hash2(s, 1)) + ", " +
    "high_risk_reason: " + cql_text(hash2(s, 2)) + ", " +
    "description: " + cql_text(hash2(s, 3)) + ", " +
    "renewal_date: " + cql_text(hash2(s, 4)) + ", " +
    "renewal_date_reason: " + cql_text(hash2(s, 5)) +
    "}"
}
fn cql_pay_processing_fees_breakdown_by_scheme(s) {
    "{" +
    "visa: " + cql_pay_fees_detail(hash2(s, 0)) + ", " +
    "mastercard: " + cql_pay_fees_detail(hash2(s, 1)) + ", " +
    "amex: " + cql_pay_fees_detail(hash2(s, 2)) + ", " +
    "discover: " + cql_pay_fees_detail(hash2(s, 3)) +
    "}"
}
fn cql_pay_payout_us_bank_account_options(s) {
    "{" +     "rail: " + cql_text(hash2(s, 0)) + ", " +     "ach_payment_type: " + cql_text(hash2(s, 1)) + ", " +     "fallback_to_ach: " + cql_bool(hash2(s, 2)) + "}"
}
fn cql_pay_eu_social_media(s) {
    "{" +     "type: " + cql_text(hash2(s, 0)) + ", " +     "value: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_statement_delivery_record(s) {
    "{" +     "emails: " + cql_set_text(hash2(s, 0)) + ", " +     "sent_at: " + cql_text(hash2(s, 1)) + ", " +     "email_id: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_pricing_additional_configuration(s) {
    "{" +     "return_interchange_for_refunds: " + cql_bool(hash2(s, 0)) + ", " +     "markup_network_fees: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_fallback_config(s) {
    "{" +     "default_config: " + cql_bool(hash2(s, 0)) + ", " +     "settlement_account_id: " + cql_text(hash2(s, 1)) + ", " +     "failure_codes: " + cql_list_text(hash2(s, 2)) + "}"
}
fn cql_pay_routing_details_rule_engine(s) {
    "{" +     "rule_id: " + cql_text(hash2(s, 0)) + "}"
}
fn cql_pay_eu_fulfillment_details(s) {
    "{" +     "physical_goods: " + cql_bool(hash2(s, 0)) + ", " +     "fulfillment_method: " + cql_text(hash2(s, 1)) + ", " +     "delivery_timeframe: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_us_onboarding_provider_errors(s) {
    "{" +     "application_error: " + cql_text(hash2(s, 0)) + ", " +     "field_errors: " + "[" + cql_pay_us_onboarding_provider_error(hash2(s, 1)) + "]" + "}"
}
fn cql_pay_receipt_delivery_record(s) {
    "{" +     "emails: " + cql_set_text(hash2(s, 0)) + ", " +     "sent_at: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_eu_country_volume_share(s) {
    "{" +     "region: " + cql_text(hash2(s, 0)) + ", " +     "percentage: " + cql_text(hash2(s, 1)) + ", " +     "countries: " + cql_list_text(hash2(s, 2)) + "}"
}
fn cql_pay_custom_fields_validation(s) {
    "{" +
    "required: " + cql_bool(hash2(s, 0)) + ", " +
    "max: " + cql_int(hash2(s, 1)) + ", " +
    "min: " + cql_int(hash2(s, 2)) + ", " +
    "max_length: " + cql_int(hash2(s, 3)) + ", " +
    "min_length: " + cql_int(hash2(s, 4)) + ", " +
    "pattern: " + cql_text(hash2(s, 5)) +
    "}"
}
fn cql_pay_paypal_method_options(s) {
    "{" +     "name_verification: " + cql_bool(hash2(s, 0)) + "}"
}
fn cql_pay_ecp_tokens(s) {
    "{" +
    "cvv_on: " + cql_text(hash2(s, 0)) + ", " +
    "cvv_off: " + cql_text(hash2(s, 1)) + ", " +
    "moto: " + cql_text(hash2(s, 2)) + ", " +
    "three_ds: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_after_completion_hosted_confirmation(s) {
    "{" +     "custom_message: " + cql_text(hash2(s, 0)) + "}"
}
fn cql_pay_eu_decline_details(s) {
    "{" +     "decline_reason: " + cql_text(hash2(s, 0)) + ", " +     "comment: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_us_infinicept_category(s) {
    "{" +     "value: " + cql_text(hash2(s, 0)) + ", " +     "status: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_evidence_references(s) {
    "{" +
    "proof_of_delivery_or_service: " + cql_text(hash2(s, 0)) + ", " +
    "invoice_or_receipt: " + cql_text(hash2(s, 1)) + ", " +
    "invoice_showing_distinct_transactions: " + cql_text(hash2(s, 2)) + ", " +
    "customer_communication: " + cql_text(hash2(s, 3)) + ", " +
    "refund_or_cancellation_policy: " + cql_text(hash2(s, 4)) + ", " +
    "recurring_transaction_agreement: " + cql_text(hash2(s, 5)) + ", " +
    "additional_evidence: " + cql_text(hash2(s, 6)) + ", " +
    "proof_of_delivery_or_service_date: " + cql_text(hash2(s, 7)) +
    "}"
}
fn cql_pay_us_fulfillment_details(s) {
    "{" +     "physical_goods: " + cql_bool(hash2(s, 0)) + ", " +     "fulfillment_method: " + cql_text(hash2(s, 1)) + ", " +     "delivery_timeframe: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_apm_frontend_content(s) {
    "{" +     "type: " + cql_text(hash2(s, 0)) + ", " +     "content: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_eu_infinicept_category(s) {
    "{" +     "value: " + cql_text(hash2(s, 0)) + ", " +     "status: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_payment_method_netbanking(s) {
    "{" +     "bank_code: " + cql_text(hash2(s, 0)) + ", " +     "bank_name: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_common_settings_subscription_status(s) {
    "{" +     "current_subscription: " + cql_text(hash2(s, 0)) + ", " +     "other_subscriptions: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_custom_fields_label(s) {
    "{" +     "custom: " + cql_text(hash2(s, 0)) + ", " +     "type: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_workflow_param(s) {
    "{" +     "key: " + cql_text(hash2(s, 0)) + ", " +     "description: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_us_risk(s) {
    "{" +
    "aml_risk: " + cql_pay_us_aml_risk(hash2(s, 0)) + ", " +
    "exposure_risk: " + cql_pay_us_exposure_risk(hash2(s, 1)) + ", " +
    "processing_risk_score: " + cql_text(hash2(s, 2)) + ", " +
    "is_overridden: " + cql_bool(hash2(s, 3)) + ", " +
    "renewal_date: " + cql_text(hash2(s, 4)) + ", " +
    "renewal_date_reason: " + cql_text(hash2(s, 5)) +
    "}"
}
fn cql_pay_after_completion_redirect(s) {
    "{" +     "url: " + cql_text(hash2(s, 0)) + "}"
}
fn cql_pay_risk_calculation_details(s) {
    "{" +
    "parameter: " + cql_text(hash2(s, 0)) + ", " +
    "value: " + cql_text(hash2(s, 1)) + ", " +
    "type: " + cql_text(hash2(s, 2)) + ", " +
    "source: " + cql_text(hash2(s, 3)) + ", " +
    "score: " + cql_int(hash2(s, 4)) +
    "}"
}
fn cql_pay_report_config_sftp(s) {
    "{" +
    "enabled: " + cql_bool(hash2(s, 0)) + ", " +
    "host: " + cql_text(hash2(s, 1)) + ", " +
    "port: " + cql_text(hash2(s, 2)) + ", " +
    "username: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_custom_text_submit(s) {
    "{" +     "message: " + cql_text(hash2(s, 0)) + "}"
}
fn cql_pay_common_settings_interval(s) {
    "{" +     "interval: " + cql_text(hash2(s, 0)) + ", " +     "interval_count: " + cql_int(hash2(s, 1)) + "}"
}
fn cql_pay_payment_method_neteller(s) {
    "{" +
    "email: " + cql_text(hash2(s, 0)) + ", " +
    "first_name: " + cql_text(hash2(s, 1)) + ", " +
    "last_name: " + cql_text(hash2(s, 2)) + ", " +
    "customer_id: " + cql_text(hash2(s, 3)) + ", " +
    "country: " + cql_text(hash2(s, 4)) +
    "}"
}
fn cql_pay_partial_approval_finalize(s) {
    "{" +
    "status: " + cql_text(hash2(s, 0)) + ", " +
    "amount_requested: " + cql_text(hash2(s, 1)) + ", " +
    "amount_authorized: " + cql_text(hash2(s, 2)) + ", " +
    "amount_charged: " + cql_text(hash2(s, 3)) + ", " +
    "product_id: " + cql_text(hash2(s, 4)) +
    "}"
}
fn cql_pay_us_note(s) {
    "{" +
    "added_at: " + cql_text(hash2(s, 0)) + ", " +
    "added_by: " + cql_text(hash2(s, 1)) + ", " +
    "message: " + cql_text(hash2(s, 2)) + ", " +
    "section: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_task_note(s) {
    "{" +
    "id: " + cql_text(hash2(s, 0)) + ", " +
    "note: " + cql_text(hash2(s, 1)) + ", " +
    "created_at: " + cql_text(hash2(s, 2)) + ", " +
    "created_by: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_payment_method_options_providers(s) {
    "{" +
    "settlement_account_id: " + cql_text(hash2(s, 0)) + ", " +
    "provider: " + cql_text(hash2(s, 1)) + ", " +
    "routing_key: " + cql_text(hash2(s, 2)) + ", " +
    "retryable_decline_codes: " + cql_list_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_task_fields_options(s) {
    "{" +     "label: " + cql_text(hash2(s, 0)) + ", " +     "value: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_entity_contact_info(s) {
    "{" +     "phone: " + cql_text(hash2(s, 0)) + ", " +     "email: " + cql_text(hash2(s, 1)) + ", " +     "name: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_customer_details_match_options(s) {
    "{" +
    "first_name: " + cql_bool(hash2(s, 0)) + ", " +
    "last_name: " + cql_bool(hash2(s, 1)) + ", " +
    "country: " + cql_bool(hash2(s, 2)) + ", " +
    "postal_code: " + cql_bool(hash2(s, 3)) + ", " +
    "line1: " + cql_bool(hash2(s, 4)) + ", " +
    "dob: " + cql_bool(hash2(s, 5)) +
    "}"
}
fn cql_pay_eu_implementation(s) {
    "{" +     "predefined_types: " + cql_list_text(hash2(s, 0)) + ", " +     "custom_type: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_routing_details_initial_mit(s) {
    "{" +     "transaction_id: " + cql_text(hash2(s, 0)) + "}"
}
fn cql_pay_task_list_value(s) {
    "{" +
    "string_value: " + cql_text(hash2(s, 0)) + ", " +
    "bool_value: " + cql_bool(hash2(s, 1)) + ", " +
    "json_value: " + cql_text(hash2(s, 2)) + ", " +
    "number_value: " + cql_int(hash2(s, 3)) +
    "}"
}
fn cql_pay_us_bank_account_method_options_limits(s) {
    "{" +     "ach_payment_type: " + cql_list_text(hash2(s, 0)) + "}"
}
fn cql_pay_us_social_media(s) {
    "{" +     "type: " + cql_text(hash2(s, 0)) + ", " +     "value: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_ani_verification_details(s) {
    "{" +
    "match_performed: " + cql_text(hash2(s, 0)) + ", " +
    "provider: " + cql_text(hash2(s, 1)) + ", " +
    "full_name_match: " + cql_text(hash2(s, 2)) + ", " +
    "first_name_match: " + cql_text(hash2(s, 3)) + ", " +
    "middle_name_match: " + cql_text(hash2(s, 4)) + ", " +
    "last_name_match: " + cql_text(hash2(s, 5)) + ", " +
    "action_code: " + cql_text(hash2(s, 6)) + ", " +
    "match_details: " + cql_text(hash2(s, 7)) + ", " +
    "provider_transaction_id: " + cql_text(hash2(s, 8)) +
    "}"
}
fn cql_pay_us_country_volume_share(s) {
    "{" +     "region: " + cql_text(hash2(s, 0)) + ", " +     "percentage: " + cql_text(hash2(s, 1)) + ", " +     "countries: " + cql_list_text(hash2(s, 2)) + "}"
}
fn cql_pay_schedule_config_settlement(s) {
    "{" +     "schedule: " + cql_text(hash2(s, 0)) + ", " +     "day: " + cql_int(hash2(s, 1)) + "}"
}
fn cql_pay_eu_onboarding_schedule_config_settlement(s) {
    "{" +     "schedule: " + cql_text(hash2(s, 0)) + ", " +     "day: " + cql_int(hash2(s, 1)) + "}"
}
fn cql_pay_us_implementation(s) {
    "{" +     "predefined_types: " + cql_list_text(hash2(s, 0)) + ", " +     "custom_type: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_logic_fields_additional_settings(s) {
    "{" +     "depends_on_external_risk_engine: " + cql_bool(hash2(s, 0)) + "}"
}
fn cql_pay_notification_delivery_config(s) {
    "{" +
    "email_enabled: " + cql_bool(hash2(s, 0)) + ", " +
    "sms_enabled: " + cql_bool(hash2(s, 1)) + ", " +
    "email_config: " + cql_pay_email_notification_config(hash2(s, 2)) + ", " +
    "sms_config: " + cql_pay_sms_notification_config(hash2(s, 3)) +
    "}"
}
fn cql_pay_task_category(s) {
    "{" +     "value: " + cql_text(hash2(s, 0)) + ", " +     "title: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_browser_details(s) {
    "{" +
    "accept_header: " + cql_text(hash2(s, 0)) + ", " +
    "javascript_enabled: " + cql_bool(hash2(s, 1)) + ", " +
    "language: " + cql_text(hash2(s, 2)) + ", " +
    "user_agent: " + cql_text(hash2(s, 3)) + ", " +
    "screen_width: " + cql_int(hash2(s, 4)) + ", " +
    "screen_height: " + cql_int(hash2(s, 5)) + ", " +
    "timezone_offset: " + cql_text(hash2(s, 6)) + ", " +
    "java_enabled: " + cql_bool(hash2(s, 7)) + ", " +
    "color_depth: " + cql_int(hash2(s, 8)) +
    "}"
}
fn cql_pay_customer_support(s) {
    "{" +
    "statement_descriptor: " + cql_text(hash2(s, 0)) + ", " +
    "phone: " + cql_text(hash2(s, 1)) + ", " +
    "email: " + cql_text(hash2(s, 2)) + ", " +
    "address: " + cql_pay_address_v2(hash2(s, 3)) +
    "}"
}
fn cql_pay_eu_onboarding_provider_error(s) {
    "{" +
    "value: " + cql_text(hash2(s, 0)) + ", " +
    "provider_name: " + cql_text(hash2(s, 1)) + ", " +
    "field_path: " + cql_text(hash2(s, 2)) + ", " +
    "error_message: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_eu_onboarding_channel(s) {
    "{" +
    "channel: " + cql_text(hash2(s, 0)) + ", " +
    "solicitor: " + cql_text(hash2(s, 1)) + ", " +
    "solicitor_email: " + cql_text(hash2(s, 2)) + ", " +
    "solicitor_name: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_custom_fields_dropdown(s) {
    "{" +     "options: " + "[" + cql_pay_dropdown_options(hash2(s, 0)) + "]" + "}"
}
fn cql_pay_silverflow_credentials_payout(s) {
    "{" +     "silverflow_merchant_acceptor_key: " + cql_pay_silverflow_merchant_acceptor_key(hash2(s, 0)) + ", " +     "silverflow_credentials_by_currency: " + "{'" + cql_text_raw(hash2(s, 1)) + "': " + cql_pay_silverflow_merchant_acceptor_key(hash2(hash2(s, 1), 99)) + "}" + "}"
}
fn cql_pay_payment_method_upi(s) {
    "{" +     "vpa: " + cql_text(hash2(s, 0)) + "}"
}
fn cql_pay_card_method_options_security_checks_v2(s) {
    "{" +     "address_line1_check: " + cql_bool(hash2(s, 0)) + ", " +     "address_postal_code_check: " + cql_bool(hash2(s, 1)) + ", " +     "cvv_check: " + cql_bool(hash2(s, 2)) + "}"
}
fn cql_pay_eu_note(s) {
    "{" +
    "added_at: " + cql_text(hash2(s, 0)) + ", " +
    "added_by: " + cql_text(hash2(s, 1)) + ", " +
    "message: " + cql_text(hash2(s, 2)) + ", " +
    "section: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_risk_alert_status_details(s) {
    "{" +
    "status: " + cql_text(hash2(s, 0)) + ", " +
    "notes: " + "[" + cql_pay_note(hash2(s, 1)) + "]" + ", " +
    "documents: " + cql_list_text(hash2(s, 2)) + ", " +
    "assignee: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_us_customer_support(s) {
    "{" +
    "statement_descriptor: " + cql_text(hash2(s, 0)) + ", " +
    "phone: " + cql_text(hash2(s, 1)) + ", " +
    "email: " + cql_text(hash2(s, 2)) + ", " +
    "address: " + cql_pay_us_address_v2(hash2(s, 3)) +
    "}"
}
fn cql_pay_contact_info(s) {
    "{" +
    "phone: " + cql_text(hash2(s, 0)) + ", " +
    "email: " + cql_text(hash2(s, 1)) + ", " +
    "first_name: " + cql_text(hash2(s, 2)) + ", " +
    "last_name: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_finance_rev_share_tiers(s) {
    "{" +
    "basis_points: " + cql_text(hash2(s, 0)) + ", " +
    "from_volume: " + cql_text(hash2(s, 1)) + ", " +
    "to_volume: " + cql_text(hash2(s, 2)) + ", " +
    "name: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_payment_method_options_applepay_shipping_address_v2(s) {
    "{" +     "enabled: " + cql_bool(hash2(s, 0)) + ", " +     "include_phone_number: " + cql_bool(hash2(s, 1)) + "}"
}
fn cql_pay_authentication_context(s) {
    "{" +     "customer_ip_address: " + cql_text(hash2(s, 0)) + ", " +     "browser_details: " + cql_pay_browser_details(hash2(s, 1)) + "}"
}
fn cql_pay_logic_field_options(s) {
    "{" +     "label: " + cql_text(hash2(s, 0)) + ", " +     "value: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_routing_details(s) {
    "{" +
    "selected_methodology: " + cql_text(hash2(s, 0)) + ", " +
    "initial_mit: " + cql_pay_routing_details_initial_mit(hash2(s, 1)) + ", " +
    "stored_processor_token: " + cql_pay_routing_details_stored_processor_token(hash2(s, 2)) + ", " +
    "rule_engine: " + cql_pay_routing_details_rule_engine(hash2(s, 3)) +
    "}"
}
fn cql_pay_eu_verification_comment(s) {
    "{" +
    "added_at: " + cql_text(hash2(s, 0)) + ", " +
    "added_by: " + cql_text(hash2(s, 1)) + ", " +
    "message: " + cql_text(hash2(s, 2)) + ", " +
    "updated_at: " + cql_text(hash2(s, 3)) + ", " +
    "updated_by: " + cql_text(hash2(s, 4)) +
    "}"
}
fn cql_pay_payment_method_paypal(s) {
    "{" +
    "email: " + cql_text(hash2(s, 0)) + ", " +
    "payer_id: " + cql_text(hash2(s, 1)) + ", " +
    "first_name: " + cql_text(hash2(s, 2)) + ", " +
    "last_name: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_us_provider_method_infinicept(s) {
    "{" +
    "acceptable_use: " + cql_pay_us_infinicept_category(hash2(s, 0)) + ", " +
    "credit: " + cql_pay_us_infinicept_category(hash2(s, 1)) + ", " +
    "fraud: " + cql_pay_us_infinicept_category(hash2(s, 2)) + ", " +
    "kyc_business: " + cql_pay_us_infinicept_category(hash2(s, 3)) + ", " +
    "kyc_personal: " + cql_pay_us_infinicept_category(hash2(s, 4)) + ", " +
    "social: " + cql_pay_us_infinicept_category(hash2(s, 5)) +
    "}"
}
fn cql_pay_payment_method_zimpler(s) {
    "{" +
    "country: " + cql_text(hash2(s, 0)) + ", " +
    "user_id: " + cql_text(hash2(s, 1)) + ", " +
    "national_identification_number: " + cql_text(hash2(s, 2)) + ", " +
    "account_number: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_three_ds_type_options(s) {
    "{" +     "type: " + cql_text(hash2(s, 0)) + ", " +     "allow_frictionless: " + cql_bool(hash2(s, 1)) + ", " +     "sca_exemption_type: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_cvv_whitelist(s) {
    "{" +     "enabled: " + cql_bool(hash2(s, 0)) + ", " +     "duration: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_decline_recovery_setting(s) {
    "{" +     "enabled: " + cql_bool(hash2(s, 0)) + ", " +     "settlement_account_id: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_eu_check_sub_type(s) {
    "{" +
    "type: " + cql_text(hash2(s, 0)) + ", " +
    "result: " + cql_text(hash2(s, 1)) + ", " +
    "sub_categories: " + cql_map_tt(hash2(s, 2)) + ", " +
    "check_sub_result: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_payment_method_paypal_billing_agreement(s) {
    "{" +
    "ba_token: " + cql_text(hash2(s, 0)) + ", " +
    "ba_id: " + cql_text(hash2(s, 1)) + ", " +
    "email: " + cql_text(hash2(s, 2)) + ", " +
    "first_name: " + cql_text(hash2(s, 3)) + ", " +
    "last_name: " + cql_text(hash2(s, 4)) + ", " +
    "payer_id: " + cql_text(hash2(s, 5)) +
    "}"
}
fn cql_pay_custom_text_shipping_address(s) {
    "{" +     "message: " + cql_text(hash2(s, 0)) + "}"
}
fn cql_pay_us_bank_account_method_options(s) {
    "{" +     "ach_payment_type: " + cql_text(hash2(s, 0)) + "}"
}
fn cql_pay_us_verification_check(s) {
    "{" +
    "check_stage: " + cql_text(hash2(s, 0)) + ", " +
    "check_type: " + cql_text(hash2(s, 1)) + ", " +
    "provider_name: " + cql_text(hash2(s, 2)) + ", " +
    "status: " + cql_text(hash2(s, 3)) + ", " +
    "check_sub_types: " + "[" + cql_pay_us_check_sub_type(hash2(s, 4)) + "]" + ", " +
    "comments: " + "[" + cql_pay_us_verification_comment(hash2(s, 5)) + "]" + ", " +
    "manual: " + cql_bool(hash2(s, 6)) + ", " +
    "check_date: " + cql_text(hash2(s, 7)) + ", " +
    "updated_by: " + cql_text(hash2(s, 8)) + ", " +
    "added_by: " + cql_text(hash2(s, 9)) + ", " +
    "updated_at: " + cql_text(hash2(s, 10)) +
    "}"
}
fn cql_pay_gumballpay_tokens(s) {
    "{" +     "endpoint_id: " + cql_text(hash2(s, 0)) + ", " +     "endpoint_group_id: " + cql_text(hash2(s, 1)) + ", " +     "private_key: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_us_onboarding_settlement_details(s) {
    "{" +
    "settlement_currency: " + cql_text(hash2(s, 0)) + ", " +
    "bank_name: " + cql_text(hash2(s, 1)) + ", " +
    "bank_country: " + cql_text(hash2(s, 2)) + ", " +
    "beneficiary_name: " + cql_text(hash2(s, 3)) + ", " +
    "iban: " + cql_text(hash2(s, 4)) + ", " +
    "swift: " + cql_text(hash2(s, 5)) + ", " +
    "beneficiary_address: " + cql_pay_us_address_v2(hash2(s, 6)) + ", " +
    "id: " + cql_text(hash2(s, 7)) + ", " +
    "paired_currencies: " + cql_list_text(hash2(s, 8)) +
    "}"
}
fn cql_pay_master_account_details(s) {
    "{" +
    "iban: " + cql_text(hash2(s, 0)) + ", " +
    "swift_bic: " + cql_text(hash2(s, 1)) + ", " +
    "account_identifier: " + cql_text(hash2(s, 2)) + ", " +
    "currency: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_common_settings_retries(s) {
    "{" +     "attempts: " + cql_int(hash2(s, 0)) + ", " +     "interval: " + cql_text(hash2(s, 1)) + ", " +     "interval_count: " + cql_int(hash2(s, 2)) + "}"
}
fn cql_pay_chargeback_breakdown_by_scheme(s) {
    "{" +
    "visa: " + cql_pay_chargeback_detail(hash2(s, 0)) + ", " +
    "mastercard: " + cql_pay_chargeback_detail(hash2(s, 1)) + ", " +
    "amex: " + cql_pay_chargeback_detail(hash2(s, 2)) + ", " +
    "discover: " + cql_pay_chargeback_detail(hash2(s, 3)) +
    "}"
}
fn cql_pay_recurring_time_settings(s) {
    "{" +
    "days_of_week: " + cql_text(hash2(s, 0)) + ", " +
    "days_of_month: " + cql_text(hash2(s, 1)) + ", " +
    "day_time: " + cql_text(hash2(s, 2)) + ", " +
    "last_day_of_month: " + cql_bool(hash2(s, 3)) +
    "}"
}
fn cql_pay_us_onboarding_schedule_config_settlement(s) {
    "{" +     "schedule: " + cql_text(hash2(s, 0)) + ", " +     "day: " + cql_int(hash2(s, 1)) + "}"
}
fn cql_pay_eu_address_v2(s) {
    "{" +
    "address_line: " + cql_text(hash2(s, 0)) + ", " +
    "address_line2: " + cql_text(hash2(s, 1)) + ", " +
    "zip: " + cql_text(hash2(s, 2)) + ", " +
    "city: " + cql_text(hash2(s, 3)) + ", " +
    "state: " + cql_text(hash2(s, 4)) + ", " +
    "country_alpha2: " + cql_text(hash2(s, 5)) +
    "}"
}
fn cql_pay_custom_fields_options(s) {
    "{" +     "label: " + cql_text(hash2(s, 0)) + ", " +     "value: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_expiry_options(s) {
    "{" +     "type: " + cql_text(hash2(s, 0)) + "}"
}
fn cql_pay_evaluation_report(s) {
    "{" +
    "evaluation_report_id: " + cql_text(hash2(s, 0)) + ", " +
    "enquiries_undertaken: " + cql_text(hash2(s, 1)) + ", " +
    "decision_of_the_amlco: " + cql_text(hash2(s, 2)) + ", " +
    "decision_description: " + cql_text(hash2(s, 3)) + ", " +
    "external_report_reference: " + cql_text(hash2(s, 4)) + ", " +
    "evaluation_date: " + cql_text(hash2(s, 5)) + ", " +
    "last_updated_by: " + cql_text(hash2(s, 6)) + ", " +
    "last_updated_on: " + cql_text(hash2(s, 7)) + ", " +
    "attached_document_ids: " + cql_list_text(hash2(s, 8)) +
    "}"
}
fn cql_pay_us_onboarding_channel(s) {
    "{" +
    "channel: " + cql_text(hash2(s, 0)) + ", " +
    "solicitor: " + cql_text(hash2(s, 1)) + ", " +
    "solicitor_email: " + cql_text(hash2(s, 2)) + ", " +
    "solicitor_name: " + cql_text(hash2(s, 3)) +
    "}"
}
fn cql_pay_validation_config(s) {
    "{" +
    "key: " + cql_text(hash2(s, 0)) + ", " +
    "error_message: " + cql_text(hash2(s, 1)) + ", " +
    "required: " + cql_bool(hash2(s, 2)) + ", " +
    "min_length: " + cql_int(hash2(s, 3)) + ", " +
    "max_length: " + cql_int(hash2(s, 4)) + ", " +
    "pattern: " + cql_text(hash2(s, 5)) + ", " +
    "min_value: " + cql_double(hash2(s, 6)) + ", " +
    "max_value: " + cql_double(hash2(s, 7)) +
    "}"
}
fn cql_pay_task_template_field(s) {
    "{" +
    "id: " + cql_text(hash2(s, 0)) + ", " +
    "created_at: " + cql_text(hash2(s, 1)) + ", " +
    "type: " + cql_text(hash2(s, 2)) + ", " +
    "label: " + cql_text(hash2(s, 3)) + ", " +
    "placeholder: " + cql_text(hash2(s, 4)) + ", " +
    "options: " + "[" + cql_pay_task_fields_options(hash2(s, 5)) + "]" + ", " +
    "readonly: " + cql_bool(hash2(s, 6)) + ", " +
    "external_id: " + cql_text(hash2(s, 7)) +
    "}"
}
fn cql_pay_us_business_structure_details(s) {
    "{" +
    "business_structure: " + cql_text(hash2(s, 0)) + ", " +
    "business_registered_country: " + cql_text(hash2(s, 1)) + ", " +
    "registered_business_address: " + cql_pay_us_address_v2(hash2(s, 2)) + ", " +
    "business_phone_number: " + cql_text(hash2(s, 3)) + ", " +
    "number_of_employees: " + cql_text(hash2(s, 4)) + ", " +
    "date_of_incorporation: " + cql_text(hash2(s, 5)) + ", " +
    "physical_business_address: " + cql_pay_us_address_v2(hash2(s, 6)) + ", " +
    "companies_group: " + cql_bool(hash2(s, 7)) + ", " +
    "group_name: " + cql_text(hash2(s, 8)) + ", " +
    "group_website: " + cql_text(hash2(s, 9)) + ", " +
    "public_company: " + cql_bool(hash2(s, 10)) + ", " +
    "bankruptcy_proceedings: " + cql_bool(hash2(s, 11)) + ", " +
    "business_email: " + cql_text(hash2(s, 12)) + ", " +
    "business_conduction_location: " + cql_text(hash2(s, 13)) +
    "}"
}
fn cql_pay_risk_control_payment_method_options(s) {
    "{" +     "start: " + cql_int(hash2(s, 0)) + ", " +     "end: " + cql_int(hash2(s, 1)) + ", " +     "outcome: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_processor_config(s) {
    "{" +
    "default_processor: " + cql_text(hash2(s, 0)) + ", " +
    "default_processor_map: " + cql_map_tt(hash2(s, 1)) + ", " +
    "default3_ds_processor: " + cql_text(hash2(s, 2)) + ", " +
    "routing_key: " + cql_text(hash2(s, 3)) + ", " +
    "retry_providers: " + cql_list_text(hash2(s, 4)) + ", " +
    "transacting_mid_country: " + cql_text(hash2(s, 5)) + ", " +
    "settlement_account_id: " + cql_text(hash2(s, 6)) +
    "}"
}
fn cql_pay_risk_alert_customer(s) {
    "{" +
    "name: " + cql_text(hash2(s, 0)) + ", " +
    "address: " + cql_pay_address_v2(hash2(s, 1)) + ", " +
    "contact_number: " + cql_text(hash2(s, 2)) + ", " +
    "date_of_incorporation: " + cql_text(hash2(s, 3)) + ", " +
    "email: " + cql_text(hash2(s, 4)) + ", " +
    "country_of_incorporation: " + cql_text(hash2(s, 5)) +
    "}"
}
fn cql_pay_payment_method_generic(s) {
    "{" +     "type: " + cql_text(hash2(s, 0)) + ", " +     "details: " + cql_map_tt(hash2(s, 1)) + "}"
}
fn cql_pay_payment_method_options_collection_applepay_v2(s) {
    "{" +
    "billing_address: " + cql_pay_payment_method_options_collection_item_v2(hash2(s, 0)) + ", " +
    "email: " + cql_pay_payment_method_options_collection_item_v2(hash2(s, 1)) + ", " +
    "name: " + cql_pay_payment_method_options_collection_item_v2(hash2(s, 2)) + ", " +
    "phone_number: " + cql_pay_payment_method_options_collection_item_v2(hash2(s, 3)) + ", " +
    "shipping_address: " + cql_pay_payment_method_options_applepay_shipping_address_v2(hash2(s, 4)) +
    "}"
}
fn cql_pay_us_provider_data(s) {
    "{" +
    "provider: " + cql_text(hash2(s, 0)) + ", " +
    "provider_errors: " + cql_pay_us_onboarding_provider_errors(hash2(s, 1)) + ", " +
    "provider_ma_id: " + cql_text(hash2(s, 2)) + ", " +
    "provider_status: " + cql_text(hash2(s, 3)) + ", " +
    "provider_merchant_id: " + cql_text(hash2(s, 4)) + ", " +
    "underwriting_results_url: " + cql_text(hash2(s, 5)) + ", " +
    "infinicept: " + cql_pay_us_provider_method_infinicept(hash2(s, 6)) + ", " +
    "last_updated: " + cql_text(hash2(s, 7)) +
    "}"
}
fn cql_pay_payment_link_amount_limits(s) {
    "{" +     "max: " + cql_text(hash2(s, 0)) + ", " +     "min: " + cql_text(hash2(s, 1)) + "}"
}
fn cql_pay_eu_onboarding_provider_errors(s) {
    "{" +     "application_error: " + cql_text(hash2(s, 0)) + ", " +     "field_errors: " + "[" + cql_pay_eu_onboarding_provider_error(hash2(s, 1)) + "]" + "}"
}
fn cql_pay_us_business_processing_info(s) {
    "{" +
    "is_website_pci_compliant: " + cql_bool(hash2(s, 0)) + ", " +
    "saq_type: " + cql_text(hash2(s, 1)) + ", " +
    "third_party_integration: " + cql_bool(hash2(s, 2)) + ", " +
    "third_party_integration_description: " + cql_text(hash2(s, 3)) + ", " +
    "email_receipts: " + cql_bool(hash2(s, 4)) + ", " +
    "orders_fulfilled_directly: " + cql_bool(hash2(s, 5)) + ", " +
    "customer_access_type: " + cql_text(hash2(s, 6)) + ", " +
    "fraud_prevention_service_used: " + cql_bool(hash2(s, 7)) + ", " +
    "fraud_prevention_service_description: " + cql_text(hash2(s, 8)) + ", " +
    "chargeback_procedure_description: " + cql_text(hash2(s, 9)) + ", " +
    "platform_requires_test_user: " + cql_bool(hash2(s, 10)) + ", " +
    "test_username: " + cql_text(hash2(s, 11)) + ", " +
    "test_password: " + cql_text(hash2(s, 12)) +
    "}"
}
fn cql_pay_partial_approval_products(s) {
    "{" +
    "amount: " + cql_text(hash2(s, 0)) + ", " +
    "description: " + cql_text(hash2(s, 1)) + ", " +
    "id: " + cql_text(hash2(s, 2)) + ", " +
    "image: " + cql_text(hash2(s, 3)) + ", " +
    "title: " + cql_text(hash2(s, 4)) +
    "}"
}
fn cql_pay_bank_details(s) {
    "{" +     "iban: " + cql_text(hash2(s, 0)) + ", " +     "currency_code: " + cql_text(hash2(s, 1)) + ", " +     "country_alpha2: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_payout_interac_options(s) {
    "{" +     "name_verification: " + cql_pay_payout_interac_name_verification_options(hash2(s, 0)) + "}"
}
fn cql_pay_payment_method_options_bank_v2(s) {
    "{" +     "allowed_countries: " + cql_list_text(hash2(s, 0)) + "}"
}
fn cql_pay_payment_methods_options_limits(s) {
    "{" +     "card: " + cql_pay_card_method_options_limits(hash2(s, 0)) + ", " +     "us_bank_account: " + cql_pay_us_bank_account_method_options_limits(hash2(s, 1)) + "}"
}
fn cql_pay_payment_method_options_collection_googlepay_v2(s) {
    "{" +
    "billing_address: " + cql_pay_payment_method_options_collection_item_v2(hash2(s, 0)) + ", " +
    "email: " + cql_pay_payment_method_options_collection_item_v2(hash2(s, 1)) + ", " +
    "name: " + cql_pay_payment_method_options_collection_item_v2(hash2(s, 2)) + ", " +
    "phone_number: " + cql_pay_payment_method_options_collection_item_v2(hash2(s, 3)) + ", " +
    "shipping_address: " + cql_pay_payment_method_options_googlepay_shipping_address_v2(hash2(s, 4)) +
    "}"
}
fn cql_pay_eu_business_structure_details(s) {
    "{" +
    "business_structure: " + cql_text(hash2(s, 0)) + ", " +
    "business_registered_country: " + cql_text(hash2(s, 1)) + ", " +
    "registered_business_address: " + cql_pay_eu_address_v2(hash2(s, 2)) + ", " +
    "business_phone_number: " + cql_text(hash2(s, 3)) + ", " +
    "number_of_employees: " + cql_text(hash2(s, 4)) + ", " +
    "date_of_incorporation: " + cql_text(hash2(s, 5)) + ", " +
    "physical_business_address: " + cql_pay_eu_address_v2(hash2(s, 6)) + ", " +
    "companies_group: " + cql_bool(hash2(s, 7)) + ", " +
    "group_name: " + cql_text(hash2(s, 8)) + ", " +
    "group_website: " + cql_text(hash2(s, 9)) + ", " +
    "public_company: " + cql_bool(hash2(s, 10)) + ", " +
    "bankruptcy_proceedings: " + cql_bool(hash2(s, 11)) + ", " +
    "business_email: " + cql_text(hash2(s, 12)) + ", " +
    "business_conduction_location: " + cql_text(hash2(s, 13)) +
    "}"
}
fn cql_pay_eu_customer_support(s) {
    "{" +
    "statement_descriptor: " + cql_text(hash2(s, 0)) + ", " +
    "phone: " + cql_text(hash2(s, 1)) + ", " +
    "email: " + cql_text(hash2(s, 2)) + ", " +
    "address: " + cql_pay_eu_address_v2(hash2(s, 3)) +
    "}"
}
fn cql_pay_advanced_fraud_screening_payment_method_options(s) {
    "{" +     "enabled: " + cql_bool(hash2(s, 0)) + ", " +     "learn_mode: " + cql_bool(hash2(s, 1)) + ", " +     "thresholds: " + "[" + cql_pay_risk_control_payment_method_options(hash2(s, 2)) + "]" + "}"
}
fn cql_pay_eu_risk(s) {
    "{" +
    "aml_risk: " + cql_pay_eu_aml_risk(hash2(s, 0)) + ", " +
    "exposure_risk: " + cql_pay_eu_exposure_risk(hash2(s, 1)) + ", " +
    "processing_risk_score: " + cql_text(hash2(s, 2)) + ", " +
    "is_overridden: " + cql_bool(hash2(s, 3)) + ", " +
    "renewal_date: " + cql_text(hash2(s, 4)) + ", " +
    "renewal_date_reason: " + cql_text(hash2(s, 5)) +
    "}"
}
fn cql_pay_eu_provider_method_infinicept(s) {
    "{" +
    "acceptable_use: " + cql_pay_eu_infinicept_category(hash2(s, 0)) + ", " +
    "credit: " + cql_pay_eu_infinicept_category(hash2(s, 1)) + ", " +
    "fraud: " + cql_pay_eu_infinicept_category(hash2(s, 2)) + ", " +
    "kyc_business: " + cql_pay_eu_infinicept_category(hash2(s, 3)) + ", " +
    "kyc_personal: " + cql_pay_eu_infinicept_category(hash2(s, 4)) + ", " +
    "social: " + cql_pay_eu_infinicept_category(hash2(s, 5)) +
    "}"
}
fn cql_pay_report_config(s) {
    "{" +     "email: " + cql_pay_report_config_email(hash2(s, 0)) + ", " +     "s3: " + cql_pay_report_config_s3(hash2(s, 1)) + ", " +     "sftp: " + cql_pay_report_config_sftp(hash2(s, 2)) + "}"
}
fn cql_pay_decline_recovery_settings(s) {
    "{" +     "flex_factor: " + cql_pay_decline_recovery_setting(hash2(s, 0)) + "}"
}
fn cql_pay_eu_onboarding_document(s) {
    "{" +
    "id: " + cql_text(hash2(s, 0)) + ", " +
    "name: " + cql_text(hash2(s, 1)) + ", " +
    "category: " + cql_text(hash2(s, 2)) + ", " +
    "type: " + cql_text(hash2(s, 3)) + ", " +
    "uploaded_on: " + cql_text(hash2(s, 4)) + ", " +
    "uploaded_by: " + cql_text(hash2(s, 5)) + ", " +
    "archive_status: " + cql_text(hash2(s, 6)) + ", " +
    "notes: " + "[" + cql_pay_eu_note(hash2(s, 7)) + "]" + ", " +
    "expiry_date: " + cql_text(hash2(s, 8)) + ", " +
    "issuing_date: " + cql_text(hash2(s, 9)) + ", " +
    "status: " + cql_text(hash2(s, 10)) +
    "}"
}
fn cql_pay_branding(s) {
    "{" +
    "display_name: " + cql_text(hash2(s, 0)) + ", " +
    "logo: " + cql_text(hash2(s, 1)) + ", " +
    "color: " + cql_text(hash2(s, 2)) + ", " +
    "fallback_url: " + cql_text(hash2(s, 3)) + ", " +
    "cta_text: " + cql_text(hash2(s, 4)) + ", " +
    "customer_support: " + cql_pay_customer_support(hash2(s, 5)) +
    "}"
}
fn cql_pay_custom_fields(s) {
    "{" +
    "dropdown: " + cql_pay_custom_fields_dropdown(hash2(s, 0)) + ", " +
    "key: " + cql_text(hash2(s, 1)) + ", " +
    "label: " + cql_pay_custom_fields_label(hash2(s, 2)) + ", " +
    "optional: " + cql_bool(hash2(s, 3)) + ", " +
    "type: " + cql_text(hash2(s, 4)) + ", " +
    "regex: " + cql_text(hash2(s, 5)) +
    "}"
}
fn cql_pay_card_method_options_partial_approval_v2(s) {
    "{" +
    "accept: " + cql_bool(hash2(s, 0)) + ", " +
    "allow_top_up: " + cql_bool(hash2(s, 1)) + ", " +
    "percentage_threshold: " + cql_int(hash2(s, 2)) + ", " +
    "amount_threshold: " + cql_text(hash2(s, 3)) + ", " +
    "require_full_amount: " + cql_bool(hash2(s, 4)) + ", " +
    "approved_by_default: " + cql_bool(hash2(s, 5)) + ", " +
    "products: " + "[" + cql_pay_partial_approval_products(hash2(s, 6)) + "]" +
    "}"
}
fn cql_pay_tiering_object(s) {
    "{" +     "strategy_id: " + cql_text(hash2(s, 0)) + ", " +     "tiers: " + "[" + cql_pay_tier_object(hash2(s, 1)) + "]" + "}"
}
fn cql_pay_task_field_value(s) {
    "{" +
    "string_value: " + cql_text(hash2(s, 0)) + ", " +
    "bool_value: " + cql_bool(hash2(s, 1)) + ", " +
    "list_value: " + "[" + cql_pay_task_list_value(hash2(s, 2)) + "]" + ", " +
    "json_value: " + cql_text(hash2(s, 3)) + ", " +
    "number_value: " + cql_int(hash2(s, 4)) +
    "}"
}
fn cql_pay_three_ds_flow_indicator_options(s) {
    "{" +     "type: " + cql_text(hash2(s, 0)) + ", " +     "challenge: " + cql_pay_three_ds_type_options(hash2(s, 1)) + ", " +     "frictionless: " + cql_pay_three_ds_type_options(hash2(s, 2)) + "}"
}
fn cql_pay_processing_fees_breakdown_by_card_type(s) {
    "{" +
    "debit: " + cql_pay_processing_fees_breakdown_by_card_product(hash2(s, 0)) + ", " +
    "credit: " + cql_pay_processing_fees_breakdown_by_card_product(hash2(s, 1)) + ", " +
    "prepaid: " + cql_pay_processing_fees_breakdown_by_card_product(hash2(s, 2)) + ", " +
    "unknown: " + cql_pay_processing_fees_breakdown_by_card_product(hash2(s, 3)) +
    "}"
}
fn cql_pay_verification_options(s) {
    "{" +     "enabled: " + cql_bool(hash2(s, 0)) + ", " +     "accepted_verification_level_values: " + cql_list_text(hash2(s, 1)) + ", " +     "require_match_for_customer_details: " + cql_pay_customer_details_match_options(hash2(s, 2)) + "}"
}
fn cql_pay_after_completion(s) {
    "{" +     "hosted_confirmation: " + cql_pay_after_completion_hosted_confirmation(hash2(s, 0)) + ", " +     "redirect: " + cql_pay_after_completion_redirect(hash2(s, 1)) + ", " +     "type: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_card_method_options_network_token_v2(s) {
    "{" +     "provision: " + cql_pay_card_method_options_network_token_provision_v2(hash2(s, 0)) + ", " +     "authorization: " + cql_pay_card_method_options_network_token_authorization_v2(hash2(s, 1)) + "}"
}
fn cql_pay_payment_method_options_googleplay_v2(s) {
    "{" +     "collection: " + cql_pay_payment_method_options_collection_googlepay_v2(hash2(s, 0)) + ", " +     "require_cryptogram_threed_secure: " + cql_bool(hash2(s, 1)) + "}"
}
fn cql_pay_eu_onboarding_business_activity(s) {
    "{" +
    "reason: " + cql_text(hash2(s, 0)) + ", " +
    "product_description: " + cql_text(hash2(s, 1)) + ", " +
    "physical_products_origins: " + cql_list_text(hash2(s, 2)) + ", " +
    "origins_of_funds: " + cql_list_text(hash2(s, 3)) + ", " +
    "customers_abroad_countries: " + cql_list_text(hash2(s, 4)) + ", " +
    "high_risk_countries: " + cql_list_text(hash2(s, 5)) + ", " +
    "requires_authorization_from_authority: " + cql_bool(hash2(s, 6)) + ", " +
    "payment_channels: " + cql_list_text(hash2(s, 7)) + ", " +
    "product_supply_time_range: " + cql_text(hash2(s, 8)) + ", " +
    "subscription_based_service: " + cql_bool(hash2(s, 9)) + ", " +
    "moto_options: " + cql_bool(hash2(s, 10)) + ", " +
    "yearly_volume_currency: " + cql_text(hash2(s, 11)) + ", " +
    "yearly_volume: " + cql_text(hash2(s, 12)) + ", " +
    "minimum_transaction_currency: " + cql_text(hash2(s, 13)) + ", " +
    "minimum_transaction_amount: " + cql_text(hash2(s, 14)) + ", " +
    "average_transaction_currency: " + cql_text(hash2(s, 15)) + ", " +
    "average_transaction_amount: " + cql_text(hash2(s, 16)) + ", " +
    "maximum_transaction_currency: " + cql_text(hash2(s, 17)) + ", " +
    "maximum_transaction_amount: " + cql_text(hash2(s, 18)) + ", " +
    "sources_of_funds: " + cql_list_text(hash2(s, 19)) + ", " +
    "customers_abroad: " + cql_bool(hash2(s, 20)) + ", " +
    "product_company: " + cql_bool(hash2(s, 21)) + ", " +
    "license_jurisdiction_country: " + cql_text(hash2(s, 22)) + ", " +
    "license_type: " + cql_text(hash2(s, 23)) + ", " +
    "projected_card_volume: " + cql_text(hash2(s, 24)) + ", " +
    "projected_card_volume_currency: " + cql_text(hash2(s, 25)) + ", " +
    "projected_card_turnover: " + cql_text(hash2(s, 26)) + ", " +
    "requires_authorization_from_authority_description: " + cql_text(hash2(s, 27)) + ", " +
    "monthly_card_volume_amount: " + cql_text(hash2(s, 28)) + ", " +
    "monthly_card_volume_currency: " + cql_text(hash2(s, 29)) + ", " +
    "monthly_average_volume_amount: " + cql_text(hash2(s, 30)) + ", " +
    "monthly_average_volume_currency: " + cql_text(hash2(s, 31)) + ", " +
    "volume_share_countries: " + "[" + cql_pay_eu_country_volume_share(hash2(s, 32)) + "]" + ", " +
    "processing_currencies: " + cql_list_text(hash2(s, 33)) + ", " +
    "settlement_currencies: " + cql_list_text(hash2(s, 34)) + ", " +
    "blacklisted_countries: " + cql_list_text(hash2(s, 35)) + ", " +
    "current_payment_processor: " + cql_text(hash2(s, 36)) + ", " +
    "applying_reason: " + cql_text(hash2(s, 37)) + ", " +
    "special_products: " + cql_list_text(hash2(s, 38)) + ", " +
    "special_products_description: " + cql_text(hash2(s, 39)) +
    "}"
}
fn cql_pay_custom_fields_v2(s) {
    "{" +
    "id: " + cql_text(hash2(s, 0)) + ", " +
    "placeholder: " + cql_text(hash2(s, 1)) + ", " +
    "label: " + cql_text(hash2(s, 2)) + ", " +
    "type: " + cql_text(hash2(s, 3)) + ", " +
    "input_type: " + cql_text(hash2(s, 4)) + ", " +
    "options: " + "[" + cql_pay_custom_fields_options(hash2(s, 5)) + "]" + ", " +
    "description: " + cql_text(hash2(s, 6)) + ", " +
    "validation: " + cql_pay_custom_fields_validation(hash2(s, 7)) +
    "}"
}
fn cql_pay_us_onboarding_document(s) {
    "{" +
    "id: " + cql_text(hash2(s, 0)) + ", " +
    "name: " + cql_text(hash2(s, 1)) + ", " +
    "category: " + cql_text(hash2(s, 2)) + ", " +
    "type: " + cql_text(hash2(s, 3)) + ", " +
    "uploaded_on: " + cql_text(hash2(s, 4)) + ", " +
    "uploaded_by: " + cql_text(hash2(s, 5)) + ", " +
    "archive_status: " + cql_text(hash2(s, 6)) + ", " +
    "notes: " + "[" + cql_pay_us_note(hash2(s, 7)) + "]" + ", " +
    "expiry_date: " + cql_text(hash2(s, 8)) + ", " +
    "issuing_date: " + cql_text(hash2(s, 9)) + ", " +
    "status: " + cql_text(hash2(s, 10)) +
    "}"
}
fn cql_pay_payment_method_options_applepay_v2(s) {
    "{" +     "collection: " + cql_pay_payment_method_options_collection_applepay_v2(hash2(s, 0)) + "}"
}
fn cql_pay_eu_verification_check(s) {
    "{" +
    "check_stage: " + cql_text(hash2(s, 0)) + ", " +
    "check_type: " + cql_text(hash2(s, 1)) + ", " +
    "provider_name: " + cql_text(hash2(s, 2)) + ", " +
    "status: " + cql_text(hash2(s, 3)) + ", " +
    "check_sub_types: " + "[" + cql_pay_eu_check_sub_type(hash2(s, 4)) + "]" + ", " +
    "comments: " + "[" + cql_pay_eu_verification_comment(hash2(s, 5)) + "]" + ", " +
    "manual: " + cql_bool(hash2(s, 6)) + ", " +
    "check_date: " + cql_text(hash2(s, 7)) + ", " +
    "updated_by: " + cql_text(hash2(s, 8)) + ", " +
    "added_by: " + cql_text(hash2(s, 9)) + ", " +
    "updated_at: " + cql_text(hash2(s, 10)) +
    "}"
}
fn cql_pay_payment_method_options(s) {
    "{" +
    "card: " + cql_pay_card_method_options(hash2(s, 0)) + ", " +
    "us_bank_account: " + cql_pay_us_bank_account_method_options(hash2(s, 1)) + ", " +
    "types: " + cql_list_text(hash2(s, 2)) + ", " +
    "paypal: " + cql_pay_paypal_method_options(hash2(s, 3)) +
    "}"
}
fn cql_pay_us_entity_settlement_terms(s) {
    "{" +
    "rolling_reserve_type: " + cql_text(hash2(s, 0)) + ", " +
    "rolling_reserve_duration: " + cql_int(hash2(s, 1)) + ", " +
    "rolling_reserve_amount: " + cql_text(hash2(s, 2)) + ", " +
    "maximum_held_reserve: " + cql_text(hash2(s, 3)) + ", " +
    "schedule_config: " + cql_pay_us_onboarding_schedule_config_settlement(hash2(s, 4)) + ", " +
    "funding_delay: " + cql_int(hash2(s, 5)) + ", " +
    "security_deposit_amount: " + cql_text(hash2(s, 6)) + ", " +
    "currency: " + cql_text(hash2(s, 7)) +
    "}"
}
fn cql_pay_pricing_action_object(s) {
    "{" +
    "basis_points: " + cql_text(hash2(s, 0)) + ", " +
    "fixed_fee: " + cql_text(hash2(s, 1)) + ", " +
    "basis_fee_description: " + cql_text(hash2(s, 2)) + ", " +
    "fixed_fee_description: " + cql_text(hash2(s, 3)) + ", " +
    "gross_fixed: " + cql_bool(hash2(s, 4)) + ", " +
    "gross_basis_points: " + cql_bool(hash2(s, 5)) + ", " +
    "tiering: " + cql_pay_tiering_object(hash2(s, 6)) + ", " +
    "apply_as_application_fee: " + cql_bool(hash2(s, 7)) + ", " +
    "apply_as_network_fee: " + cql_bool(hash2(s, 8)) + ", " +
    "precision: " + cql_int(hash2(s, 9)) + ", " +
    "alias: " + cql_text(hash2(s, 10)) + ", " +
    "cost_provider: " + cql_text(hash2(s, 11)) + ", " +
    "once_per_payment_attempt: " + cql_bool(hash2(s, 12)) +
    "}"
}
fn cql_pay_us_onboarding_business_details(s) {
    "{" +
    "legal_business_name: " + cql_text(hash2(s, 0)) + ", " +
    "doing_business_as: " + cql_text(hash2(s, 1)) + ", " +
    "employer_id_number: " + cql_text(hash2(s, 2)) + ", " +
    "company_registration_number: " + cql_text(hash2(s, 3)) + ", " +
    "industry: " + cql_text(hash2(s, 4)) + ", " +
    "website: " + cql_text(hash2(s, 5)) + ", " +
    "product_description: " + cql_text(hash2(s, 6)) + ", " +
    "monthly_processing_volume: " + cql_text(hash2(s, 7)) + ", " +
    "vat_number: " + cql_text(hash2(s, 8)) + ", " +
    "issuing_authority: " + cql_text(hash2(s, 9)) + ", " +
    "no_website: " + cql_bool(hash2(s, 10)) + ", " +
    "social_media: " + "[" + cql_pay_us_social_media(hash2(s, 11)) + "]" + ", " +
    "website_under_construction: " + cql_bool(hash2(s, 12)) + ", " +
    "no_online_presence: " + cql_bool(hash2(s, 13)) + ", " +
    "implementation: " + cql_pay_us_implementation(hash2(s, 14)) + ", " +
    "monthly_processing_volume_currency: " + cql_text(hash2(s, 15)) + ", " +
    "business_license_number: " + cql_text(hash2(s, 16)) + ", " +
    "industry_description: " + cql_text(hash2(s, 17)) + ", " +
    "special_products: " + cql_set_text(hash2(s, 18)) + ", " +
    "special_products_description: " + cql_text(hash2(s, 19)) + ", " +
    "no_vat_number: " + cql_bool(hash2(s, 20)) +
    "}"
}
fn cql_pay_finalize(s) {
    "{" +
    "issuer_response_code: " + cql_int(hash2(s, 0)) + ", " +
    "issuer_response_text: " + cql_text(hash2(s, 1)) + ", " +
    "result_source: " + cql_text(hash2(s, 2)) + ", " +
    "auth_code: " + cql_text(hash2(s, 3)) + ", " +
    "transaction_rrn: " + cql_text(hash2(s, 4)) + ", " +
    "transaction_result: " + cql_text(hash2(s, 5)) + ", " +
    "transaction_timestamp: " + cql_text(hash2(s, 6)) + ", " +
    "network_code: " + cql_text(hash2(s, 7)) + ", " +
    "system_trace_audit_number: " + cql_text(hash2(s, 8)) + ", " +
    "eci: " + cql_text(hash2(s, 9)) + ", " +
    "network_specific_fields: " + cql_pay_network_specific_fields(hash2(s, 10)) + ", " +
    "issuer_response_code_string: " + cql_text(hash2(s, 11)) + ", " +
    "rrn: " + cql_text(hash2(s, 12)) + ", " +
    "funding: " + cql_bool(hash2(s, 13)) + ", " +
    "ani_verification_details: " + cql_pay_ani_verification_details(hash2(s, 14)) + ", " +
    "partial_approval: " + cql_pay_partial_approval_finalize(hash2(s, 15)) + ", " +
    "payout_type: " + cql_text(hash2(s, 16)) + ", " +
    "funding_type: " + cql_text(hash2(s, 17)) +
    "}"
}
fn cql_pay_common_settings_dispute(s) {
    "{" +     "created: " + cql_pay_common_settings_subscription_status(hash2(s, 0)) + ", " +     "lost: " + cql_pay_common_settings_subscription_status(hash2(s, 1)) + "}"
}
fn cql_pay_apm_verification_options(s) {
    "{" +     "enabled: " + cql_bool(hash2(s, 0)) + ", " +     "accepted_verification_level_values: " + cql_list_text(hash2(s, 1)) + ", " +     "require_match_for_customer_details: " + cql_pay_customer_details_match_options(hash2(s, 2)) + "}"
}
fn cql_pay_payout_skrill_neteller_method_options(s) {
    "{" +     "verification: " + cql_pay_apm_verification_options(hash2(s, 0)) + ", " +     "email_subject: " + cql_text(hash2(s, 1)) + ", " +     "email_message: " + cql_text(hash2(s, 2)) + "}"
}
fn cql_pay_us_onboarding_business_activity(s) {
    "{" +
    "reason: " + cql_text(hash2(s, 0)) + ", " +
    "product_description: " + cql_text(hash2(s, 1)) + ", " +
    "physical_products_origins: " + cql_list_text(hash2(s, 2)) + ", " +
    "origins_of_funds: " + cql_list_text(hash2(s, 3)) + ", " +
    "customers_abroad_countries: " + cql_list_text(hash2(s, 4)) + ", " +
    "high_risk_countries: " + cql_list_text(hash2(s, 5)) + ", " +
    "requires_authorization_from_authority: " + cql_bool(hash2(s, 6)) + ", " +
    "payment_channels: " + cql_list_text(hash2(s, 7)) + ", " +
    "product_supply_time_range: " + cql_text(hash2(s, 8)) + ", " +
    "subscription_based_service: " + cql_bool(hash2(s, 9)) + ", " +
    "moto_options: " + cql_bool(hash2(s, 10)) + ", " +
    "yearly_volume_currency: " + cql_text(hash2(s, 11)) + ", " +
    "yearly_volume: " + cql_text(hash2(s, 12)) + ", " +
    "minimum_transaction_currency: " + cql_text(hash2(s, 13)) + ", " +
    "minimum_transaction_amount: " + cql_text(hash2(s, 14)) + ", " +
    "average_transaction_currency: " + cql_text(hash2(s, 15)) + ", " +
    "average_transaction_amount: " + cql_text(hash2(s, 16)) + ", " +
    "maximum_transaction_currency: " + cql_text(hash2(s, 17)) + ", " +
    "maximum_transaction_amount: " + cql_text(hash2(s, 18)) + ", " +
    "sources_of_funds: " + cql_list_text(hash2(s, 19)) + ", " +
    "customers_abroad: " + cql_bool(hash2(s, 20)) + ", " +
    "product_company: " + cql_bool(hash2(s, 21)) + ", " +
    "license_jurisdiction_country: " + cql_text(hash2(s, 22)) + ", " +
    "license_type: " + cql_text(hash2(s, 23)) + ", " +
    "projected_card_volume: " + cql_text(hash2(s, 24)) + ", " +
    "projected_card_volume_currency: " + cql_text(hash2(s, 25)) + ", " +
    "projected_card_turnover: " + cql_text(hash2(s, 26)) + ", " +
    "requires_authorization_from_authority_description: " + cql_text(hash2(s, 27)) + ", " +
    "monthly_card_volume_amount: " + cql_text(hash2(s, 28)) + ", " +
    "monthly_card_volume_currency: " + cql_text(hash2(s, 29)) + ", " +
    "monthly_average_volume_amount: " + cql_text(hash2(s, 30)) + ", " +
    "monthly_average_volume_currency: " + cql_text(hash2(s, 31)) + ", " +
    "volume_share_countries: " + "[" + cql_pay_us_country_volume_share(hash2(s, 32)) + "]" + ", " +
    "processing_currencies: " + cql_list_text(hash2(s, 33)) + ", " +
    "settlement_currencies: " + cql_list_text(hash2(s, 34)) + ", " +
    "blacklisted_countries: " + cql_list_text(hash2(s, 35)) + ", " +
    "current_payment_processor: " + cql_text(hash2(s, 36)) + ", " +
    "applying_reason: " + cql_text(hash2(s, 37)) + ", " +
    "special_products: " + cql_list_text(hash2(s, 38)) + ", " +
    "special_products_description: " + cql_text(hash2(s, 39)) +
    "}"
}
fn cql_pay_eu_onboarding_business_details(s) {
    "{" +
    "legal_business_name: " + cql_text(hash2(s, 0)) + ", " +
    "doing_business_as: " + cql_text(hash2(s, 1)) + ", " +
    "employer_id_number: " + cql_text(hash2(s, 2)) + ", " +
    "company_registration_number: " + cql_text(hash2(s, 3)) + ", " +
    "industry: " + cql_text(hash2(s, 4)) + ", " +
    "website: " + cql_text(hash2(s, 5)) + ", " +
    "product_description: " + cql_text(hash2(s, 6)) + ", " +
    "monthly_processing_volume: " + cql_text(hash2(s, 7)) + ", " +
    "vat_number: " + cql_text(hash2(s, 8)) + ", " +
    "issuing_authority: " + cql_text(hash2(s, 9)) + ", " +
    "no_website: " + cql_bool(hash2(s, 10)) + ", " +
    "social_media: " + "[" + cql_pay_eu_social_media(hash2(s, 11)) + "]" + ", " +
    "website_under_construction: " + cql_bool(hash2(s, 12)) + ", " +
    "no_online_presence: " + cql_bool(hash2(s, 13)) + ", " +
    "implementation: " + cql_pay_eu_implementation(hash2(s, 14)) + ", " +
    "monthly_processing_volume_currency: " + cql_text(hash2(s, 15)) + ", " +
    "business_license_number: " + cql_text(hash2(s, 16)) + ", " +
    "industry_description: " + cql_text(hash2(s, 17)) + ", " +
    "special_products: " + cql_set_text(hash2(s, 18)) + ", " +
    "special_products_description: " + cql_text(hash2(s, 19)) + ", " +
    "no_vat_number: " + cql_bool(hash2(s, 20)) +
    "}"
}
fn cql_pay_eu_entity_settlement_terms(s) {
    "{" +
    "rolling_reserve_type: " + cql_text(hash2(s, 0)) + ", " +
    "rolling_reserve_duration: " + cql_int(hash2(s, 1)) + ", " +
    "rolling_reserve_amount: " + cql_text(hash2(s, 2)) + ", " +
    "maximum_held_reserve: " + cql_text(hash2(s, 3)) + ", " +
    "schedule_config: " + cql_pay_eu_onboarding_schedule_config_settlement(hash2(s, 4)) + ", " +
    "funding_delay: " + cql_int(hash2(s, 5)) + ", " +
    "security_deposit_amount: " + cql_text(hash2(s, 6)) + ", " +
    "currency: " + cql_text(hash2(s, 7)) +
    "}"
}
fn cql_pay_eu_provider_data(s) {
    "{" +
    "provider: " + cql_text(hash2(s, 0)) + ", " +
    "provider_errors: " + cql_pay_eu_onboarding_provider_errors(hash2(s, 1)) + ", " +
    "provider_ma_id: " + cql_text(hash2(s, 2)) + ", " +
    "provider_status: " + cql_text(hash2(s, 3)) + ", " +
    "provider_merchant_id: " + cql_text(hash2(s, 4)) + ", " +
    "underwriting_results_url: " + cql_text(hash2(s, 5)) + ", " +
    "infinicept: " + cql_pay_eu_provider_method_infinicept(hash2(s, 6)) + ", " +
    "last_updated: " + cql_text(hash2(s, 7)) +
    "}"
}
fn cql_pay_us_onboarding_bank_details(s) {
    "{" +
    "routing_number: " + cql_text(hash2(s, 0)) + ", " +
    "account_number: " + cql_text(hash2(s, 1)) + ", " +
    "iban: " + cql_text(hash2(s, 2)) + ", " +
    "account_holder_name: " + cql_text(hash2(s, 3)) + ", " +
    "dda_type: " + cql_text(hash2(s, 4)) + ", " +
    "settlement_details: " + "[" + cql_pay_us_onboarding_settlement_details(hash2(s, 5)) + "]" +
    "}"
}
fn cql_pay_custom_text(s) {
    "{" +     "shipping_address: " + cql_pay_custom_text_shipping_address(hash2(s, 0)) + ", " +     "submit: " + cql_pay_custom_text_submit(hash2(s, 1)) + "}"
}
fn cql_pay_task_template_action(s) {
    "{" +
    "signal: " + cql_text(hash2(s, 0)) + ", " +
    "style: " + cql_text(hash2(s, 1)) + ", " +
    "label: " + cql_text(hash2(s, 2)) + ", " +
    "validation_configs: " + "[" + cql_pay_validation_config(hash2(s, 3)) + "]" +
    "}"
}
fn cql_pay_eu_onboarding_settlement_details(s) {
    "{" +
    "settlement_currency: " + cql_text(hash2(s, 0)) + ", " +
    "bank_name: " + cql_text(hash2(s, 1)) + ", " +
    "bank_country: " + cql_text(hash2(s, 2)) + ", " +
    "beneficiary_name: " + cql_text(hash2(s, 3)) + ", " +
    "iban: " + cql_text(hash2(s, 4)) + ", " +
    "swift: " + cql_text(hash2(s, 5)) + ", " +
    "beneficiary_address: " + cql_pay_eu_address_v2(hash2(s, 6)) + ", " +
    "id: " + cql_text(hash2(s, 7)) + ", " +
    "paired_currencies: " + cql_list_text(hash2(s, 8)) +
    "}"
}
fn cql_pay_recurring_options(s) {
    "{" +
    "amount: " + cql_int(hash2(s, 0)) + ", " +
    "interval: " + cql_text(hash2(s, 1)) + ", " +
    "interval_count: " + cql_int(hash2(s, 2)) + ", " +
    "expiry: " + cql_pay_expiry_options(hash2(s, 3)) +
    "}"
}
fn cql_pay_three_ds_options(s) {
    "{" +     "accepted_eci_values: " + cql_list_text(hash2(s, 0)) + ", " +     "flow_indicator: " + cql_pay_three_ds_flow_indicator_options(hash2(s, 1)) + "}"
}
fn cql_pay_payment_method(s) {
    "{" +
    "type: " + cql_text(hash2(s, 0)) + ", " +
    "id: " + cql_text(hash2(s, 1)) + ", " +
    "unique_identifier: " + cql_text(hash2(s, 2)) + ", " +
    "card: " + cql_pay_payment_method_card(hash2(s, 3)) + ", " +
    "paypal: " + cql_pay_payment_method_paypal(hash2(s, 4)) + ", " +
    "paypal_billing_agreement: " + cql_pay_payment_method_paypal_billing_agreement(hash2(s, 5)) + ", " +
    "paysafecard: " + cql_pay_payment_method_paysafecard(hash2(s, 6)) + ", " +
    "neteller: " + cql_pay_payment_method_neteller(hash2(s, 7)) + ", " +
    "paysafecash: " + cql_pay_payment_method_paysafecash(hash2(s, 8)) + ", " +
    "zimpler: " + cql_pay_payment_method_zimpler(hash2(s, 9)) + ", " +
    "skrill: " + cql_pay_payment_method_skrill(hash2(s, 10)) + ", " +
    "us_bank_account: " + cql_pay_payment_method_bank_account(hash2(s, 11)) + ", " +
    "applepay: " + cql_pay_payment_method_card(hash2(s, 12)) + ", " +
    "googlpay: " + cql_pay_payment_method_card(hash2(s, 13)) + ", " +
    "googlepay: " + cql_pay_payment_method_card(hash2(s, 14)) + ", " +
    "in_bank_account: " + cql_pay_payment_method_bank_account(hash2(s, 15)) + ", " +
    "upi: " + cql_pay_payment_method_upi(hash2(s, 16)) + ", " +
    "netbanking: " + cql_pay_payment_method_netbanking(hash2(s, 17)) + ", " +
    "generic: " + cql_pay_payment_method_generic(hash2(s, 18)) + ", " +
    "reference: " + cql_text(hash2(s, 19)) + ", " +
    "bank_account: " + cql_pay_payment_method_bank_account(hash2(s, 20)) +
    "}"
}
fn cql_pay_installment_options(s) {
    "{" +
    "number: " + cql_int(hash2(s, 0)) + ", " +
    "amount: " + cql_int(hash2(s, 1)) + ", " +
    "interval: " + cql_text(hash2(s, 2)) + ", " +
    "interval_count: " + cql_int(hash2(s, 3)) + ", " +
    "expiry: " + cql_pay_expiry_options(hash2(s, 4)) +
    "}"
}
fn cql_pay_processor_transaction_type_config(s) {
    "{" +
    "default_processor: " + cql_text(hash2(s, 0)) + ", " +
    "default_processor_map: " + cql_map_tt(hash2(s, 1)) + ", " +
    "default3_ds_processor: " + cql_text(hash2(s, 2)) + ", " +
    "currency: " + "{'" + cql_text_raw(hash2(s, 3)) + "': " + cql_pay_processor_config(hash2(hash2(s, 3), 99)) + "}" + ", " +
    "retry_providers: " + cql_list_text(hash2(s, 4)) +
    "}"
}
fn cql_pay_task_value(s) {
    "{" +     "key: " + cql_text(hash2(s, 0)) + ", " +     "value: " + cql_pay_task_field_value(hash2(s, 1)) + "}"
}
fn cql_pay_pricing_alternative_payment_methods(s) {
    "{" +     "actions: " + "{'" + cql_text_raw(hash2(s, 0)) + "': " + cql_pay_pricing_action_object(hash2(hash2(s, 0), 99)) + "}" + ", " +     "blended: " + cql_bool(hash2(s, 1)) + "}"
}
fn cql_pay_processing_fees_breakdown_by_jurisdiction(s) {
    "{" +     "domestic: " + cql_pay_processing_fees_breakdown_by_card_type(hash2(s, 0)) + ", " +     "international: " + cql_pay_processing_fees_breakdown_by_card_type(hash2(s, 1)) + ", " +     "intraregional: " + cql_pay_processing_fees_breakdown_by_card_type(hash2(s, 2)) + "}"
}
fn cql_pay_skrill_neteller_payment_method_options(s) {
    "{" +     "verification: " + cql_pay_verification_options(hash2(s, 0)) + "}"
}
fn cql_pay_future_usage_options(s) {
    "{" +     "type: " + cql_text(hash2(s, 0)) + ", " +     "installment: " + cql_pay_installment_options(hash2(s, 1)) + ", " +     "recurring: " + cql_pay_recurring_options(hash2(s, 2)) + "}"
}
fn cql_pay_card_method_options_v2(s) {
    "{" +
    "accepted_card_brands: " + cql_list_text(hash2(s, 0)) + ", " +
    "accepted_card_funding: " + cql_list_text(hash2(s, 1)) + ", " +
    "accepted_card_jurisdictions: " + cql_list_text(hash2(s, 2)) + ", " +
    "accepted_card_categories: " + cql_list_text(hash2(s, 3)) + ", " +
    "enforce_customer_name_as_cardholder_name: " + cql_bool(hash2(s, 4)) + ", " +
    "request_threed_secure: " + cql_text(hash2(s, 5)) + ", " +
    "security_checks: " + cql_pay_card_method_options_security_checks_v2(hash2(s, 6)) + ", " +
    "duplicate_card_check: " + cql_bool(hash2(s, 7)) + ", " +
    "accepted_card_countries: " + cql_list_text(hash2(s, 8)) + ", " +
    "moto: " + cql_bool(hash2(s, 9)) + ", " +
    "accepted_eci_values: " + cql_list_text(hash2(s, 10)) + ", " +
    "dynamic_currency_conversion: " + cql_bool(hash2(s, 11)) + ", " +
    "providers: " + cql_list_text(hash2(s, 12)) + ", " +
    "exemption_type: " + cql_text(hash2(s, 13)) + ", " +
    "partial_approval: " + cql_pay_card_method_options_partial_approval_v2(hash2(s, 14)) + ", " +
    "instant_refund: " + cql_bool(hash2(s, 15)) + ", " +
    "network_token: " + cql_pay_card_method_options_network_token_v2(hash2(s, 16)) + ", " +
    "funding: " + cql_bool(hash2(s, 17)) + ", " +
    "retry_providers: " + "[" + cql_pay_payment_method_options_providers(hash2(s, 18)) + "]" + ", " +
    "advanced_fraud_screening: " + cql_pay_advanced_fraud_screening_payment_method_options(hash2(s, 19)) + ", " +
    "accepted_ani_results: " + cql_list_text(hash2(s, 20)) + ", " +
    "accepted_ani_results_breakdown: " + cql_pay_accepted_ani_results_breakdown(hash2(s, 21)) + ", " +
    "request_ani: " + cql_bool(hash2(s, 22)) + ", " +
    "use_customer_name_ani: " + cql_bool(hash2(s, 23)) + ", " +
    "request_sca_exemption: " + cql_pay_request_sca_exemption(hash2(s, 24)) + ", " +
    "pinless_debit: " + cql_pay_pinless_debit_options(hash2(s, 25)) + ", " +
    "cvv_whitelist: " + cql_pay_cvv_whitelist(hash2(s, 26)) +
    "}"
}
fn cql_pay_subscriptions_common_settings(s) {
    "{" +
    "amount: " + cql_pay_common_settings_amount(hash2(s, 0)) + ", " +
    "currency: " + cql_text(hash2(s, 1)) + ", " +
    "retries: " + cql_pay_common_settings_retries(hash2(s, 2)) + ", " +
    "schedule: " + cql_pay_common_settings_interval(hash2(s, 3)) + ", " +
    "trial: " + cql_pay_common_settings_interval(hash2(s, 4)) + ", " +
    "cancel: " + cql_pay_common_settings_interval(hash2(s, 5)) + ", " +
    "failure: " + cql_text(hash2(s, 6)) + ", " +
    "pause: " + cql_text(hash2(s, 7)) + ", " +
    "dispute: " + cql_pay_common_settings_dispute(hash2(s, 8)) + ", " +
    "fraud_warning: " + cql_pay_common_settings_subscription_status(hash2(s, 9)) +
    "}"
}
fn cql_pay_eu_onboarding_bank_details(s) {
    "{" +
    "routing_number: " + cql_text(hash2(s, 0)) + ", " +
    "account_number: " + cql_text(hash2(s, 1)) + ", " +
    "iban: " + cql_text(hash2(s, 2)) + ", " +
    "account_holder_name: " + cql_text(hash2(s, 3)) + ", " +
    "dda_type: " + cql_text(hash2(s, 4)) + ", " +
    "settlement_details: " + "[" + cql_pay_eu_onboarding_settlement_details(hash2(s, 5)) + "]" +
    "}"
}
fn cql_pay_payout_method_options(s) {
    "{" +
    "skrill: " + cql_pay_payout_skrill_neteller_method_options(hash2(s, 0)) + ", " +
    "us_bank_account: " + cql_pay_payout_us_bank_account_options(hash2(s, 1)) + ", " +
    "prepaid_card: " + cql_pay_payout_prepaid_card_options(hash2(s, 2)) + ", " +
    "interac: " + cql_pay_payout_interac_options(hash2(s, 3)) +
    "}"
}
fn cql_pay_pricing_alternative_currencies_v2(s) {
    "{" +     "actions: " + "{'" + cql_text_raw(hash2(s, 0)) + "': " + cql_pay_pricing_action_object(hash2(hash2(s, 0), 99)) + "}" + ", " +     "alternative_payment_methods: " + "{'" + cql_text_raw(hash2(s, 1)) + "': " + cql_pay_pricing_alternative_payment_methods(hash2(hash2(s, 1), 99)) + "}" + ", " +     "settlement_fees: " + "{'" + cql_text_raw(hash2(s, 2)) + "': " + cql_pay_pricing_action_object(hash2(hash2(s, 2), 99)) + "}" + "}"
}
fn cql_pay_payment_control_hours(s) {
    "{" +
    "default_processor: " + cql_text(hash2(s, 0)) + ", " +
    "default_processor_map: " + cql_map_tt(hash2(s, 1)) + ", " +
    "default3_ds_processor: " + cql_text(hash2(s, 2)) + ", " +
    "currency: " + "{'" + cql_text_raw(hash2(s, 3)) + "': " + cql_pay_processor_config(hash2(hash2(s, 3), 99)) + "}" + ", " +
    "transaction_types: " + "{'" + cql_text_raw(hash2(s, 4)) + "': " + cql_pay_processor_transaction_type_config(hash2(hash2(s, 4), 99)) + "}" + ", " +
    "retry_providers: " + cql_list_text(hash2(s, 5)) +
    "}"
}
fn cql_pay_processing_fees_breakdown_by_scheme_detailed(s) {
    "{" +
    "visa: " + cql_pay_processing_fees_breakdown_by_jurisdiction(hash2(s, 0)) + ", " +
    "mastercard: " + cql_pay_processing_fees_breakdown_by_jurisdiction(hash2(s, 1)) + ", " +
    "amex: " + cql_pay_processing_fees_breakdown_by_jurisdiction(hash2(s, 2)) + ", " +
    "discover: " + cql_pay_processing_fees_breakdown_by_jurisdiction(hash2(s, 3)) +
    "}"
}
fn cql_pay_subscriptions_custom_settings(s) {
    "{" +
    "id: " + cql_text(hash2(s, 0)) + ", " +
    "reference: " + cql_text(hash2(s, 1)) + ", " +
    "description: " + cql_text(hash2(s, 2)) + ", " +
    "overwritten: " + cql_bool(hash2(s, 3)) + ", " +
    "settings: " + cql_pay_subscriptions_common_settings(hash2(s, 4)) +
    "}"
}
fn cql_pay_authentication_options(s) {
    "{" +
    "type: " + cql_text(hash2(s, 0)) + ", " +
    "three_ds: " + cql_pay_three_ds_options(hash2(s, 1)) + ", " +
    "three_ri: " + cql_pay_three_ri_options(hash2(s, 2)) + ", " +
    "setup_future_usage: " + cql_pay_future_usage_options(hash2(s, 3)) + ", " +
    "submit: " + cql_text(hash2(s, 4)) +
    "}"
}
fn cql_pay_payment_method_options_v2(s) {
    "{" +
    "card: " + cql_pay_card_method_options_v2(hash2(s, 0)) + ", " +
    "us_bank_account: " + cql_pay_us_bank_account_method_options_v2(hash2(s, 1)) + ", " +
    "types: " + cql_list_text(hash2(s, 2)) + ", " +
    "paypal: " + cql_pay_paypal_method_options_v2(hash2(s, 3)) + ", " +
    "googlepay: " + cql_pay_payment_method_options_googleplay_v2(hash2(s, 4)) + ", " +
    "applepay: " + cql_pay_payment_method_options_applepay_v2(hash2(s, 5)) + ", " +
    "bank_account: " + cql_pay_payment_method_options_bank_v2(hash2(s, 6)) + ", " +
    "disabled_payment_methods_types: " + cql_list_text(hash2(s, 7)) + ", " +
    "skrill: " + cql_pay_skrill_neteller_payment_method_options(hash2(s, 8)) + ", " +
    "neteller: " + cql_pay_skrill_neteller_payment_method_options(hash2(s, 9)) + ", " +
    "authentication_options: " + cql_pay_authentication_options(hash2(s, 10)) + ", " +
    "decline_recovery: " + cql_pay_decline_recovery_settings(hash2(s, 11)) + ", " +
    "payout_method_options: " + cql_pay_payout_method_options(hash2(s, 12)) +
    "}"
}
fn cql_pay_outcome_details(s) {
    "{" +
    "processor_config: " + cql_pay_processor_config(hash2(s, 0)) + ", " +
    "payment_methods_options: " + cql_pay_payment_method_options_v2(hash2(s, 1)) + ", " +
    "payment_method_config_id: " + cql_text(hash2(s, 2)) + ", " +
    "deprecated_fallback_config: " + cql_pay_fallback_config(hash2(s, 3)) + ", " +
    "fallback_config: " + "[" + cql_pay_fallback_config(hash2(s, 4)) + "]" +
    "}"
}
fn cql_pay_outcome_details_by_range(s) {
    "{" +     "outcome_details: " + cql_pay_outcome_details(hash2(s, 0)) + ", " +     "start: " + cql_int(hash2(s, 1)) + ", " +     "end: " + cql_int(hash2(s, 2)) + "}"
}

/// Per-table INSERT generators
fn gen_insert_pay_addresses(s) {
    "INSERT INTO pay.addresses (consumer_id, id, address, company_id, hash, merchant_id) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_pay_address_v2(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) +
    ")"
}
fn gen_insert_pay_apm_configurations(s) {
    "INSERT INTO pay.apm_configurations (payment_method_type, provider, call_gateway, call_initialize_on_stored_pm, color, fields, footer, grid_icon, grid_selected_background_color, header, icon, name, redirect, type) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_bool(hash2(s, 2)) + ", " +
    cql_bool(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    "[" + cql_pay_custom_fields_v2(hash2(s, 5)) + "]" + ", " +
    cql_pay_apm_frontend_content(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_pay_apm_frontend_content(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_bool(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) +
    ")"
}
fn gen_insert_pay_aps_credentials(s) {
    "INSERT INTO pay.aps_credentials (merchant_id, aps_credentials_by_currency, aps_payout_credentials_by_currency) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    "{'" + cql_text_raw(hash2(s, 1)) + "': " + cql_pay_aps_tokens(hash2(hash2(s, 1), 99)) + "}" + ", " +
    "{'" + cql_text_raw(hash2(s, 2)) + "': " + cql_pay_aps_tokens(hash2(hash2(s, 2), 99)) + "}" +
    ")"
}
fn gen_insert_pay_bank_accounts(s) {
    "INSERT INTO pay.bank_accounts (company_id, merchant_id, id, account_identifier, account_number, account_type, archived, bank, bank_country, bank_name, currency, iban, master, provider, region, routing_number, sort_code, swift_bic, type, virtual) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_bool(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_pay_master_account_details(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_text(hash2(s, 18)) + ", " +
    cql_bool(hash2(s, 19)) +
    ")"
}
fn gen_insert_pay_bank_transfers(s) {
    "INSERT INTO pay.bank_transfers (id, account_id, account_identifier, account_number, amount, bank, charge_bearer, company_id, counterparty_account_id, counterparty_account_identifier, counterparty_account_number, counterparty_bank, counterparty_company_id, counterparty_currency, counterparty_iban, counterparty_master, counterparty_merchant_id, counterparty_provider, counterparty_region, counterparty_routing_number, counterparty_sort_code, counterparty_swift_bic, counterparty_type, created_at, currency, direction, iban, master, merchant_id, operation, provider, rail, region, routing_number, sort_code, status, swift_bic, transfer_reference, transfer_type, type, updated_at, value_date) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_text(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_pay_master_account_details(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_text(hash2(s, 18)) + ", " +
    cql_text(hash2(s, 19)) + ", " +
    cql_text(hash2(s, 20)) + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_text(hash2(s, 22)) + ", " +
    cql_text(hash2(s, 23)) + ", " +
    cql_text(hash2(s, 24)) + ", " +
    cql_text(hash2(s, 25)) + ", " +
    cql_text(hash2(s, 26)) + ", " +
    cql_pay_master_account_details(hash2(s, 27)) + ", " +
    cql_text(hash2(s, 28)) + ", " +
    cql_text(hash2(s, 29)) + ", " +
    cql_text(hash2(s, 30)) + ", " +
    cql_text(hash2(s, 31)) + ", " +
    cql_text(hash2(s, 32)) + ", " +
    cql_text(hash2(s, 33)) + ", " +
    cql_text(hash2(s, 34)) + ", " +
    cql_text(hash2(s, 35)) + ", " +
    cql_text(hash2(s, 36)) + ", " +
    cql_text(hash2(s, 37)) + ", " +
    cql_text(hash2(s, 38)) + ", " +
    cql_text(hash2(s, 39)) + ", " +
    cql_text(hash2(s, 40)) + ", " +
    cql_text(hash2(s, 41)) +
    ")"
}
fn gen_insert_pay_banks(s) {
    "INSERT INTO pay.banks (currency, country, provider, provider_bank_id, bank_name, custom_fields, enabled, id, logo_url, priority, qr_code, requires_consent, show_qr, supported_types) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    "[" + cql_pay_custom_fields_v2(hash2(s, 5)) + "]" + ", " +
    cql_bool(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_int(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_bool(hash2(s, 11)) + ", " +
    cql_bool(hash2(s, 12)) + ", " +
    cql_list_text(hash2(s, 13)) +
    ")"
}
fn gen_insert_pay_cards(s) {
    "INSERT INTO pay.cards (merchant_id, consumer_id, method_token, billing_details, bin, expiry_month, expiry_year, issuer_name, last_four_digits, name) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_pay_address(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) +
    ")"
}
fn gen_insert_pay_companies(s) {
    "INSERT INTO pay.companies (id, bank_details, billing_details, business_details, contact_info, mailing_address, name) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_pay_bank_details(hash2(s, 1)) + ", " +
    cql_pay_address_v2(hash2(s, 2)) + ", " +
    cql_pay_business_details(hash2(s, 3)) + ", " +
    cql_pay_contact_info(hash2(s, 4)) + ", " +
    cql_pay_address_v2(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) +
    ")"
}
fn gen_insert_pay_crm_fields(s) {
    "INSERT INTO pay.crm_fields (id, created_at, description, form_type, input_type, label, options, placeholder, type, validation) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    "[" + cql_pay_custom_fields_options(hash2(s, 6)) + "]" + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_pay_custom_fields_validation(hash2(s, 9)) +
    ")"
}
fn gen_insert_pay_disputes(s) {
    "INSERT INTO pay.disputes (merchant_id, date, id, accepted_reason, amount, arn, attempt, company_id, consumer_id, currency, dispute_network_reference, disputed_payment, disputed_transaction, evidence, evidence_required_by, is_partial, last_update, mid, network, network_dispute_id, processor, processor_dispute_id, reason, reason_code, received_on, status) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_int(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_text(hash2(s, 12)) + ", " +
    cql_pay_evidence_references(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_bool(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_text(hash2(s, 18)) + ", " +
    cql_text(hash2(s, 19)) + ", " +
    cql_text(hash2(s, 20)) + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_text(hash2(s, 22)) + ", " +
    cql_text(hash2(s, 23)) + ", " +
    cql_text(hash2(s, 24)) + ", " +
    cql_text(hash2(s, 25)) +
    ")"
}
fn gen_insert_pay_ecp_credentials(s) {
    "INSERT INTO pay.ecp_credentials (merchant_id, ecp_password, ecp_tokens_by_currency, ecp_username) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    "{'" + cql_text_raw(hash2(s, 2)) + "': " + cql_pay_ecp_tokens(hash2(hash2(s, 2), 99)) + "}" + ", " +
    cql_text(hash2(s, 3)) +
    ")"
}
fn gen_insert_pay_finance_settings(s) {
    "INSERT INTO pay.finance_settings (company_id, merchant_id, commission_setup, referral_id) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    "{" + cql_pay_finance_commission_setup(hash2(s, 2)) + "}" + ", " +
    cql_text(hash2(s, 3)) +
    ")"
}
fn gen_insert_pay_fonix_credentials(s) {
    "INSERT INTO pay.fonix_credentials (merchant_id, fonix_api_key, fonix_credentials, fonix_originator_number) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    "{'" + cql_text_raw(hash2(s, 2)) + "': " + cql_pay_fonix_services_credentials(hash2(hash2(s, 2), 99)) + "}" + ", " +
    cql_text(hash2(s, 3)) +
    ")"
}
fn gen_insert_pay_gumballpay_credentials(s) {
    "INSERT INTO pay.gumballpay_credentials (merchant_id, control_key, endpoint_group_id, endpoint_id, gumballpay_payout_credentials, username) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_pay_gumballpay_tokens(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) +
    ")"
}
fn gen_insert_pay_legal_entities(s) {
    "INSERT INTO pay.legal_entities (company_id, id, application_status, billing_address, company_number, contact_info, continent, created_at, dba_name, mcc, name, registered_address, tax_identifier, updated_at) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_pay_address_v2(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    "[" + cql_pay_entity_contact_info(hash2(s, 5)) + "]" + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_int(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_pay_address_v2(hash2(s, 11)) + ", " +
    cql_text(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) +
    ")"
}
fn gen_insert_pay_limits(s) {
    "INSERT INTO pay.limits (company_id, merchant_id, maximum_payment_amount, minimum_payment_amount, payment_methods_options) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_pay_payment_methods_options_limits(hash2(s, 4)) +
    ")"
}
fn gen_insert_pay_logic_fields(s) {
    "INSERT INTO pay.logic_fields (identifier, key, additional_settings, category_name, created_at, default_value, internal, label, list_types, only_for_outcomes_categories, options, placeholder, regex, sub_key, updated_at, value_field_type) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_pay_logic_fields_additional_settings(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_bool(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_set_text(hash2(s, 8)) + ", " +
    cql_set_text(hash2(s, 9)) + ", " +
    "[" + cql_pay_logic_field_options(hash2(s, 10)) + "]" + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_text(hash2(s, 12)) + ", " +
    cql_bool(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) +
    ")"
}
fn gen_insert_pay_merchants(s) {
    "INSERT INTO pay.merchants (company_id, id, acquirer, activation_date, api_resources_gates, application_status, assignee, automatic_review, billing_details, branding, business_details, consumer_payouts_enabled, contact_info, continent, costs_provider_override, country, currency_code, currency_to_settlement_account, default_3ds_processor, default_processor, default_processor_amex, default_processor_discover, default_processor_map, default_processor_mastercard, default_processor_visa, default_settlement_account_id, descriptor, doing_business_as, entity_id, feature_flags, frontegg_tenant_id, gateway, last_updated, merchant_status, metadata, name, override_onboarding_merchant_id, payfac, payment_methods_options_defaults, processing_currency_codes, processing_risk_score, processing_to_settlements_currency_codes, reference, settlement_currency_codes, stage, status, tenant, test_merchant) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_list_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_map_tb(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_bool(hash2(s, 7)) + ", " +
    cql_pay_address_v2(hash2(s, 8)) + ", " +
    cql_pay_branding(hash2(s, 9)) + ", " +
    cql_pay_business_details(hash2(s, 10)) + ", " +
    cql_bool(hash2(s, 11)) + ", " +
    cql_pay_contact_info(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    cql_map_tt(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_map_tt(hash2(s, 17)) + ", " +
    cql_text(hash2(s, 18)) + ", " +
    cql_text(hash2(s, 19)) + ", " +
    cql_text(hash2(s, 20)) + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_map_tt(hash2(s, 22)) + ", " +
    cql_text(hash2(s, 23)) + ", " +
    cql_text(hash2(s, 24)) + ", " +
    cql_text(hash2(s, 25)) + ", " +
    cql_text(hash2(s, 26)) + ", " +
    cql_text(hash2(s, 27)) + ", " +
    cql_text(hash2(s, 28)) + ", " +
    cql_map_tb(hash2(s, 29)) + ", " +
    cql_text(hash2(s, 30)) + ", " +
    cql_list_text(hash2(s, 31)) + ", " +
    cql_text(hash2(s, 32)) + ", " +
    cql_text(hash2(s, 33)) + ", " +
    cql_map_tt(hash2(s, 34)) + ", " +
    cql_text(hash2(s, 35)) + ", " +
    cql_text(hash2(s, 36)) + ", " +
    cql_list_text(hash2(s, 37)) + ", " +
    cql_pay_payment_method_options(hash2(s, 38)) + ", " +
    cql_list_text(hash2(s, 39)) + ", " +
    cql_text(hash2(s, 40)) + ", " +
    cql_map_tt(hash2(s, 41)) + ", " +
    cql_text(hash2(s, 42)) + ", " +
    cql_list_text(hash2(s, 43)) + ", " +
    cql_int(hash2(s, 44)) + ", " +
    cql_text(hash2(s, 45)) + ", " +
    cql_text(hash2(s, 46)) + ", " +
    cql_bool(hash2(s, 47)) +
    ")"
}
fn gen_insert_pay_notification_subscriptions(s) {
    "INSERT INTO pay.notification_subscriptions (company_id, merchant_id, user_id, notification_type, created_at, delivery_config, updated_at) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_pay_notification_subscription_delivery_config(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) +
    ")"
}
fn gen_insert_pay_notifications(s) {
    "INSERT INTO pay.notifications (notification_type, active, created_at, delivery_config, description, name, updated_at) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_bool(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_pay_notification_delivery_config(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) +
    ")"
}
fn gen_insert_pay_payment_control(s) {
    "INSERT INTO pay.payment_control (company_id, merchant_id, currency, hours, transaction_types) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    "{'" + cql_text_raw(hash2(s, 2)) + "': " + cql_pay_processor_config(hash2(hash2(s, 2), 99)) + "}" + ", " +
    "{'" + cql_text_raw(hash2(s, 3)) + "': " + cql_pay_payment_control_hours(hash2(hash2(s, 3), 99)) + "}" + ", " +
    "{'" + cql_text_raw(hash2(s, 4)) + "': " + cql_pay_processor_transaction_type_config(hash2(hash2(s, 4), 99)) + "}" +
    ")"
}
fn gen_insert_pay_payment_control_v2(s) {
    "INSERT INTO pay.payment_control_v2 (company_id, settlement_account_id, merchant_id, currency, hours, transaction_types) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    "{'" + cql_text_raw(hash2(s, 3)) + "': " + cql_pay_processor_config(hash2(hash2(s, 3), 99)) + "}" + ", " +
    "{'" + cql_text_raw(hash2(s, 4)) + "': " + cql_pay_payment_control_hours(hash2(hash2(s, 4), 99)) + "}" + ", " +
    "{'" + cql_text_raw(hash2(s, 5)) + "': " + cql_pay_processor_transaction_type_config(hash2(hash2(s, 5), 99)) + "}" +
    ")"
}
fn gen_insert_pay_payment_method_options(s) {
    "INSERT INTO pay.payment_method_options (key, id, attempt_id, applepay, authentication_options, bank_account, card, decline_recovery, disabled_payment_methods_types, googlepay, payout_method_options, paypal, risk_control, routing_methodologies, types, us_bank_account) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_pay_payment_method_options_applepay_v2(hash2(s, 3)) + ", " +
    cql_pay_authentication_options(hash2(s, 4)) + ", " +
    cql_pay_payment_method_options_bank_v2(hash2(s, 5)) + ", " +
    cql_pay_card_method_options_v2(hash2(s, 6)) + ", " +
    cql_pay_decline_recovery_settings(hash2(s, 7)) + ", " +
    cql_list_text(hash2(s, 8)) + ", " +
    cql_pay_payment_method_options_googleplay_v2(hash2(s, 9)) + ", " +
    cql_pay_payout_method_options(hash2(s, 10)) + ", " +
    cql_pay_paypal_method_options_v2(hash2(s, 11)) + ", " +
    "[" + cql_pay_risk_control_payment_method_options(hash2(s, 12)) + "]" + ", " +
    cql_list_text(hash2(s, 13)) + ", " +
    cql_list_text(hash2(s, 14)) + ", " +
    cql_pay_us_bank_account_method_options_v2(hash2(s, 15)) +
    ")"
}
fn gen_insert_pay_payment_method_options_configs(s) {
    "INSERT INTO pay.payment_method_options_configs (company_id, merchant_id, id, applepay, authentication_options, bank_account, card, created_at, default_config, disabled_payment_methods_types, googlepay, name, neteller, payout_method_options, paypal, routing_methodologies, skrill, types, updated_at, us_bank_account) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_pay_payment_method_options_applepay_v2(hash2(s, 3)) + ", " +
    cql_pay_authentication_options(hash2(s, 4)) + ", " +
    cql_pay_payment_method_options_bank_v2(hash2(s, 5)) + ", " +
    cql_pay_card_method_options_v2(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_bool(hash2(s, 8)) + ", " +
    cql_list_text(hash2(s, 9)) + ", " +
    cql_pay_payment_method_options_googleplay_v2(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_pay_skrill_neteller_payment_method_options(hash2(s, 12)) + ", " +
    cql_pay_payout_method_options(hash2(s, 13)) + ", " +
    cql_pay_paypal_method_options_v2(hash2(s, 14)) + ", " +
    cql_list_text(hash2(s, 15)) + ", " +
    cql_pay_skrill_neteller_payment_method_options(hash2(s, 16)) + ", " +
    cql_list_text(hash2(s, 17)) + ", " +
    cql_text(hash2(s, 18)) + ", " +
    cql_pay_us_bank_account_method_options_v2(hash2(s, 19)) +
    ")"
}
fn gen_insert_pay_paymentlinks(s) {
    "INSERT INTO pay.paymentlinks (company_id, merchant_id, id, after_completion, amount, amount_limits, available_payment_methods, collection, created_at, currency, custom_fields, custom_text, description, duration, is_deleted, link, max_attempts, name, payment_method_options, send_receipt, statement_descriptor_suffix, type, updated_at) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_pay_after_completion(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_pay_payment_link_amount_limits(hash2(s, 5)) + ", " +
    cql_list_text(hash2(s, 6)) + ", " +
    cql_pay_collection(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    "[" + cql_pay_custom_fields_v2(hash2(s, 10)) + "]" + ", " +
    cql_pay_custom_text(hash2(s, 11)) + ", " +
    cql_text(hash2(s, 12)) + ", " +
    cql_int(hash2(s, 13)) + ", " +
    cql_bool(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_int(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_pay_payment_method_options(hash2(s, 18)) + ", " +
    cql_bool(hash2(s, 19)) + ", " +
    cql_text(hash2(s, 20)) + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_text(hash2(s, 22)) +
    ")"
}
fn gen_insert_pay_paypal_payers(s) {
    "INSERT INTO pay.paypal_payers (merchant_id, consumer_id, email, address, dob, first_name, last_name, payer_id, phone) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_pay_address(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) +
    ")"
}
fn gen_insert_pay_pricing(s) {
    "INSERT INTO pay.pricing (company_id, merchant_id, actions, blended, created_at, currency, funding_delay, maximum_held_reserve, rolling_reserve_amount, rolling_reserve_duration, rolling_reserve_enabled, rolling_reserve_type) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    "{'" + cql_text_raw(hash2(s, 2)) + "': " + cql_pay_pricing_action_object(hash2(hash2(s, 2), 99)) + "}" + ", " +
    cql_bool(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_bool(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) +
    ")"
}
fn gen_insert_pay_pricing_v2(s) {
    "INSERT INTO pay.pricing_v2 (company_id, merchant_id, provider, actions, additional_configuration, additional_cost_providers, alternative_currencies, alternative_payment_methods, blended, created_at, currency, funding_delay, maximum_held_reserve, monthly_merchant_fee, monthly_minimum_fee, override_gross_fixed_currency, rolling_reserve_amount, rolling_reserve_duration, rolling_reserve_enabled, rolling_reserve_type, settlement_day, settlement_fees, settlement_schedule, updated_at) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    "{'" + cql_text_raw(hash2(s, 3)) + "': " + cql_pay_pricing_action_object(hash2(hash2(s, 3), 99)) + "}" + ", " +
    cql_pay_pricing_additional_configuration(hash2(s, 4)) + ", " +
    cql_list_text(hash2(s, 5)) + ", " +
    "{'" + cql_text_raw(hash2(s, 6)) + "': " + cql_pay_pricing_alternative_currencies_v2(hash2(hash2(s, 6), 99)) + "}" + ", " +
    "{'" + cql_text_raw(hash2(s, 7)) + "': " + cql_pay_pricing_alternative_payment_methods(hash2(hash2(s, 7), 99)) + "}" + ", " +
    cql_bool(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_text(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_bool(hash2(s, 18)) + ", " +
    cql_text(hash2(s, 19)) + ", " +
    cql_int(hash2(s, 20)) + ", " +
    "{'" + cql_text_raw(hash2(s, 21)) + "': " + cql_pay_pricing_action_object(hash2(hash2(s, 21), 99)) + "}" + ", " +
    cql_text(hash2(s, 22)) + ", " +
    cql_text(hash2(s, 23)) +
    ")"
}
fn gen_insert_pay_pricing_v3(s) {
    "INSERT INTO pay.pricing_v3 (company_id, settlement_account_id, currency, payment_method_type, merchant_id, actions, additional_configuration, additional_cost_providers, alternative_currencies, alternative_payment_methods, blended, created_at, funding_delay, maximum_held_reserve, monthly_merchant_fee, monthly_minimum_fee, override_gross_fixed_currency, provider, rolling_reserve_amount, rolling_reserve_duration, rolling_reserve_enabled, rolling_reserve_type, settlement_day, settlement_fees, settlement_schedule, updated_at) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    "{'" + cql_text_raw(hash2(s, 5)) + "': " + cql_pay_pricing_action_object(hash2(hash2(s, 5), 99)) + "}" + ", " +
    cql_pay_pricing_additional_configuration(hash2(s, 6)) + ", " +
    cql_list_text(hash2(s, 7)) + ", " +
    "{'" + cql_text_raw(hash2(s, 8)) + "': " + cql_pay_pricing_alternative_currencies_v2(hash2(hash2(s, 8), 99)) + "}" + ", " +
    "{'" + cql_text_raw(hash2(s, 9)) + "': " + cql_pay_pricing_alternative_payment_methods(hash2(hash2(s, 9), 99)) + "}" + ", " +
    cql_bool(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_text(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_text(hash2(s, 18)) + ", " +
    cql_text(hash2(s, 19)) + ", " +
    cql_bool(hash2(s, 20)) + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_int(hash2(s, 22)) + ", " +
    "{'" + cql_text_raw(hash2(s, 23)) + "': " + cql_pay_pricing_action_object(hash2(hash2(s, 23), 99)) + "}" + ", " +
    cql_text(hash2(s, 24)) + ", " +
    cql_text(hash2(s, 25)) +
    ")"
}
fn gen_insert_pay_receipts(s) {
    "INSERT INTO pay.receipts (transaction_id, company_id, id, amount_received, amount_refunded, created_at, deliveries, filename, funds_status) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    "{" + cql_pay_receipt_delivery_record(hash2(s, 6)) + "}" + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) +
    ")"
}
fn gen_insert_pay_reconciliation_config(s) {
    "INSERT INTO pay.reconciliation_config (regex, enabled, example, namespace, params, provider, queue, reconciliation_type, successor_workflow, task_queue, unique_id_regex, workflow) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_bool(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    "{'" + cql_text_raw(hash2(s, 4)) + "': " + cql_pay_reconciliation_config_params(hash2(hash2(s, 4), 99)) + "}" + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_bool(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) +
    ")"
}
fn gen_insert_pay_referrals(s) {
    "INSERT INTO pay.referrals (id, actions, alternative_currencies, alternative_payment_methods, commission_setup, currency, enabled, expires_in_years, name, period_count_starts_from, rev_share_tiers, settlement_fees) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    "{'" + cql_text_raw(hash2(s, 1)) + "': " + cql_pay_pricing_action_object(hash2(hash2(s, 1), 99)) + "}" + ", " +
    "{'" + cql_text_raw(hash2(s, 2)) + "': " + cql_pay_pricing_alternative_currencies_v2(hash2(hash2(s, 2), 99)) + "}" + ", " +
    "{'" + cql_text_raw(hash2(s, 3)) + "': " + cql_pay_pricing_alternative_payment_methods(hash2(hash2(s, 3), 99)) + "}" + ", " +
    "{" + cql_pay_finance_commission_setup(hash2(s, 4)) + "}" + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_bool(hash2(s, 6)) + ", " +
    cql_int(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    "{" + cql_pay_finance_rev_share_tiers(hash2(s, 10)) + "}" + ", " +
    "{'" + cql_text_raw(hash2(s, 11)) + "': " + cql_pay_pricing_action_object(hash2(hash2(s, 11), 99)) + "}" +
    ")"
}
fn gen_insert_pay_report_pull_config(s) {
    "INSERT INTO pay.report_pull_config (provider, id, access_type, company_id, created_at, credentials, destination_folder, enabled, file_date_regex, file_type_filter, format_file, host, merchant_ids, merge_files, params, password, port, private_key, raw_data_folder, source_folder, type, updated_at, username) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_bool(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_bool(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_list_text(hash2(s, 12)) + ", " +
    cql_bool(hash2(s, 13)) + ", " +
    "{'" + cql_text_raw(hash2(s, 14)) + "': " + cql_pay_reconciliation_config_params(hash2(hash2(s, 14), 99)) + "}" + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_text(hash2(s, 18)) + ", " +
    cql_text(hash2(s, 19)) + ", " +
    cql_text(hash2(s, 20)) + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_text(hash2(s, 22)) +
    ")"
}
fn gen_insert_pay_reports(s) {
    "INSERT INTO pay.reports (company_id, merchant_id, id, active, columns, created_at, distribution_method, emails, end_period, filters, format, frequency, last_update, name, recurrence_period, start_period, type) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_bool(hash2(s, 3)) + ", " +
    cql_map_flt(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_list_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    "{" + cql_pay_filter_field(hash2(s, 9)) + "}" + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_text(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    cql_pay_recurring_time_settings(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) +
    ")"
}
fn gen_insert_pay_reports_config(s) {
    "INSERT INTO pay.reports_config (company_id, merchant_id, custom_fields, default_config, enabled_reports, exclude_fields, per_report_config_override, rename_fields) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    "null" + ", " +
    cql_pay_report_config(hash2(s, 3)) + ", " +
    cql_list_text(hash2(s, 4)) + ", " +
    "null" + ", " +
    "{'" + cql_text_raw(hash2(s, 6)) + "': " + cql_pay_report_config(hash2(hash2(s, 6), 99)) + "}" + ", " +
    "{'" + cql_text_raw(hash2(s, 7)) + "': " + cql_pay_rename_fields_type(hash2(hash2(s, 7), 99)) + "}" +
    ")"
}
fn gen_insert_pay_risk_alerts(s) {
    "INSERT INTO pay.risk_alerts (company_id, merchant_id, id, actions_to_be_taken, alert_name, alert_notes, category, customer, escalation_reason, evaluated_at, evaluation_report, issue_link, last_updated_by, last_updated_on, priority, resolve_reason, rule_id, seen, status_list, suspicion_report, triggered_previously, triggering_transaction_id, uniqueness_params) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    "[" + cql_pay_note(hash2(s, 5)) + "]" + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_pay_risk_alert_customer(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_pay_evaluation_report(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_text(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_bool(hash2(s, 17)) + ", " +
    "[" + cql_pay_risk_alert_status_details(hash2(s, 18)) + "]" + ", " +
    cql_pay_suspicion_report(hash2(s, 19)) + ", " +
    cql_int(hash2(s, 20)) + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_map_tt(hash2(s, 22)) +
    ")"
}
fn gen_insert_pay_risk_calculations(s) {
    "INSERT INTO pay.risk_calculations (company_id, merchant_id, id, calculated_at, calculated_by, details, reason, score, score_type) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    "[" + cql_pay_risk_calculation_details(hash2(s, 5)) + "]" + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) +
    ")"
}
fn gen_insert_pay_rules(s) {
    "INSERT INTO pay.rules (company_id, merchant_id, id, alert_frequency, alert_uniqueness_params, allow_updates_to_groups, archived, category, created_by, default_risk_alert_category, description, dry_run, enabled, excludable, failure_code, failure_reason, fallback_config, global_aggregation, internal_rule, last_updated, logic, logic_client, outcome, outcome_details_by_range, outcomes, payment_method_config_id, payment_methods_options, payment_methods_options_v2, post_external_risk_check, priority, processor_config, risk_score_modifier, routing_priority, rule_level, rule_priority, scoping_logic, system_rule) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_list_text(hash2(s, 4)) + ", " +
    cql_list_text(hash2(s, 5)) + ", " +
    cql_bool(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_bool(hash2(s, 11)) + ", " +
    cql_bool(hash2(s, 12)) + ", " +
    cql_bool(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_pay_fallback_config(hash2(s, 16)) + ", " +
    cql_bool(hash2(s, 17)) + ", " +
    cql_bool(hash2(s, 18)) + ", " +
    cql_text(hash2(s, 19)) + ", " +
    cql_text(hash2(s, 20)) + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_text(hash2(s, 22)) + ", " +
    "[" + cql_pay_outcome_details_by_range(hash2(s, 23)) + "]" + ", " +
    cql_list_text(hash2(s, 24)) + ", " +
    cql_text(hash2(s, 25)) + ", " +
    cql_pay_payment_method_options(hash2(s, 26)) + ", " +
    cql_pay_payment_method_options_v2(hash2(s, 27)) + ", " +
    cql_bool(hash2(s, 28)) + ", " +
    cql_text(hash2(s, 29)) + ", " +
    cql_pay_processor_config(hash2(s, 30)) + ", " +
    cql_text(hash2(s, 31)) + ", " +
    cql_int(hash2(s, 32)) + ", " +
    cql_text(hash2(s, 33)) + ", " +
    cql_float(hash2(s, 34)) + ", " +
    cql_text(hash2(s, 35)) + ", " +
    cql_bool(hash2(s, 36)) +
    ")"
}
fn gen_insert_pay_settings(s) {
    "INSERT INTO pay.settings (company_id, merchant_id, checkout_sdk_config, collection_defaults, cta_text, cybersource_risk_config, default_payment_method_options_id, default_risk_control, fallback_url, locale, metadata_quick_search_keys, payment_methods_options_defaults, payment_methods_options_defaults_v2, providers_config) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_pay_collection(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    "[" + cql_pay_cybersource_risk_interval(hash2(s, 5)) + "]" + ", " +
    cql_text(hash2(s, 6)) + ", " +
    "[" + cql_pay_risk_control_payment_method_options(hash2(s, 7)) + "]" + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_list_text(hash2(s, 10)) + ", " +
    cql_pay_payment_method_options(hash2(s, 11)) + ", " +
    cql_pay_payment_method_options_v2(hash2(s, 12)) + ", " +
    cql_map_tt(hash2(s, 13)) +
    ")"
}
fn gen_insert_pay_settlement_config(s) {
    "INSERT INTO pay.settlement_config (company_id, id, acceptance_currencies, bank_account_id, bank_account_merchant_id, billing_address, conversion_price_per_currency, country, created_at, currency, default_processor, descriptor, enabled, enabled_transfer_types, entity_id, entity_name, fallback_failure_codes, fallback_settlement_account_id, funding_delay, global_conversion_price, intermediary_bank_account_id, intermediary_bank_account_merchant_id, intermediary_provider, maximum_held_reserve, mcc, merchant_ids, metadata, name, parent_settlement_account, payment_method_processor_map, processors, provider, provider_reference, rolling_reserve_amount, rolling_reserve_duration, rolling_reserve_enabled, rolling_reserve_type, routing_key, schedule_config, settlement_transfer_type, suspended, three_ds_processor, three_ds_processor_map, updated_at, vat_number, virtual) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_set_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_pay_address_v2(hash2(s, 5)) + ", " +
    cql_map_tt(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_bool(hash2(s, 12)) + ", " +
    cql_set_text(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_set_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_int(hash2(s, 18)) + ", " +
    cql_text(hash2(s, 19)) + ", " +
    cql_text(hash2(s, 20)) + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_text(hash2(s, 22)) + ", " +
    cql_text(hash2(s, 23)) + ", " +
    cql_text(hash2(s, 24)) + ", " +
    cql_list_text(hash2(s, 25)) + ", " +
    cql_map_tt(hash2(s, 26)) + ", " +
    cql_text(hash2(s, 27)) + ", " +
    cql_text(hash2(s, 28)) + ", " +
    cql_map_tt(hash2(s, 29)) + ", " +
    cql_set_text(hash2(s, 30)) + ", " +
    cql_text(hash2(s, 31)) + ", " +
    cql_text(hash2(s, 32)) + ", " +
    cql_text(hash2(s, 33)) + ", " +
    cql_int(hash2(s, 34)) + ", " +
    cql_bool(hash2(s, 35)) + ", " +
    cql_text(hash2(s, 36)) + ", " +
    cql_text(hash2(s, 37)) + ", " +
    cql_pay_schedule_config_settlement(hash2(s, 38)) + ", " +
    cql_text(hash2(s, 39)) + ", " +
    cql_bool(hash2(s, 40)) + ", " +
    cql_text(hash2(s, 41)) + ", " +
    cql_map_tt(hash2(s, 42)) + ", " +
    cql_text(hash2(s, 43)) + ", " +
    cql_text(hash2(s, 44)) + ", " +
    cql_bool(hash2(s, 45)) +
    ")"
}
fn gen_insert_pay_settlements(s) {
    "INSERT INTO pay.settlements (company_id, merchant_id, id, currency, bank_reference_number, blended, card_settlement_bank_cleared, card_settlement_bank_clearing_date, card_settlement_bank_transfer_reference, card_settlement_cleared, card_settlement_clearing_date, charge_amount, charge_count, chargeback_amount, chargeback_breakdown, chargeback_count, chargeback_fees, created_at, date_from, date_to, decline_count, general_adjustments, interchange_fees, interchange_returned, merchant_bank_account, merchant_bank_name, merchant_ids, merchant_statement_file, net_amount, network_fees, payment_date, payout_amount, payout_count, processed_amount, processed_count, processing_fees, processing_fees_breakdown, processing_fees_breakdown_detailed, refund_amount, refund_count, rolling_reserve_adjustment, rolling_reserve_amount, rolling_reserve_released_amount, service_fees, settlement_config_id, settlement_fee, settlement_method, settling_entity, settling_entity_id, status, sub_transfers_data, total_fees, transaction_max_datetime, transaction_min_datetime, updated_at, vat) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_bool(hash2(s, 5)) + ", " +
    cql_bool(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_bool(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_int(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    cql_pay_chargeback_breakdown_by_scheme(hash2(s, 14)) + ", " +
    cql_int(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_text(hash2(s, 18)) + ", " +
    cql_text(hash2(s, 19)) + ", " +
    cql_int(hash2(s, 20)) + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_text(hash2(s, 22)) + ", " +
    cql_text(hash2(s, 23)) + ", " +
    cql_text(hash2(s, 24)) + ", " +
    cql_text(hash2(s, 25)) + ", " +
    cql_list_text(hash2(s, 26)) + ", " +
    cql_text(hash2(s, 27)) + ", " +
    cql_text(hash2(s, 28)) + ", " +
    cql_text(hash2(s, 29)) + ", " +
    cql_text(hash2(s, 30)) + ", " +
    cql_text(hash2(s, 31)) + ", " +
    cql_int(hash2(s, 32)) + ", " +
    cql_text(hash2(s, 33)) + ", " +
    cql_int(hash2(s, 34)) + ", " +
    cql_text(hash2(s, 35)) + ", " +
    cql_pay_processing_fees_breakdown_by_scheme(hash2(s, 36)) + ", " +
    cql_pay_processing_fees_breakdown_by_scheme_detailed(hash2(s, 37)) + ", " +
    cql_text(hash2(s, 38)) + ", " +
    cql_int(hash2(s, 39)) + ", " +
    cql_text(hash2(s, 40)) + ", " +
    cql_text(hash2(s, 41)) + ", " +
    cql_text(hash2(s, 42)) + ", " +
    cql_text(hash2(s, 43)) + ", " +
    cql_text(hash2(s, 44)) + ", " +
    cql_text(hash2(s, 45)) + ", " +
    cql_text(hash2(s, 46)) + ", " +
    cql_text(hash2(s, 47)) + ", " +
    cql_text(hash2(s, 48)) + ", " +
    cql_text(hash2(s, 49)) + ", " +
    cql_map_tt(hash2(s, 50)) + ", " +
    cql_text(hash2(s, 51)) + ", " +
    cql_text(hash2(s, 52)) + ", " +
    cql_text(hash2(s, 53)) + ", " +
    cql_text(hash2(s, 54)) + ", " +
    cql_text(hash2(s, 55)) +
    ")"
}
fn gen_insert_pay_silverflow_credentials(s) {
    "INSERT INTO pay.silverflow_credentials (merchant_id, funding, payout, silverflow_api_key, silverflow_api_secret, silverflow_credentials_by_currency, silverflow_merchant_acceptor_key, silverflow_region) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_pay_silverflow_credentials_payout(hash2(s, 1)) + ", " +
    cql_pay_silverflow_credentials_payout(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    "{'" + cql_text_raw(hash2(s, 5)) + "': " + cql_pay_silverflow_merchant_acceptor_key(hash2(hash2(s, 5), 99)) + "}" + ", " +
    cql_pay_silverflow_merchant_acceptor_key(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) +
    ")"
}
fn gen_insert_pay_sources(s) {
    "INSERT INTO pay.sources (merchant_id, type, unique_identifier, billing_details, billing_details_id, card, company_id, consumer_id, id, last_transaction_date, paypal, paypal_billing_agreement, paysafecard, reusable_payments, reusable_payouts, site_id) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_pay_address_v2(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_pay_payment_method_card(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_timestamp(hash2(s, 9)) + ", " +
    cql_pay_payment_method_paypal(hash2(s, 10)) + ", " +
    cql_pay_payment_method_paypal_billing_agreement(hash2(s, 11)) + ", " +
    cql_pay_payment_method_paysafecard(hash2(s, 12)) + ", " +
    cql_bool(hash2(s, 13)) + ", " +
    cql_bool(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) +
    ")"
}
fn gen_insert_pay_sources_v2(s) {
    "INSERT INTO pay.sources_v2 (merchant_id, consumer_id, type, unique_identifier, applepay, bank_account, billing_details, billing_details_id, card, company_id, created_at, disable_duplicate_check, generic, googlepay, id, in_bank_account, initial_successful_settlement_account, last_transaction_date, metadata, netbanking, network_transaction_id, network_transaction_tx_id, paypal, paypal_billing_agreement, paysafecard, previous_successful_settlement_account, reference, reusable_payments, reusable_payouts, site_id, updated_at, upi, us_bank_account) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_pay_payment_method_card(hash2(s, 4)) + ", " +
    cql_pay_payment_method_bank_account(hash2(s, 5)) + ", " +
    cql_pay_address_v2(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_pay_payment_method_card(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_bool(hash2(s, 11)) + ", " +
    cql_pay_payment_method_generic(hash2(s, 12)) + ", " +
    cql_pay_payment_method_card(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_pay_payment_method_bank_account(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_map_tt(hash2(s, 18)) + ", " +
    cql_pay_payment_method_netbanking(hash2(s, 19)) + ", " +
    cql_text(hash2(s, 20)) + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_pay_payment_method_paypal(hash2(s, 22)) + ", " +
    cql_pay_payment_method_paypal_billing_agreement(hash2(s, 23)) + ", " +
    cql_pay_payment_method_paysafecard(hash2(s, 24)) + ", " +
    cql_text(hash2(s, 25)) + ", " +
    cql_text(hash2(s, 26)) + ", " +
    cql_bool(hash2(s, 27)) + ", " +
    cql_bool(hash2(s, 28)) + ", " +
    cql_text(hash2(s, 29)) + ", " +
    cql_text(hash2(s, 30)) + ", " +
    cql_pay_payment_method_upi(hash2(s, 31)) + ", " +
    cql_pay_payment_method_bank_account(hash2(s, 32)) +
    ")"
}
fn gen_insert_pay_statements(s) {
    "INSERT INTO pay.statements (company_id, date, id, created_at, data, deliveries, filename, identifier, merchant_id, type, updated_at) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_map_tt(hash2(s, 4)) + ", " +
    "{" + cql_pay_statement_delivery_record(hash2(s, 5)) + "}" + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) +
    ")"
}
fn gen_insert_pay_subscription_packages(s) {
    "INSERT INTO pay.subscription_packages (company_id, merchant_id, id, active, created_at, description, reference, settings, updated_at) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_bool(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_pay_subscriptions_common_settings(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) +
    ")"
}
fn gen_insert_pay_subscriptions(s) {
    "INSERT INTO pay.subscriptions (company_id, date, id, cancel_at, cancel_at_period_end, cancellation_reason, consumer_id, consumer_region, created_at, current_period_end_date, current_period_start_date, ended_at, failed_charging_attempts, failed_next_charge_attempt_date, initial_subscription_session, latest_successful_amount, latest_successful_charge, merchant_id, metadata, reference, settings, source_id, status, trial_period_end_date, trial_period_start_date, updated_at) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_bool(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_int(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_map_tt(hash2(s, 18)) + ", " +
    cql_text(hash2(s, 19)) + ", " +
    cql_pay_subscriptions_custom_settings(hash2(s, 20)) + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_text(hash2(s, 22)) + ", " +
    cql_text(hash2(s, 23)) + ", " +
    cql_text(hash2(s, 24)) + ", " +
    cql_text(hash2(s, 25)) +
    ")"
}
fn gen_insert_pay_task_templates(s) {
    "INSERT INTO pay.task_templates (id, actions, category, created_at, created_by, fields, is_deleted, slug, title, type, updated_at, workflow) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    "[" + cql_pay_task_template_action(hash2(s, 1)) + "]" + ", " +
    cql_pay_task_category(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    "[" + cql_pay_task_template_field(hash2(s, 5)) + "]" + ", " +
    cql_bool(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) +
    ")"
}
fn gen_insert_pay_tasks(s) {
    "INSERT INTO pay.tasks (partition_key, id, actions, assignee, cancel_reason, canceled_at, category, company_id, completed_at, created_at, created_by, creator_note, description, expires_on, fields, group_assignee, merchant_group_assignee, merchant_id, metadata, notes, parent_id, signal, status, task_template_id, title, type, values, workflow) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    "[" + cql_pay_task_template_action(hash2(s, 2)) + "]" + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_pay_task_category(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_text(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    "[" + cql_pay_task_template_field(hash2(s, 14)) + "]" + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_map_tt(hash2(s, 18)) + ", " +
    "[" + cql_pay_task_note(hash2(s, 19)) + "]" + ", " +
    cql_text(hash2(s, 20)) + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_text(hash2(s, 22)) + ", " +
    cql_text(hash2(s, 23)) + ", " +
    cql_text(hash2(s, 24)) + ", " +
    cql_text(hash2(s, 25)) + ", " +
    "[" + cql_pay_task_value(hash2(s, 26)) + "]" + ", " +
    cql_text(hash2(s, 27)) +
    ")"
}
fn gen_insert_pay_transactions(s) {
    "INSERT INTO pay.transactions (key, id, attempt_id, acquirer_bin, acquirer_mid, acquiring_setup, additional_pricing_actions, after_completion, allocation_bank_transfer_reference, allocation_cleared_transactional_fees_bank_transfer_id, allocation_fx_fees_bank_transfer_id, allocation_net_amount_bank_transfer_id, allocation_non_cleared_transactional_fees_bank_transfer_id, allow_partial_approval, amount_cancelled, amount_capturable, amount_eur, amount_gbp, amount_received, amount_refunded, amount_usd, anonymous_proxy, apm_metadata, approved_amount, at_least_one_capture, attempt, authentication_context, available_payment_methods, bank_cleared, bank_clearing_date, bank_settlement_summable_amount, bank_settlement_summable_amount_currency, bank_transfer_reference, billing_details, billing_details_address_id, blended_pricing, blocked_by_rule_id, calculated_statement_descriptor, capture_delay, chargeback_reason_code, checkout, checkout_cashier, checkout_cashier_balance, checkout_cashier_deposit_limit, checkout_cashier_preset_amounts, checkout_cashier_withdraw_limit, checkout_link, checkout_locale, checkout_session_duration, checkout_session_type, checkout_setup_future_usage, checkout_submit_type, cleared, cleared_at, clearing_date, clearing_file_identifier, client_country, client_ip, client_ipcity, client_ipcontinent, client_ipcountry, client_iplatitud, client_iplongitud, client_ipstate, client_posta, client_region, client_region_code, client_subdivision, client_timezone, collaboration_id, collection, commission, commission_id, company_id, confirm_related_transaction, consumer_dob, consumer_email, consumer_first_name, consumer_id, consumer_last_name, consumer_merchant_consumer_id, consumer_national_identification_number, consumer_phone, continent, conversion_bank_to_settlement_margin, conversion_bank_to_settlement_provider, conversion_bank_to_settlement_rate, conversion_provider_to_bank_margin, conversion_provider_to_bank_provider, conversion_provider_to_bank_rate, currency, custom_fields, custom_fields_list, custom_fields_values, custom_text, date_after_funding_delay, date_time, dcc_accepted, dcc_enabled, dcc_revenue, description, descriptor, dispute_accepted_lose_at, dispute_amount, dispute_id, dispute_status, dispute_won_at, dr_enabled, dr_finalize, end_user_amount, end_user_conversion_margin, end_user_conversion_rate, end_user_currency, entity_id, estimated_settlement_date, exemption_location, exemption_type, exemption_used, external_settlement, fee_currency, finalize, flow_directions, fraud, fraud_actionable, fraud_date_time, fraud_input_method, fraud_raw_code, fraud_raw_sub_code, fraud_sub_type, fraud_type, global_settlement_id, gross_fee, gross_invoice_id, initial_dispute_status, initialize_url, interchange_currency, interchange_fee_estimated, interchange_fee_final, internal_bank_amount, internal_bank_currency, internal_block, internal_clearing_date, internal_cost, internal_cost_acquiring, internal_cost_acquiring_basis_points, internal_cost_commission, internal_cost_fixed, internal_cost_fixed_processor, internal_cost_provider, internal_cost_referral, internal_metadata, internal_revenue_estimated, internal_revenue_final, internal_source, is_partial_chunk, jurisdiction, last_visited_step, mandate_id, manual_review, manual_review_approver_identifier, manual_review_approver_origin, manual_review_expires_at, manual_review_status, manual_review_status_reason, max_attempts, merchant_country, merchant_dba_name, merchant_fee, merchant_id, merchant_legal_name, merchant_onboarding_stage, metadata, mit, mit_reason, net_amount_currency, net_amount_estimated, net_amount_final, network_fee_currency, network_fee_estimated, network_fee_final, network_token_provision_response_code, network_token_used, network_transaction_id, notification_url, original_transaction, parent_settlement_account_id, partial, partial_approval, partially_refunded, payment_attempt, payment_id, payment_link_id, payment_method, payment_method_options, payment_status, pricing_segment_code, processor, processor_transaction_id, proxy_processor, receipt_email, receipt_number, receipt_url, reconciliation_date, reconciliation_failure_reason, reconciliation_id, reconciliation_status, recurring_expiry, recurring_frequency, redirect_url_failure, redirect_url_success, reference, referral_fee, referral_id, refunded, related_recurring_transaction, related_transaction, requested_amount, requestor_country, requestor_identifier, requestor_ip, requestor_origin, retry_of_attempt_id, risk_assessed, risk_assessment_decision, risk_assessment_decision_details, risk_assessment_decision_external_rules, risk_assessment_decision_internal_rules, risk_assessment_decision_reasons, risk_assessment_id, risk_assessment_rule_id, risk_assessment_rule_id_configuration, risk_assessment_rule_id_external, risk_assessment_rule_id_internal, risk_assessment_rule_id_routing, risk_assessment_score, risk_engine_id, rolling_reserve_amount, rolling_reserve_config_amount, rolling_reserve_config_duration, rolling_reserve_config_type, rolling_reserve_currency, rolling_reserve_enabled, rolling_reserve_id, rolling_reserve_release_date, routing_details, routing_key, scheme_fee_estimated, scheme_fee_final, session_date_time, settled, settlement_account_id, settlement_conversion_rate, settlement_conversion_rate_margin, settlement_conversion_rate_provider, settlement_currency, settlement_currency_amount, settlement_date, settlement_id, settlement_net_amount_final, setup_future_usage_type, shipping_details, shipping_details_address_id, shipping_first_name, shipping_last_name, shipping_phone, site_id, source_id, statement_descriptor_suffix, status, sub_type, subscription_id, summable_amount, tax_amount, tax_collection_enabled, tax_inclusive, tax_percentage, tax_product_code, terms_and_conditions_accepted, terms_and_conditions_accepted_on_transaction, three_ds_acs_operator_id, three_ds_acs_reference_number, three_ds_acs_transaction_id, three_ds_acs_url, three_ds_ares, three_ds_authentication_flow, three_ds_card_holder_info, three_ds_cavv, three_ds_challenge_indicator, three_ds_challenge_required, three_ds_challenge_url, three_ds_ds_transaction_id, three_ds_eci, three_ds_enrolled, three_ds_error_code, three_ds_error_description, three_ds_metadata, three_ds_method_completed, three_ds_method_payload, three_ds_method_url, three_ds_pa_res_status, three_ds_payload, three_ds_processor, three_ds_reason_code, three_ds_reason_description, three_ds_result, three_ds_result_extended, three_ds_rreq, three_ds_server_transaction_id, three_ds_status_reason, three_ds_timestamp, three_ds_used, three_ds_version, three_ds_xid, three_ri_indicator, three_ri_initial_authentication_acs_trans_id, three_ri_initial_authentication_date_time, three_ri_initial_authentication_ds_trans_id, three_ri_initial_authentication_flow, three_ri_initial_authentication_transaction_id, trace_ids, transaction_fee_estimated, transaction_fee_final, type, updated_at, updated_by, user_agent) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_pay_additional_pricing_actions(hash2(s, 6)) + ", " +
    cql_pay_after_completion(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_text(hash2(s, 12)) + ", " +
    cql_bool(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_text(hash2(s, 18)) + ", " +
    cql_text(hash2(s, 19)) + ", " +
    cql_text(hash2(s, 20)) + ", " +
    cql_bool(hash2(s, 21)) + ", " +
    cql_map_tt(hash2(s, 22)) + ", " +
    cql_text(hash2(s, 23)) + ", " +
    cql_bool(hash2(s, 24)) + ", " +
    cql_int(hash2(s, 25)) + ", " +
    cql_pay_authentication_context(hash2(s, 26)) + ", " +
    cql_list_text(hash2(s, 27)) + ", " +
    cql_bool(hash2(s, 28)) + ", " +
    cql_text(hash2(s, 29)) + ", " +
    cql_text(hash2(s, 30)) + ", " +
    cql_text(hash2(s, 31)) + ", " +
    cql_text(hash2(s, 32)) + ", " +
    cql_pay_address_v2(hash2(s, 33)) + ", " +
    cql_text(hash2(s, 34)) + ", " +
    cql_bool(hash2(s, 35)) + ", " +
    cql_text(hash2(s, 36)) + ", " +
    cql_text(hash2(s, 37)) + ", " +
    cql_text(hash2(s, 38)) + ", " +
    cql_text(hash2(s, 39)) + ", " +
    cql_bool(hash2(s, 40)) + ", " +
    cql_bool(hash2(s, 41)) + ", " +
    cql_text(hash2(s, 42)) + ", " +
    cql_text(hash2(s, 43)) + ", " +
    cql_list_text(hash2(s, 44)) + ", " +
    cql_text(hash2(s, 45)) + ", " +
    cql_text(hash2(s, 46)) + ", " +
    cql_text(hash2(s, 47)) + ", " +
    cql_int(hash2(s, 48)) + ", " +
    cql_text(hash2(s, 49)) + ", " +
    cql_bool(hash2(s, 50)) + ", " +
    cql_text(hash2(s, 51)) + ", " +
    cql_bool(hash2(s, 52)) + ", " +
    cql_text(hash2(s, 53)) + ", " +
    cql_text(hash2(s, 54)) + ", " +
    cql_text(hash2(s, 55)) + ", " +
    cql_text(hash2(s, 56)) + ", " +
    cql_text(hash2(s, 57)) + ", " +
    cql_text(hash2(s, 58)) + ", " +
    cql_text(hash2(s, 59)) + ", " +
    cql_text(hash2(s, 60)) + ", " +
    cql_text(hash2(s, 61)) + ", " +
    cql_text(hash2(s, 62)) + ", " +
    cql_text(hash2(s, 63)) + ", " +
    cql_text(hash2(s, 64)) + ", " +
    cql_text(hash2(s, 65)) + ", " +
    cql_text(hash2(s, 66)) + ", " +
    cql_text(hash2(s, 67)) + ", " +
    cql_text(hash2(s, 68)) + ", " +
    cql_text(hash2(s, 69)) + ", " +
    cql_pay_collection(hash2(s, 70)) + ", " +
    cql_text(hash2(s, 71)) + ", " +
    cql_text(hash2(s, 72)) + ", " +
    cql_text(hash2(s, 73)) + ", " +
    cql_bool(hash2(s, 74)) + ", " +
    cql_text(hash2(s, 75)) + ", " +
    cql_text(hash2(s, 76)) + ", " +
    cql_text(hash2(s, 77)) + ", " +
    cql_text(hash2(s, 78)) + ", " +
    cql_text(hash2(s, 79)) + ", " +
    cql_text(hash2(s, 80)) + ", " +
    cql_text(hash2(s, 81)) + ", " +
    cql_text(hash2(s, 82)) + ", " +
    cql_text(hash2(s, 83)) + ", " +
    cql_text(hash2(s, 84)) + ", " +
    cql_text(hash2(s, 85)) + ", " +
    cql_text(hash2(s, 86)) + ", " +
    cql_text(hash2(s, 87)) + ", " +
    cql_text(hash2(s, 88)) + ", " +
    cql_text(hash2(s, 89)) + ", " +
    cql_text(hash2(s, 90)) + ", " +
    cql_pay_custom_fields(hash2(s, 91)) + ", " +
    "[" + cql_pay_custom_fields_v2(hash2(s, 92)) + "]" + ", " +
    cql_map_tt(hash2(s, 93)) + ", " +
    cql_pay_custom_text(hash2(s, 94)) + ", " +
    cql_text(hash2(s, 95)) + ", " +
    cql_text(hash2(s, 96)) + ", " +
    cql_bool(hash2(s, 97)) + ", " +
    cql_bool(hash2(s, 98)) + ", " +
    cql_text(hash2(s, 99)) + ", " +
    cql_text(hash2(s, 100)) + ", " +
    cql_text(hash2(s, 101)) + ", " +
    cql_text(hash2(s, 102)) + ", " +
    cql_text(hash2(s, 103)) + ", " +
    cql_text(hash2(s, 104)) + ", " +
    cql_text(hash2(s, 105)) + ", " +
    cql_text(hash2(s, 106)) + ", " +
    cql_bool(hash2(s, 107)) + ", " +
    cql_pay_finalize(hash2(s, 108)) + ", " +
    cql_text(hash2(s, 109)) + ", " +
    cql_text(hash2(s, 110)) + ", " +
    cql_text(hash2(s, 111)) + ", " +
    cql_text(hash2(s, 112)) + ", " +
    cql_text(hash2(s, 113)) + ", " +
    cql_text(hash2(s, 114)) + ", " +
    cql_text(hash2(s, 115)) + ", " +
    cql_text(hash2(s, 116)) + ", " +
    cql_bool(hash2(s, 117)) + ", " +
    cql_bool(hash2(s, 118)) + ", " +
    cql_text(hash2(s, 119)) + ", " +
    cql_pay_finalize(hash2(s, 120)) + ", " +
    cql_pay_flow_directions(hash2(s, 121)) + ", " +
    cql_bool(hash2(s, 122)) + ", " +
    cql_bool(hash2(s, 123)) + ", " +
    cql_text(hash2(s, 124)) + ", " +
    cql_text(hash2(s, 125)) + ", " +
    cql_text(hash2(s, 126)) + ", " +
    cql_text(hash2(s, 127)) + ", " +
    cql_text(hash2(s, 128)) + ", " +
    cql_text(hash2(s, 129)) + ", " +
    cql_text(hash2(s, 130)) + ", " +
    cql_text(hash2(s, 131)) + ", " +
    cql_text(hash2(s, 132)) + ", " +
    cql_text(hash2(s, 133)) + ", " +
    cql_text(hash2(s, 134)) + ", " +
    cql_text(hash2(s, 135)) + ", " +
    cql_text(hash2(s, 136)) + ", " +
    cql_text(hash2(s, 137)) + ", " +
    cql_text(hash2(s, 138)) + ", " +
    cql_text(hash2(s, 139)) + ", " +
    cql_bool(hash2(s, 140)) + ", " +
    cql_text(hash2(s, 141)) + ", " +
    cql_text(hash2(s, 142)) + ", " +
    cql_text(hash2(s, 143)) + ", " +
    cql_text(hash2(s, 144)) + ", " +
    cql_text(hash2(s, 145)) + ", " +
    cql_text(hash2(s, 146)) + ", " +
    cql_text(hash2(s, 147)) + ", " +
    cql_text(hash2(s, 148)) + ", " +
    cql_text(hash2(s, 149)) + ", " +
    cql_map_tt(hash2(s, 150)) + ", " +
    cql_text(hash2(s, 151)) + ", " +
    cql_text(hash2(s, 152)) + ", " +
    cql_text(hash2(s, 153)) + ", " +
    cql_bool(hash2(s, 154)) + ", " +
    cql_text(hash2(s, 155)) + ", " +
    cql_text(hash2(s, 156)) + ", " +
    cql_text(hash2(s, 157)) + ", " +
    cql_bool(hash2(s, 158)) + ", " +
    cql_text(hash2(s, 159)) + ", " +
    cql_text(hash2(s, 160)) + ", " +
    cql_text(hash2(s, 161)) + ", " +
    cql_text(hash2(s, 162)) + ", " +
    cql_text(hash2(s, 163)) + ", " +
    cql_int(hash2(s, 164)) + ", " +
    cql_text(hash2(s, 165)) + ", " +
    cql_text(hash2(s, 166)) + ", " +
    cql_text(hash2(s, 167)) + ", " +
    cql_text(hash2(s, 168)) + ", " +
    cql_text(hash2(s, 169)) + ", " +
    cql_int(hash2(s, 170)) + ", " +
    cql_map_tt(hash2(s, 171)) + ", " +
    cql_bool(hash2(s, 172)) + ", " +
    cql_text(hash2(s, 173)) + ", " +
    cql_text(hash2(s, 174)) + ", " +
    cql_text(hash2(s, 175)) + ", " +
    cql_text(hash2(s, 176)) + ", " +
    cql_text(hash2(s, 177)) + ", " +
    cql_text(hash2(s, 178)) + ", " +
    cql_text(hash2(s, 179)) + ", " +
    cql_text(hash2(s, 180)) + ", " +
    cql_bool(hash2(s, 181)) + ", " +
    cql_text(hash2(s, 182)) + ", " +
    cql_text(hash2(s, 183)) + ", " +
    cql_bool(hash2(s, 184)) + ", " +
    cql_text(hash2(s, 185)) + ", " +
    cql_bool(hash2(s, 186)) + ", " +
    cql_bool(hash2(s, 187)) + ", " +
    cql_bool(hash2(s, 188)) + ", " +
    cql_int(hash2(s, 189)) + ", " +
    cql_text(hash2(s, 190)) + ", " +
    cql_text(hash2(s, 191)) + ", " +
    cql_pay_payment_method(hash2(s, 192)) + ", " +
    cql_pay_payment_method_options(hash2(s, 193)) + ", " +
    cql_text(hash2(s, 194)) + ", " +
    cql_text(hash2(s, 195)) + ", " +
    cql_text(hash2(s, 196)) + ", " +
    cql_text(hash2(s, 197)) + ", " +
    cql_text(hash2(s, 198)) + ", " +
    cql_text(hash2(s, 199)) + ", " +
    cql_text(hash2(s, 200)) + ", " +
    cql_text(hash2(s, 201)) + ", " +
    cql_text(hash2(s, 202)) + ", " +
    cql_text(hash2(s, 203)) + ", " +
    cql_text(hash2(s, 204)) + ", " +
    cql_text(hash2(s, 205)) + ", " +
    cql_text(hash2(s, 206)) + ", " +
    cql_text(hash2(s, 207)) + ", " +
    cql_text(hash2(s, 208)) + ", " +
    cql_text(hash2(s, 209)) + ", " +
    cql_text(hash2(s, 210)) + ", " +
    cql_text(hash2(s, 211)) + ", " +
    cql_text(hash2(s, 212)) + ", " +
    cql_bool(hash2(s, 213)) + ", " +
    cql_text(hash2(s, 214)) + ", " +
    cql_text(hash2(s, 215)) + ", " +
    cql_text(hash2(s, 216)) + ", " +
    cql_text(hash2(s, 217)) + ", " +
    cql_text(hash2(s, 218)) + ", " +
    cql_text(hash2(s, 219)) + ", " +
    cql_text(hash2(s, 220)) + ", " +
    cql_text(hash2(s, 221)) + ", " +
    cql_bool(hash2(s, 222)) + ", " +
    cql_text(hash2(s, 223)) + ", " +
    cql_text(hash2(s, 224)) + ", " +
    cql_text(hash2(s, 225)) + ", " +
    cql_text(hash2(s, 226)) + ", " +
    cql_list_text(hash2(s, 227)) + ", " +
    cql_text(hash2(s, 228)) + ", " +
    cql_text(hash2(s, 229)) + ", " +
    cql_text(hash2(s, 230)) + ", " +
    cql_text(hash2(s, 231)) + ", " +
    cql_text(hash2(s, 232)) + ", " +
    cql_text(hash2(s, 233)) + ", " +
    cql_text(hash2(s, 234)) + ", " +
    cql_text(hash2(s, 235)) + ", " +
    cql_text(hash2(s, 236)) + ", " +
    cql_text(hash2(s, 237)) + ", " +
    cql_text(hash2(s, 238)) + ", " +
    cql_text(hash2(s, 239)) + ", " +
    cql_text(hash2(s, 240)) + ", " +
    cql_bool(hash2(s, 241)) + ", " +
    cql_text(hash2(s, 242)) + ", " +
    cql_text(hash2(s, 243)) + ", " +
    cql_pay_routing_details(hash2(s, 244)) + ", " +
    cql_text(hash2(s, 245)) + ", " +
    cql_text(hash2(s, 246)) + ", " +
    cql_text(hash2(s, 247)) + ", " +
    cql_text(hash2(s, 248)) + ", " +
    cql_bool(hash2(s, 249)) + ", " +
    cql_text(hash2(s, 250)) + ", " +
    cql_text(hash2(s, 251)) + ", " +
    cql_text(hash2(s, 252)) + ", " +
    cql_text(hash2(s, 253)) + ", " +
    cql_text(hash2(s, 254)) + ", " +
    cql_text(hash2(s, 255)) + ", " +
    cql_text(hash2(s, 256)) + ", " +
    cql_text(hash2(s, 257)) + ", " +
    cql_text(hash2(s, 258)) + ", " +
    cql_text(hash2(s, 259)) + ", " +
    cql_pay_address_v2(hash2(s, 260)) + ", " +
    cql_text(hash2(s, 261)) + ", " +
    cql_text(hash2(s, 262)) + ", " +
    cql_text(hash2(s, 263)) + ", " +
    cql_text(hash2(s, 264)) + ", " +
    cql_text(hash2(s, 265)) + ", " +
    cql_text(hash2(s, 266)) + ", " +
    cql_text(hash2(s, 267)) + ", " +
    cql_text(hash2(s, 268)) + ", " +
    cql_text(hash2(s, 269)) + ", " +
    cql_text(hash2(s, 270)) + ", " +
    cql_text(hash2(s, 271)) + ", " +
    cql_text(hash2(s, 272)) + ", " +
    cql_bool(hash2(s, 273)) + ", " +
    cql_bool(hash2(s, 274)) + ", " +
    cql_text(hash2(s, 275)) + ", " +
    cql_text(hash2(s, 276)) + ", " +
    cql_bool(hash2(s, 277)) + ", " +
    cql_text(hash2(s, 278)) + ", " +
    cql_text(hash2(s, 279)) + ", " +
    cql_text(hash2(s, 280)) + ", " +
    cql_text(hash2(s, 281)) + ", " +
    cql_text(hash2(s, 282)) + ", " +
    cql_text(hash2(s, 283)) + ", " +
    cql_text(hash2(s, 284)) + ", " +
    cql_text(hash2(s, 285)) + ", " +
    cql_text(hash2(s, 286)) + ", " +
    cql_text(hash2(s, 287)) + ", " +
    cql_bool(hash2(s, 288)) + ", " +
    cql_text(hash2(s, 289)) + ", " +
    cql_text(hash2(s, 290)) + ", " +
    cql_text(hash2(s, 291)) + ", " +
    cql_bool(hash2(s, 292)) + ", " +
    cql_text(hash2(s, 293)) + ", " +
    cql_text(hash2(s, 294)) + ", " +
    cql_map_tt(hash2(s, 295)) + ", " +
    cql_bool(hash2(s, 296)) + ", " +
    cql_text(hash2(s, 297)) + ", " +
    cql_text(hash2(s, 298)) + ", " +
    cql_text(hash2(s, 299)) + ", " +
    cql_text(hash2(s, 300)) + ", " +
    cql_text(hash2(s, 301)) + ", " +
    cql_text(hash2(s, 302)) + ", " +
    cql_text(hash2(s, 303)) + ", " +
    cql_text(hash2(s, 304)) + ", " +
    cql_text(hash2(s, 305)) + ", " +
    cql_text(hash2(s, 306)) + ", " +
    cql_text(hash2(s, 307)) + ", " +
    cql_text(hash2(s, 308)) + ", " +
    cql_text(hash2(s, 309)) + ", " +
    cql_bool(hash2(s, 310)) + ", " +
    cql_text(hash2(s, 311)) + ", " +
    cql_text(hash2(s, 312)) + ", " +
    cql_text(hash2(s, 313)) + ", " +
    cql_text(hash2(s, 314)) + ", " +
    cql_text(hash2(s, 315)) + ", " +
    cql_text(hash2(s, 316)) + ", " +
    cql_text(hash2(s, 317)) + ", " +
    cql_text(hash2(s, 318)) + ", " +
    cql_list_text(hash2(s, 319)) + ", " +
    cql_text(hash2(s, 320)) + ", " +
    cql_text(hash2(s, 321)) + ", " +
    cql_text(hash2(s, 322)) + ", " +
    cql_text(hash2(s, 323)) + ", " +
    cql_text(hash2(s, 324)) + ", " +
    cql_text(hash2(s, 325)) +
    ")"
}
fn gen_insert_pay_workflows(s) {
    "INSERT INTO pay.workflows (name, description, enabled, friendly_name, namespace, params, signals, task_queue) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_bool(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    "[" + cql_pay_workflow_param(hash2(s, 5)) + "]" + ", " +
    cql_set_text(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) +
    ")"
}
fn gen_insert_pay_worldpay_credentials(s) {
    "INSERT INTO pay.worldpay_credentials (merchant_id, merchant_sub_id, payfac_ids, worldpay_chargeback_password, worldpay_chargeback_username, worldpay_contract_type, worldpay_credentials, worldpay_three_ds_credentials) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_map_tt(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    "null" + ", " +
    cql_pay_worldpay_three_ds_credentials(hash2(s, 7)) +
    ")"
}
fn gen_insert_pay_eu_individuals(s) {
    "INSERT INTO pay_eu.individuals (id, annual_income, annual_income_currency, archived, company_country, company_country_of_incorporation, company_date_of_incorporation, company_legal_name, company_physical_address, company_registered_address, company_registration_number, country, date_of_birth, document_country_of_issue, document_expiration_date, document_issue_date, documents, email, first_name, id_number, identification_document_type, individuals, is_business_representative, is_director, is_nominee_shareholder, is_shareholder, last_name, middle_name, nationality, other_activities_details, pep, percentage_of_shares, phone_number, place_of_birth, proof_of_residence_document_type, residential_address, significant_responsibility, size_of_wealth, size_of_wealth_currency, social_media, source_of_income, source_of_wealth, ssn, title, type, verification_checks) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_bool(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_pay_eu_address_v2(hash2(s, 8)) + ", " +
    cql_pay_eu_address_v2(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_text(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    "[" + cql_pay_eu_onboarding_document(hash2(s, 16)) + "]" + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_text(hash2(s, 18)) + ", " +
    cql_text(hash2(s, 19)) + ", " +
    cql_text(hash2(s, 20)) + ", " +
    cql_list_text(hash2(s, 21)) + ", " +
    cql_bool(hash2(s, 22)) + ", " +
    cql_bool(hash2(s, 23)) + ", " +
    cql_bool(hash2(s, 24)) + ", " +
    cql_bool(hash2(s, 25)) + ", " +
    cql_text(hash2(s, 26)) + ", " +
    cql_text(hash2(s, 27)) + ", " +
    cql_text(hash2(s, 28)) + ", " +
    cql_text(hash2(s, 29)) + ", " +
    cql_bool(hash2(s, 30)) + ", " +
    cql_text(hash2(s, 31)) + ", " +
    cql_text(hash2(s, 32)) + ", " +
    cql_text(hash2(s, 33)) + ", " +
    cql_text(hash2(s, 34)) + ", " +
    cql_pay_eu_address_v2(hash2(s, 35)) + ", " +
    cql_bool(hash2(s, 36)) + ", " +
    cql_text(hash2(s, 37)) + ", " +
    cql_text(hash2(s, 38)) + ", " +
    "[" + cql_pay_eu_social_media(hash2(s, 39)) + "]" + ", " +
    cql_text(hash2(s, 40)) + ", " +
    cql_text(hash2(s, 41)) + ", " +
    cql_text(hash2(s, 42)) + ", " +
    cql_text(hash2(s, 43)) + ", " +
    cql_text(hash2(s, 44)) + ", " +
    "[" + cql_pay_eu_verification_check(hash2(s, 45)) + "]" +
    ")"
}
fn gen_insert_pay_eu_individuals_v2(s) {
    "INSERT INTO pay_eu.individuals_v2 (company_id, merchant_id, id, annual_income, annual_income_currency, archived, company_country, company_country_of_incorporation, company_date_of_incorporation, company_legal_name, company_physical_address, company_registered_address, company_registration_number, country, date_of_birth, document_country_of_issue, document_expiration_date, document_issue_date, documents, email, first_name, id_number, identification_document_type, individuals, is_business_representative, is_director, is_nominee_shareholder, is_shareholder, is_ubo, last_name, middle_name, nationality, other_activities_details, pep, percentage_of_shares, phone_number, place_of_birth, proof_of_residence_document_type, residential_address, significant_responsibility, size_of_wealth, size_of_wealth_currency, social_media, source_of_income, source_of_income_other, source_of_wealth, source_of_wealth_other, ssn, title, type, verification_checks) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_bool(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_pay_eu_address_v2(hash2(s, 10)) + ", " +
    cql_pay_eu_address_v2(hash2(s, 11)) + ", " +
    cql_text(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    "[" + cql_pay_eu_onboarding_document(hash2(s, 18)) + "]" + ", " +
    cql_text(hash2(s, 19)) + ", " +
    cql_text(hash2(s, 20)) + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_text(hash2(s, 22)) + ", " +
    cql_list_text(hash2(s, 23)) + ", " +
    cql_bool(hash2(s, 24)) + ", " +
    cql_bool(hash2(s, 25)) + ", " +
    cql_bool(hash2(s, 26)) + ", " +
    cql_bool(hash2(s, 27)) + ", " +
    cql_bool(hash2(s, 28)) + ", " +
    cql_text(hash2(s, 29)) + ", " +
    cql_text(hash2(s, 30)) + ", " +
    cql_text(hash2(s, 31)) + ", " +
    cql_text(hash2(s, 32)) + ", " +
    cql_bool(hash2(s, 33)) + ", " +
    cql_text(hash2(s, 34)) + ", " +
    cql_text(hash2(s, 35)) + ", " +
    cql_text(hash2(s, 36)) + ", " +
    cql_text(hash2(s, 37)) + ", " +
    cql_pay_eu_address_v2(hash2(s, 38)) + ", " +
    cql_bool(hash2(s, 39)) + ", " +
    cql_text(hash2(s, 40)) + ", " +
    cql_text(hash2(s, 41)) + ", " +
    "[" + cql_pay_eu_social_media(hash2(s, 42)) + "]" + ", " +
    cql_text(hash2(s, 43)) + ", " +
    cql_text(hash2(s, 44)) + ", " +
    cql_text(hash2(s, 45)) + ", " +
    cql_text(hash2(s, 46)) + ", " +
    cql_text(hash2(s, 47)) + ", " +
    cql_text(hash2(s, 48)) + ", " +
    cql_text(hash2(s, 49)) + ", " +
    "[" + cql_pay_eu_verification_check(hash2(s, 50)) + "]" +
    ")"
}
fn gen_insert_pay_eu_merchant_applications(s) {
    "INSERT INTO pay_eu.merchant_applications (company_id, merchant_id, version, acquiring_services, approval_date, authorized_business_representative, automatic_review, bank_details, business_activity, business_details, business_processing_info, business_review, business_structure_details, channel, contract_agreement_date, created_at, created_by, created_by_system, customer_support, decline_details, documents, enrollment_date, fulfillment_details, heard_of_pay_from, individuals, last_updated, notes, onboarding_channel, other_communications, owner, pay_legal_entity, payment_requirements, paypass_link_created_at, paypass_link_created_by, paypass_link_created_by_system, paypass_submitted_at, priority, privacy_policy_agreement, provider_data, risk, risk_score, sales_assignee, settlement_terms, shadow_purchase, short_descriptor, stage, status, test, underwriting_assignee, underwriting_info, verification_checks) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_int(hash2(s, 2)) + ", " +
    cql_list_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_bool(hash2(s, 6)) + ", " +
    cql_pay_eu_onboarding_bank_details(hash2(s, 7)) + ", " +
    cql_pay_eu_onboarding_business_activity(hash2(s, 8)) + ", " +
    cql_pay_eu_onboarding_business_details(hash2(s, 9)) + ", " +
    cql_pay_eu_business_processing_info(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_pay_eu_business_structure_details(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_pay_eu_customer_support(hash2(s, 18)) + ", " +
    cql_pay_eu_decline_details(hash2(s, 19)) + ", " +
    "[" + cql_pay_eu_onboarding_document(hash2(s, 20)) + "]" + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_pay_eu_fulfillment_details(hash2(s, 22)) + ", " +
    cql_text(hash2(s, 23)) + ", " +
    cql_list_text(hash2(s, 24)) + ", " +
    cql_text(hash2(s, 25)) + ", " +
    "[" + cql_pay_eu_note(hash2(s, 26)) + "]" + ", " +
    cql_pay_eu_onboarding_channel(hash2(s, 27)) + ", " +
    cql_bool(hash2(s, 28)) + ", " +
    cql_text(hash2(s, 29)) + ", " +
    cql_set_text(hash2(s, 30)) + ", " +
    cql_text(hash2(s, 31)) + ", " +
    cql_text(hash2(s, 32)) + ", " +
    cql_text(hash2(s, 33)) + ", " +
    cql_text(hash2(s, 34)) + ", " +
    cql_text(hash2(s, 35)) + ", " +
    cql_tinyint(hash2(s, 36)) + ", " +
    cql_bool(hash2(s, 37)) + ", " +
    cql_pay_eu_provider_data(hash2(s, 38)) + ", " +
    cql_pay_eu_risk(hash2(s, 39)) + ", " +
    cql_text(hash2(s, 40)) + ", " +
    cql_text(hash2(s, 41)) + ", " +
    cql_pay_eu_entity_settlement_terms(hash2(s, 42)) + ", " +
    cql_text(hash2(s, 43)) + ", " +
    cql_text(hash2(s, 44)) + ", " +
    cql_tinyint(hash2(s, 45)) + ", " +
    cql_text(hash2(s, 46)) + ", " +
    cql_bool(hash2(s, 47)) + ", " +
    cql_text(hash2(s, 48)) + ", " +
    cql_pay_eu_underwriting_info(hash2(s, 49)) + ", " +
    "[" + cql_pay_eu_verification_check(hash2(s, 50)) + "]" +
    ")"
}
fn gen_insert_pay_us_individuals(s) {
    "INSERT INTO pay_us.individuals (id, annual_income, annual_income_currency, archived, company_country, company_country_of_incorporation, company_date_of_incorporation, company_legal_name, company_physical_address, company_registered_address, company_registration_number, country, date_of_birth, document_country_of_issue, document_expiration_date, document_issue_date, documents, email, first_name, id_number, identification_document_type, individuals, is_business_representative, is_director, is_nominee_shareholder, is_shareholder, last_name, middle_name, nationality, other_activities_details, pep, percentage_of_shares, phone_number, place_of_birth, proof_of_residence_document_type, residential_address, significant_responsibility, size_of_wealth, size_of_wealth_currency, social_media, source_of_income, source_of_wealth, ssn, title, type, verification_checks) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_bool(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_pay_us_address_v2(hash2(s, 8)) + ", " +
    cql_pay_us_address_v2(hash2(s, 9)) + ", " +
    cql_text(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_text(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    "[" + cql_pay_us_onboarding_document(hash2(s, 16)) + "]" + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_text(hash2(s, 18)) + ", " +
    cql_text(hash2(s, 19)) + ", " +
    cql_text(hash2(s, 20)) + ", " +
    cql_list_text(hash2(s, 21)) + ", " +
    cql_bool(hash2(s, 22)) + ", " +
    cql_bool(hash2(s, 23)) + ", " +
    cql_bool(hash2(s, 24)) + ", " +
    cql_bool(hash2(s, 25)) + ", " +
    cql_text(hash2(s, 26)) + ", " +
    cql_text(hash2(s, 27)) + ", " +
    cql_text(hash2(s, 28)) + ", " +
    cql_text(hash2(s, 29)) + ", " +
    cql_bool(hash2(s, 30)) + ", " +
    cql_text(hash2(s, 31)) + ", " +
    cql_text(hash2(s, 32)) + ", " +
    cql_text(hash2(s, 33)) + ", " +
    cql_text(hash2(s, 34)) + ", " +
    cql_pay_us_address_v2(hash2(s, 35)) + ", " +
    cql_bool(hash2(s, 36)) + ", " +
    cql_text(hash2(s, 37)) + ", " +
    cql_text(hash2(s, 38)) + ", " +
    "[" + cql_pay_us_social_media(hash2(s, 39)) + "]" + ", " +
    cql_text(hash2(s, 40)) + ", " +
    cql_text(hash2(s, 41)) + ", " +
    cql_text(hash2(s, 42)) + ", " +
    cql_text(hash2(s, 43)) + ", " +
    cql_text(hash2(s, 44)) + ", " +
    "[" + cql_pay_us_verification_check(hash2(s, 45)) + "]" +
    ")"
}
fn gen_insert_pay_us_individuals_v2(s) {
    "INSERT INTO pay_us.individuals_v2 (company_id, merchant_id, id, annual_income, annual_income_currency, archived, company_country, company_country_of_incorporation, company_date_of_incorporation, company_legal_name, company_physical_address, company_registered_address, company_registration_number, country, date_of_birth, document_country_of_issue, document_expiration_date, document_issue_date, documents, email, first_name, id_number, identification_document_type, individuals, is_business_representative, is_director, is_nominee_shareholder, is_shareholder, last_name, middle_name, nationality, other_activities_details, pep, percentage_of_shares, phone_number, place_of_birth, proof_of_residence_document_type, residential_address, significant_responsibility, size_of_wealth, size_of_wealth_currency, social_media, source_of_income, source_of_income_other, source_of_wealth, source_of_wealth_other, ssn, title, type, verification_checks) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_text(hash2(s, 2)) + ", " +
    cql_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_bool(hash2(s, 5)) + ", " +
    cql_text(hash2(s, 6)) + ", " +
    cql_text(hash2(s, 7)) + ", " +
    cql_text(hash2(s, 8)) + ", " +
    cql_text(hash2(s, 9)) + ", " +
    cql_pay_us_address_v2(hash2(s, 10)) + ", " +
    cql_pay_us_address_v2(hash2(s, 11)) + ", " +
    cql_text(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    "[" + cql_pay_us_onboarding_document(hash2(s, 18)) + "]" + ", " +
    cql_text(hash2(s, 19)) + ", " +
    cql_text(hash2(s, 20)) + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_text(hash2(s, 22)) + ", " +
    cql_list_text(hash2(s, 23)) + ", " +
    cql_bool(hash2(s, 24)) + ", " +
    cql_bool(hash2(s, 25)) + ", " +
    cql_bool(hash2(s, 26)) + ", " +
    cql_bool(hash2(s, 27)) + ", " +
    cql_text(hash2(s, 28)) + ", " +
    cql_text(hash2(s, 29)) + ", " +
    cql_text(hash2(s, 30)) + ", " +
    cql_text(hash2(s, 31)) + ", " +
    cql_bool(hash2(s, 32)) + ", " +
    cql_text(hash2(s, 33)) + ", " +
    cql_text(hash2(s, 34)) + ", " +
    cql_text(hash2(s, 35)) + ", " +
    cql_text(hash2(s, 36)) + ", " +
    cql_pay_us_address_v2(hash2(s, 37)) + ", " +
    cql_bool(hash2(s, 38)) + ", " +
    cql_text(hash2(s, 39)) + ", " +
    cql_text(hash2(s, 40)) + ", " +
    "[" + cql_pay_us_social_media(hash2(s, 41)) + "]" + ", " +
    cql_text(hash2(s, 42)) + ", " +
    cql_text(hash2(s, 43)) + ", " +
    cql_text(hash2(s, 44)) + ", " +
    cql_text(hash2(s, 45)) + ", " +
    cql_text(hash2(s, 46)) + ", " +
    cql_text(hash2(s, 47)) + ", " +
    cql_text(hash2(s, 48)) + ", " +
    "[" + cql_pay_us_verification_check(hash2(s, 49)) + "]" +
    ")"
}
fn gen_insert_pay_us_merchant_applications(s) {
    "INSERT INTO pay_us.merchant_applications (company_id, merchant_id, version, acquiring_services, approval_date, authorized_business_representative, automatic_review, bank_details, business_activity, business_details, business_processing_info, business_review, business_structure_details, channel, contract_agreement_date, created_at, created_by, created_by_system, customer_support, decline_details, documents, enrollment_date, fulfillment_details, heard_of_pay_from, individuals, last_updated, notes, onboarding_channel, other_communications, owner, pay_legal_entity, payment_requirements, paypass_link_created_at, paypass_link_created_by, paypass_link_created_by_system, paypass_submitted_at, priority, privacy_policy_agreement, provider_data, risk, risk_score, sales_assignee, settlement_terms, shadow_purchase, short_descriptor, stage, status, test, underwriting_assignee, underwriting_info, verification_checks) VALUES (" +
    cql_text(hash2(s, 0)) + ", " +
    cql_text(hash2(s, 1)) + ", " +
    cql_int(hash2(s, 2)) + ", " +
    cql_list_text(hash2(s, 3)) + ", " +
    cql_text(hash2(s, 4)) + ", " +
    cql_text(hash2(s, 5)) + ", " +
    cql_bool(hash2(s, 6)) + ", " +
    cql_pay_us_onboarding_bank_details(hash2(s, 7)) + ", " +
    cql_pay_us_onboarding_business_activity(hash2(s, 8)) + ", " +
    cql_pay_us_onboarding_business_details(hash2(s, 9)) + ", " +
    cql_pay_us_business_processing_info(hash2(s, 10)) + ", " +
    cql_text(hash2(s, 11)) + ", " +
    cql_pay_us_business_structure_details(hash2(s, 12)) + ", " +
    cql_text(hash2(s, 13)) + ", " +
    cql_text(hash2(s, 14)) + ", " +
    cql_text(hash2(s, 15)) + ", " +
    cql_text(hash2(s, 16)) + ", " +
    cql_text(hash2(s, 17)) + ", " +
    cql_pay_us_customer_support(hash2(s, 18)) + ", " +
    cql_pay_us_decline_details(hash2(s, 19)) + ", " +
    "[" + cql_pay_us_onboarding_document(hash2(s, 20)) + "]" + ", " +
    cql_text(hash2(s, 21)) + ", " +
    cql_pay_us_fulfillment_details(hash2(s, 22)) + ", " +
    cql_text(hash2(s, 23)) + ", " +
    cql_list_text(hash2(s, 24)) + ", " +
    cql_text(hash2(s, 25)) + ", " +
    "[" + cql_pay_us_note(hash2(s, 26)) + "]" + ", " +
    cql_pay_us_onboarding_channel(hash2(s, 27)) + ", " +
    cql_bool(hash2(s, 28)) + ", " +
    cql_text(hash2(s, 29)) + ", " +
    cql_set_text(hash2(s, 30)) + ", " +
    cql_text(hash2(s, 31)) + ", " +
    cql_text(hash2(s, 32)) + ", " +
    cql_text(hash2(s, 33)) + ", " +
    cql_text(hash2(s, 34)) + ", " +
    cql_text(hash2(s, 35)) + ", " +
    cql_tinyint(hash2(s, 36)) + ", " +
    cql_bool(hash2(s, 37)) + ", " +
    cql_pay_us_provider_data(hash2(s, 38)) + ", " +
    cql_pay_us_risk(hash2(s, 39)) + ", " +
    cql_text(hash2(s, 40)) + ", " +
    cql_text(hash2(s, 41)) + ", " +
    cql_pay_us_entity_settlement_terms(hash2(s, 42)) + ", " +
    cql_text(hash2(s, 43)) + ", " +
    cql_text(hash2(s, 44)) + ", " +
    cql_tinyint(hash2(s, 45)) + ", " +
    cql_text(hash2(s, 46)) + ", " +
    cql_bool(hash2(s, 47)) + ", " +
    cql_text(hash2(s, 48)) + ", " +
    cql_pay_us_underwriting_info(hash2(s, 49)) + ", " +
    "[" + cql_pay_us_verification_check(hash2(s, 50)) + "]" +
    ")"
}

/// Dispatch functions
fn dispatch_udt_insert(table_idx, seed) {
    if table_idx == 0 { return gen_insert_pay_addresses(seed); }
    if table_idx == 1 { return gen_insert_pay_apm_configurations(seed); }
    if table_idx == 2 { return gen_insert_pay_aps_credentials(seed); }
    if table_idx == 3 { return gen_insert_pay_bank_accounts(seed); }
    if table_idx == 4 { return gen_insert_pay_bank_transfers(seed); }
    if table_idx == 5 { return gen_insert_pay_banks(seed); }
    if table_idx == 6 { return gen_insert_pay_cards(seed); }
    if table_idx == 7 { return gen_insert_pay_companies(seed); }
    if table_idx == 8 { return gen_insert_pay_crm_fields(seed); }
    if table_idx == 9 { return gen_insert_pay_disputes(seed); }
    if table_idx == 10 { return gen_insert_pay_ecp_credentials(seed); }
    if table_idx == 11 { return gen_insert_pay_finance_settings(seed); }
    if table_idx == 12 { return gen_insert_pay_fonix_credentials(seed); }
    if table_idx == 13 { return gen_insert_pay_gumballpay_credentials(seed); }
    if table_idx == 14 { return gen_insert_pay_legal_entities(seed); }
    if table_idx == 15 { return gen_insert_pay_limits(seed); }
    if table_idx == 16 { return gen_insert_pay_logic_fields(seed); }
    if table_idx == 17 { return gen_insert_pay_merchants(seed); }
    if table_idx == 18 { return gen_insert_pay_notification_subscriptions(seed); }
    if table_idx == 19 { return gen_insert_pay_notifications(seed); }
    if table_idx == 20 { return gen_insert_pay_payment_control(seed); }
    if table_idx == 21 { return gen_insert_pay_payment_control_v2(seed); }
    if table_idx == 22 { return gen_insert_pay_payment_method_options(seed); }
    if table_idx == 23 { return gen_insert_pay_payment_method_options_configs(seed); }
    if table_idx == 24 { return gen_insert_pay_paymentlinks(seed); }
    if table_idx == 25 { return gen_insert_pay_paypal_payers(seed); }
    if table_idx == 26 { return gen_insert_pay_pricing(seed); }
    if table_idx == 27 { return gen_insert_pay_pricing_v2(seed); }
    if table_idx == 28 { return gen_insert_pay_pricing_v3(seed); }
    if table_idx == 29 { return gen_insert_pay_receipts(seed); }
    if table_idx == 30 { return gen_insert_pay_reconciliation_config(seed); }
    if table_idx == 31 { return gen_insert_pay_referrals(seed); }
    if table_idx == 32 { return gen_insert_pay_report_pull_config(seed); }
    if table_idx == 33 { return gen_insert_pay_reports(seed); }
    if table_idx == 34 { return gen_insert_pay_reports_config(seed); }
    if table_idx == 35 { return gen_insert_pay_risk_alerts(seed); }
    if table_idx == 36 { return gen_insert_pay_risk_calculations(seed); }
    if table_idx == 37 { return gen_insert_pay_rules(seed); }
    if table_idx == 38 { return gen_insert_pay_settings(seed); }
    if table_idx == 39 { return gen_insert_pay_settlement_config(seed); }
    if table_idx == 40 { return gen_insert_pay_settlements(seed); }
    if table_idx == 41 { return gen_insert_pay_silverflow_credentials(seed); }
    if table_idx == 42 { return gen_insert_pay_sources(seed); }
    if table_idx == 43 { return gen_insert_pay_sources_v2(seed); }
    if table_idx == 44 { return gen_insert_pay_statements(seed); }
    if table_idx == 45 { return gen_insert_pay_subscription_packages(seed); }
    if table_idx == 46 { return gen_insert_pay_subscriptions(seed); }
    if table_idx == 47 { return gen_insert_pay_task_templates(seed); }
    if table_idx == 48 { return gen_insert_pay_tasks(seed); }
    if table_idx == 49 { return gen_insert_pay_transactions(seed); }
    if table_idx == 50 { return gen_insert_pay_workflows(seed); }
    if table_idx == 51 { return gen_insert_pay_worldpay_credentials(seed); }
    if table_idx == 52 { return gen_insert_pay_eu_individuals(seed); }
    if table_idx == 53 { return gen_insert_pay_eu_individuals_v2(seed); }
    if table_idx == 54 { return gen_insert_pay_eu_merchant_applications(seed); }
    if table_idx == 55 { return gen_insert_pay_us_individuals(seed); }
    if table_idx == 56 { return gen_insert_pay_us_individuals_v2(seed); }
    if table_idx == 57 { return gen_insert_pay_us_merchant_applications(seed); }
    "-- unknown table"
}

/// UDT tables registry
fn get_udt_tables_registry() {
    [
        #{"name": "addresses", "ks": "pay", "pk": 1, "ck": 1, "pk_col_types": ["T", "T"]},
        #{"name": "apm_configurations", "ks": "pay", "pk": 1, "ck": 1, "pk_col_types": ["T", "T"]},
        #{"name": "aps_credentials", "ks": "pay", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "bank_accounts", "ks": "pay", "pk": 2, "ck": 1, "pk_col_types": ["T", "T", "T"]},
        #{"name": "bank_transfers", "ks": "pay", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "banks", "ks": "pay", "pk": 1, "ck": 3, "pk_col_types": ["T", "T", "T", "T"]},
        #{"name": "cards", "ks": "pay", "pk": 2, "ck": 1, "pk_col_types": ["T", "T", "T"]},
        #{"name": "companies", "ks": "pay", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "crm_fields", "ks": "pay", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "disputes", "ks": "pay", "pk": 2, "ck": 1, "pk_col_types": ["T", "T", "T"]},
        #{"name": "ecp_credentials", "ks": "pay", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "finance_settings", "ks": "pay", "pk": 1, "ck": 1, "pk_col_types": ["T", "T"]},
        #{"name": "fonix_credentials", "ks": "pay", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "gumballpay_credentials", "ks": "pay", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "legal_entities", "ks": "pay", "pk": 1, "ck": 1, "pk_col_types": ["T", "T"]},
        #{"name": "limits", "ks": "pay", "pk": 1, "ck": 1, "pk_col_types": ["T", "T"]},
        #{"name": "logic_fields", "ks": "pay", "pk": 1, "ck": 1, "pk_col_types": ["T", "T"]},
        #{"name": "merchants", "ks": "pay", "pk": 1, "ck": 1, "pk_col_types": ["T", "T"]},
        #{"name": "notification_subscriptions", "ks": "pay", "pk": 1, "ck": 3, "pk_col_types": ["T", "T", "T", "T"]},
        #{"name": "notifications", "ks": "pay", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "payment_control", "ks": "pay", "pk": 1, "ck": 1, "pk_col_types": ["T", "T"]},
        #{"name": "payment_control_v2", "ks": "pay", "pk": 1, "ck": 2, "pk_col_types": ["T", "T", "T"]},
        #{"name": "payment_method_options", "ks": "pay", "pk": 1, "ck": 2, "pk_col_types": ["T", "T", "T"]},
        #{"name": "payment_method_options_configs", "ks": "pay", "pk": 1, "ck": 2, "pk_col_types": ["T", "T", "T"]},
        #{"name": "paymentlinks", "ks": "pay", "pk": 1, "ck": 2, "pk_col_types": ["T", "T", "T"]},
        #{"name": "paypal_payers", "ks": "pay", "pk": 2, "ck": 1, "pk_col_types": ["T", "T", "T"]},
        #{"name": "pricing", "ks": "pay", "pk": 1, "ck": 1, "pk_col_types": ["T", "T"]},
        #{"name": "pricing_v2", "ks": "pay", "pk": 1, "ck": 2, "pk_col_types": ["T", "T", "T"]},
        #{"name": "pricing_v3", "ks": "pay", "pk": 1, "ck": 4, "pk_col_types": ["T", "T", "T", "T", "T"]},
        #{"name": "receipts", "ks": "pay", "pk": 2, "ck": 1, "pk_col_types": ["T", "T", "T"]},
        #{"name": "reconciliation_config", "ks": "pay", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "referrals", "ks": "pay", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "report_pull_config", "ks": "pay", "pk": 1, "ck": 1, "pk_col_types": ["T", "T"]},
        #{"name": "reports", "ks": "pay", "pk": 1, "ck": 2, "pk_col_types": ["T", "T", "T"]},
        #{"name": "reports_config", "ks": "pay", "pk": 1, "ck": 1, "pk_col_types": ["T", "T"]},
        #{"name": "risk_alerts", "ks": "pay", "pk": 1, "ck": 2, "pk_col_types": ["T", "T", "T"]},
        #{"name": "risk_calculations", "ks": "pay", "pk": 2, "ck": 1, "pk_col_types": ["T", "T", "T"]},
        #{"name": "rules", "ks": "pay", "pk": 1, "ck": 2, "pk_col_types": ["T", "T", "T"]},
        #{"name": "settings", "ks": "pay", "pk": 1, "ck": 1, "pk_col_types": ["T", "T"]},
        #{"name": "settlement_config", "ks": "pay", "pk": 1, "ck": 1, "pk_col_types": ["T", "T"]},
        #{"name": "settlements", "ks": "pay", "pk": 1, "ck": 3, "pk_col_types": ["T", "T", "T", "T"]},
        #{"name": "silverflow_credentials", "ks": "pay", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "sources", "ks": "pay", "pk": 2, "ck": 1, "pk_col_types": ["T", "T", "T"]},
        #{"name": "sources_v2", "ks": "pay", "pk": 2, "ck": 2, "pk_col_types": ["T", "T", "T", "T"]},
        #{"name": "statements", "ks": "pay", "pk": 2, "ck": 1, "pk_col_types": ["T", "T", "T"]},
        #{"name": "subscription_packages", "ks": "pay", "pk": 1, "ck": 2, "pk_col_types": ["T", "T", "T"]},
        #{"name": "subscriptions", "ks": "pay", "pk": 2, "ck": 1, "pk_col_types": ["T", "T", "T"]},
        #{"name": "task_templates", "ks": "pay", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "tasks", "ks": "pay", "pk": 1, "ck": 1, "pk_col_types": ["T", "T"]},
        #{"name": "transactions", "ks": "pay", "pk": 1, "ck": 2, "pk_col_types": ["T", "T", "T"]},
        #{"name": "workflows", "ks": "pay", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "worldpay_credentials", "ks": "pay", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "individuals", "ks": "pay_eu", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "individuals_v2", "ks": "pay_eu", "pk": 1, "ck": 2, "pk_col_types": ["T", "T", "T"]},
        #{"name": "merchant_applications", "ks": "pay_eu", "pk": 1, "ck": 2, "pk_col_types": ["T", "T", "I"]},
        #{"name": "individuals", "ks": "pay_us", "pk": 1, "ck": 0, "pk_col_types": ["T"]},
        #{"name": "individuals_v2", "ks": "pay_us", "pk": 1, "ck": 2, "pk_col_types": ["T", "T", "T"]},
        #{"name": "merchant_applications", "ks": "pay_us", "pk": 1, "ck": 2, "pk_col_types": ["T", "T", "I"]},
    ]
}

/// Prepare UDT tables for workload (called from prepare())
async fn prepare_udt_tables(db) {
    println!("Preparing workload for UDT tables...");

    let registry = get_udt_tables_registry();
    db.data.udt_tables = registry;
    db.data.num_udt_tables = registry.len();
    println!("debug: Registered {n} UDT tables for workload", n=registry.len());
}

/// Populate UDT tables with initial data using CQL literal INSERT statements.
pub async fn populate_udt(db, i) {
    let table_idx = i % db.data.num_udt_tables;
    let row_idx = i / db.data.num_udt_tables;

    if row_idx >= ROW_COUNT_PER_TABLE {
        return;
    }

    let insert_cql = dispatch_udt_insert(table_idx, row_idx);
    db.execute(insert_cql).await?
}

/// Write workload for UDT tables. Inserts/upserts rows using Gaussian distribution.
pub async fn write_udt(db, i) {
    let table_idx = i % db.data.num_udt_tables;
    let row_idx = get_partition_idx(db, i / db.data.num_udt_tables).await;

    let insert_cql = dispatch_udt_insert(table_idx, row_idx);
    db.execute(insert_cql).await?
}

/// Read workload for UDT tables. Point reads by primary key.
pub async fn read_udt(db, i) {
    let table_idx = i % db.data.num_udt_tables;
    let row_idx = get_partition_idx(db, i / db.data.num_udt_tables).await;

    let sel_cql = dispatch_udt_select(table_idx, row_idx);
    db.execute(sel_cql).await?
}

/// Select dispatch function
fn dispatch_udt_select(table_idx, seed) {
    if table_idx == 0 { return "SELECT * FROM pay.addresses WHERE consumer_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND id = '" + cql_text_raw(hash2(seed, 1)) + "'"; }
    if table_idx == 1 { return "SELECT * FROM pay.apm_configurations WHERE payment_method_type = '" + cql_text_raw(hash2(seed, 0)) + "' AND provider = '" + cql_text_raw(hash2(seed, 1)) + "'"; }
    if table_idx == 2 { return "SELECT * FROM pay.aps_credentials WHERE merchant_id = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 3 { return "SELECT * FROM pay.bank_accounts WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 4 { return "SELECT * FROM pay.bank_transfers WHERE id = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 5 { return "SELECT * FROM pay.banks WHERE currency = '" + cql_text_raw(hash2(seed, 0)) + "' AND country = '" + cql_text_raw(hash2(seed, 1)) + "' AND provider = '" + cql_text_raw(hash2(seed, 2)) + "' AND provider_bank_id = '" + cql_text_raw(hash2(seed, 3)) + "'"; }
    if table_idx == 6 { return "SELECT * FROM pay.cards WHERE merchant_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND consumer_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND method_token = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 7 { return "SELECT * FROM pay.companies WHERE id = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 8 { return "SELECT * FROM pay.crm_fields WHERE id = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 9 { return "SELECT * FROM pay.disputes WHERE merchant_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND date = '" + cql_text_raw(hash2(seed, 1)) + "' AND id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 10 { return "SELECT * FROM pay.ecp_credentials WHERE merchant_id = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 11 { return "SELECT * FROM pay.finance_settings WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "'"; }
    if table_idx == 12 { return "SELECT * FROM pay.fonix_credentials WHERE merchant_id = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 13 { return "SELECT * FROM pay.gumballpay_credentials WHERE merchant_id = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 14 { return "SELECT * FROM pay.legal_entities WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND id = '" + cql_text_raw(hash2(seed, 1)) + "'"; }
    if table_idx == 15 { return "SELECT * FROM pay.limits WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "'"; }
    if table_idx == 16 { return "SELECT * FROM pay.logic_fields WHERE identifier = '" + cql_text_raw(hash2(seed, 0)) + "' AND key = '" + cql_text_raw(hash2(seed, 1)) + "'"; }
    if table_idx == 17 { return "SELECT * FROM pay.merchants WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND id = '" + cql_text_raw(hash2(seed, 1)) + "'"; }
    if table_idx == 18 { return "SELECT * FROM pay.notification_subscriptions WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND user_id = '" + cql_text_raw(hash2(seed, 2)) + "' AND notification_type = '" + cql_text_raw(hash2(seed, 3)) + "'"; }
    if table_idx == 19 { return "SELECT * FROM pay.notifications WHERE notification_type = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 20 { return "SELECT * FROM pay.payment_control WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "'"; }
    if table_idx == 21 { return "SELECT * FROM pay.payment_control_v2 WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND settlement_account_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 22 { return "SELECT * FROM pay.payment_method_options WHERE key = '" + cql_text_raw(hash2(seed, 0)) + "' AND id = '" + cql_text_raw(hash2(seed, 1)) + "' AND attempt_id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 23 { return "SELECT * FROM pay.payment_method_options_configs WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 24 { return "SELECT * FROM pay.paymentlinks WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 25 { return "SELECT * FROM pay.paypal_payers WHERE merchant_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND consumer_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND email = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 26 { return "SELECT * FROM pay.pricing WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "'"; }
    if table_idx == 27 { return "SELECT * FROM pay.pricing_v2 WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND provider = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 28 { return "SELECT * FROM pay.pricing_v3 WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND settlement_account_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND currency = '" + cql_text_raw(hash2(seed, 2)) + "' AND payment_method_type = '" + cql_text_raw(hash2(seed, 3)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 4)) + "'"; }
    if table_idx == 29 { return "SELECT * FROM pay.receipts WHERE transaction_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND company_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 30 { return "SELECT * FROM pay.reconciliation_config WHERE regex = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 31 { return "SELECT * FROM pay.referrals WHERE id = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 32 { return "SELECT * FROM pay.report_pull_config WHERE provider = '" + cql_text_raw(hash2(seed, 0)) + "' AND id = '" + cql_text_raw(hash2(seed, 1)) + "'"; }
    if table_idx == 33 { return "SELECT * FROM pay.reports WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 34 { return "SELECT * FROM pay.reports_config WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "'"; }
    if table_idx == 35 { return "SELECT * FROM pay.risk_alerts WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 36 { return "SELECT * FROM pay.risk_calculations WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 37 { return "SELECT * FROM pay.rules WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 38 { return "SELECT * FROM pay.settings WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "'"; }
    if table_idx == 39 { return "SELECT * FROM pay.settlement_config WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND id = '" + cql_text_raw(hash2(seed, 1)) + "'"; }
    if table_idx == 40 { return "SELECT * FROM pay.settlements WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND id = '" + cql_text_raw(hash2(seed, 2)) + "' AND currency = '" + cql_text_raw(hash2(seed, 3)) + "'"; }
    if table_idx == 41 { return "SELECT * FROM pay.silverflow_credentials WHERE merchant_id = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 42 { return "SELECT * FROM pay.sources WHERE merchant_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND type = '" + cql_text_raw(hash2(seed, 1)) + "' AND unique_identifier = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 43 { return "SELECT * FROM pay.sources_v2 WHERE merchant_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND consumer_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND type = '" + cql_text_raw(hash2(seed, 2)) + "' AND unique_identifier = '" + cql_text_raw(hash2(seed, 3)) + "'"; }
    if table_idx == 44 { return "SELECT * FROM pay.statements WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND date = '" + cql_text_raw(hash2(seed, 1)) + "' AND id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 45 { return "SELECT * FROM pay.subscription_packages WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 46 { return "SELECT * FROM pay.subscriptions WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND date = '" + cql_text_raw(hash2(seed, 1)) + "' AND id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 47 { return "SELECT * FROM pay.task_templates WHERE id = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 48 { return "SELECT * FROM pay.tasks WHERE partition_key = '" + cql_text_raw(hash2(seed, 0)) + "' AND id = '" + cql_text_raw(hash2(seed, 1)) + "'"; }
    if table_idx == 49 { return "SELECT * FROM pay.transactions WHERE key = '" + cql_text_raw(hash2(seed, 0)) + "' AND id = '" + cql_text_raw(hash2(seed, 1)) + "' AND attempt_id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 50 { return "SELECT * FROM pay.workflows WHERE name = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 51 { return "SELECT * FROM pay.worldpay_credentials WHERE merchant_id = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 52 { return "SELECT * FROM pay_eu.individuals WHERE id = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 53 { return "SELECT * FROM pay_eu.individuals_v2 WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 54 { return "SELECT * FROM pay_eu.merchant_applications WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND version = " + cql_int(hash2(seed, 2)) + ""; }
    if table_idx == 55 { return "SELECT * FROM pay_us.individuals WHERE id = '" + cql_text_raw(hash2(seed, 0)) + "'"; }
    if table_idx == 56 { return "SELECT * FROM pay_us.individuals_v2 WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND id = '" + cql_text_raw(hash2(seed, 2)) + "'"; }
    if table_idx == 57 { return "SELECT * FROM pay_us.merchant_applications WHERE company_id = '" + cql_text_raw(hash2(seed, 0)) + "' AND merchant_id = '" + cql_text_raw(hash2(seed, 1)) + "' AND version = " + cql_int(hash2(seed, 2)) + ""; }
    "SELECT 1"
}

/// Populate all tables (simple + UDT)
pub async fn populate_all(db, i) {
    let total = db.data.total_tables;
    let table_idx = i % total;
    let row_idx = i / total;

    if row_idx >= ROW_COUNT_PER_TABLE {
        return;
    }

    if table_idx < db.data.num_simple_tables {
        // Simple table - use prepared statement
        let table = db.data.simple_tables[table_idx];
        let values = gen_row_values(table, row_idx).await;
        db.execute_prepared(table.insert, values).await?
    } else {
        // UDT table - use CQL literal
        let udt_idx = table_idx - db.data.num_simple_tables;
        let insert_cql = dispatch_udt_insert(udt_idx, row_idx);
        db.execute(insert_cql).await?
    }
}

/// Write to all tables (simple + UDT)
pub async fn write_all(db, i) {
    let total = db.data.total_tables;
    let table_idx = i % total;
    let row_idx = get_partition_idx(db, i / total).await;

    if table_idx < db.data.num_simple_tables {
        let table = db.data.simple_tables[table_idx];
        let values = gen_row_values(table, row_idx).await;
        db.execute_prepared(table.insert, values).await?
    } else {
        let udt_idx = table_idx - db.data.num_simple_tables;
        let insert_cql = dispatch_udt_insert(udt_idx, row_idx);
        db.execute(insert_cql).await?
    }
}

/// Read from all tables (simple + UDT)
pub async fn read_all(db, i) {
    let total = db.data.total_tables;
    let table_idx = i % total;
    let row_idx = get_partition_idx(db, i / total).await;

    if table_idx < db.data.num_simple_tables {
        let table = db.data.simple_tables[table_idx];
        let key_count = table.pk_count + table.ck_count;
        let key_values = [];
        let key_i = 0;
        while key_i < key_count {
            let seed = hash2(row_idx, key_i);
            key_values.push(gen_value(table.col_types[key_i], seed).await);
            key_i += 1;
        }
        if !DATA_VALIDATION {
            db.execute_prepared(table.sel, key_values).await?
        } else {
            let rows = db.execute_prepared_with_result(table.sel, key_values).await?;
            let rows_len = rows.len();
            if rows_len != 1 {
                db.signal_failure(
                    `Expected 1 row from pay.${table.name}, got ${rows_len}. row_idx=${row_idx}`
                ).await?;
            }
        }
    } else {
        let udt_idx = table_idx - db.data.num_simple_tables;
        let sel_cql = dispatch_udt_select(udt_idx, row_idx);
        db.execute(sel_cql).await?
    }
}


///////////////////////////////////////////
///// Phase 6: Advanced Workload Patterns //
///////////////////////////////////////////

/// Prepare table windowing configuration (called from prepare()).
/// When TABLE_GROUP_SIZE > 0, only that many tables are active at once.
/// The active window shifts by TABLE_SHIFT_COUNT tables every TABLE_SHIFT_INTERVAL_S seconds.
async fn prepare_table_windowing(db) {
    let total = db.data.total_tables;

    if TABLE_GROUP_SIZE == 0 {
        // Windowing disabled â€” all tables active
        db.data.table_group_size = total;
        db.data.windowing_enabled = false;
        println!("debug: Table windowing disabled (all {n} tables active)", n=total);
        return;
    }

    assert!(TABLE_GROUP_SIZE > 0 && TABLE_GROUP_SIZE <= total,
        "table_group_size must be > 0 and <= total_tables");

    if TABLE_SHIFT_INTERVAL_S > 0 {
        assert!(TABLE_SHIFT_COUNT > 0,
            "table_shift_count must be > 0 when table_shift_interval_s > 0");
    }
    if TABLE_SHIFT_COUNT > 0 {
        assert!(TABLE_SHIFT_INTERVAL_S > 0,
            "table_shift_interval_s must be > 0 when table_shift_count > 0");
    }

    db.data.table_group_size = TABLE_GROUP_SIZE;
    db.data.windowing_enabled = TABLE_SHIFT_INTERVAL_S > 0;

    println!("debug: Table windowing enabled: group_size={gs}, shift_count={sc}, shift_interval={si}s",
        gs=TABLE_GROUP_SIZE, sc=TABLE_SHIFT_COUNT, si=TABLE_SHIFT_INTERVAL_S);
}

/// Get the windowed table index. When windowing is enabled, maps iteration index 'i'
/// to a table within the current active window. The window shifts over time.
async fn get_table_window_idx(db, i) {
    let group_size = db.data.table_group_size;
    let window_i = i % group_size;

    if db.data.windowing_enabled {
        let elapsed = db.elapsed_secs();
        let shift_offset = (elapsed as i64 / TABLE_SHIFT_INTERVAL_S) * TABLE_SHIFT_COUNT;
        (shift_offset + window_i) % db.data.total_tables
    } else {
        window_i % db.data.total_tables
    }
}

/// Returns the PK + CK column names for each UDT table (used for DELETE CQL generation).
/// Order matches get_udt_tables_registry() and dispatch_udt_select().
fn get_udt_pk_col_names(table_idx) {
    if table_idx == 0 { return ["consumer_id", "id"]; }
    if table_idx == 1 { return ["payment_method_type", "provider"]; }
    if table_idx == 2 { return ["merchant_id"]; }
    if table_idx == 3 { return ["company_id", "merchant_id", "id"]; }
    if table_idx == 4 { return ["id"]; }
    if table_idx == 5 { return ["currency", "country", "provider", "provider_bank_id"]; }
    if table_idx == 6 { return ["merchant_id", "consumer_id", "method_token"]; }
    if table_idx == 7 { return ["id"]; }
    if table_idx == 8 { return ["id"]; }
    if table_idx == 9 { return ["merchant_id", "date", "id"]; }
    if table_idx == 10 { return ["merchant_id"]; }
    if table_idx == 11 { return ["company_id", "merchant_id"]; }
    if table_idx == 12 { return ["merchant_id"]; }
    if table_idx == 13 { return ["merchant_id"]; }
    if table_idx == 14 { return ["company_id", "id"]; }
    if table_idx == 15 { return ["company_id", "merchant_id"]; }
    if table_idx == 16 { return ["identifier", "key"]; }
    if table_idx == 17 { return ["company_id", "id"]; }
    if table_idx == 18 { return ["company_id", "merchant_id", "user_id", "notification_type"]; }
    if table_idx == 19 { return ["notification_type"]; }
    if table_idx == 20 { return ["company_id", "merchant_id"]; }
    if table_idx == 21 { return ["company_id", "settlement_account_id", "merchant_id"]; }
    if table_idx == 22 { return ["key", "id", "attempt_id"]; }
    if table_idx == 23 { return ["company_id", "merchant_id", "id"]; }
    if table_idx == 24 { return ["company_id", "merchant_id", "id"]; }
    if table_idx == 25 { return ["merchant_id", "consumer_id", "email"]; }
    if table_idx == 26 { return ["company_id", "merchant_id"]; }
    if table_idx == 27 { return ["company_id", "merchant_id", "provider"]; }
    if table_idx == 28 { return ["company_id", "settlement_account_id", "currency", "payment_method_type", "merchant_id"]; }
    if table_idx == 29 { return ["transaction_id", "company_id", "id"]; }
    if table_idx == 30 { return ["regex"]; }
    if table_idx == 31 { return ["id"]; }
    if table_idx == 32 { return ["provider", "id"]; }
    if table_idx == 33 { return ["company_id", "merchant_id", "id"]; }
    if table_idx == 34 { return ["company_id", "merchant_id"]; }
    if table_idx == 35 { return ["company_id", "merchant_id", "id"]; }
    if table_idx == 36 { return ["company_id", "merchant_id", "id"]; }
    if table_idx == 37 { return ["company_id", "merchant_id", "id"]; }
    if table_idx == 38 { return ["company_id", "merchant_id"]; }
    if table_idx == 39 { return ["company_id", "id"]; }
    if table_idx == 40 { return ["company_id", "merchant_id", "id", "currency"]; }
    if table_idx == 41 { return ["merchant_id"]; }
    if table_idx == 42 { return ["merchant_id", "type", "unique_identifier"]; }
    if table_idx == 43 { return ["merchant_id", "consumer_id", "type", "unique_identifier"]; }
    if table_idx == 44 { return ["company_id", "date", "id"]; }
    if table_idx == 45 { return ["company_id", "merchant_id", "id"]; }
    if table_idx == 46 { return ["company_id", "date", "id"]; }
    if table_idx == 47 { return ["id"]; }
    if table_idx == 48 { return ["partition_key", "id"]; }
    if table_idx == 49 { return ["key", "id", "attempt_id"]; }
    if table_idx == 50 { return ["name"]; }
    if table_idx == 51 { return ["merchant_id"]; }
    if table_idx == 52 { return ["id"]; }
    if table_idx == 53 { return ["company_id", "merchant_id", "id"]; }
    if table_idx == 54 { return ["company_id", "merchant_id", "version"]; }
    if table_idx == 55 { return ["id"]; }
    if table_idx == 56 { return ["company_id", "merchant_id", "id"]; }
    if table_idx == 57 { return ["company_id", "merchant_id", "version"]; }
    let empty = Vec::new();
    empty
}

/// Generate a DELETE CQL string for a UDT table row.
fn gen_udt_delete_cql(table_meta, table_idx, seed) {
    let pk_names = get_udt_pk_col_names(table_idx);
    let pk_types = table_meta.pk_col_types;
    let where_clause = "";
    let col_i = 0;
    while col_i < pk_names.len() {
        if col_i > 0 { where_clause += " AND "; }
        let col_name = pk_names[col_i];
        if pk_types[col_i] == "I" {
            where_clause += `${col_name} = ${cql_int(hash2(seed, col_i))}`;
        } else {
            where_clause += `${col_name} = '${cql_text_raw(hash2(seed, col_i))}'`;
        }
        col_i += 1;
    }
    `DELETE FROM ${table_meta.ks}.${table_meta.name} WHERE ${where_clause}`
}

/// Delete workload for simple tables. Deletes rows by primary key.
pub async fn delete(db, i) {
    let table_idx = i % db.data.num_simple_tables;
    let row_idx = get_partition_idx(db, i / db.data.num_simple_tables).await;

    let table = db.data.simple_tables[table_idx];

    // Generate PK + CK values for WHERE clause
    let key_count = table.pk_count + table.ck_count;
    let key_values = [];
    let key_i = 0;
    while key_i < key_count {
        let seed = hash2(row_idx, key_i);
        key_values.push(gen_value(table.col_types[key_i], seed).await);
        key_i += 1;
    }

    db.execute_prepared(table.del, key_values).await?
}

/// Update workload for simple tables. Updates the first non-key column.
/// Falls back to insert (upsert) if table has no non-key columns.
pub async fn update(db, i) {
    let table_idx = i % db.data.num_simple_tables;
    let row_idx = get_partition_idx(db, i / db.data.num_simple_tables).await;

    let table = db.data.simple_tables[table_idx];

    if table.upd == "" {
        // No non-key columns to update, fall back to insert (upsert)
        let values = gen_row_values(table, row_idx).await;
        db.execute_prepared(table.insert, values).await?
    } else {
        // UPDATE table SET col = ? WHERE pk = ? AND ck = ?
        // Bind order: [new_value, pk1, pk2, ..., ck1, ck2, ...]
        let key_count = table.pk_count + table.ck_count;
        let update_values = [];

        // First: the new value for the updated column (first non-key column)
        let update_col_idx = key_count;
        let update_seed = hash2(row_idx, update_col_idx + i); // Vary by i for different updates
        update_values.push(gen_value(table.col_types[update_col_idx], update_seed).await);

        // Then: PK + CK values for WHERE clause
        let key_i = 0;
        while key_i < key_count {
            let seed = hash2(row_idx, key_i);
            update_values.push(gen_value(table.col_types[key_i], seed).await);
            key_i += 1;
        }

        db.execute_prepared(table.upd, update_values).await?
    }
}

/// Delete workload for UDT tables. Deletes rows by primary key using CQL literal.
pub async fn delete_udt(db, i) {
    let table_idx = i % db.data.num_udt_tables;
    let row_idx = get_partition_idx(db, i / db.data.num_udt_tables).await;

    let table_meta = db.data.udt_tables[table_idx];
    let del_cql = gen_udt_delete_cql(table_meta, table_idx, row_idx);
    db.execute(del_cql).await?
}

/// Update workload for UDT tables. Uses INSERT (upsert semantics in ScyllaDB).
pub async fn update_udt(db, i) {
    // In ScyllaDB, INSERT and UPDATE are both upserts.
    // For UDT tables we re-insert with the same key, effectively updating.
    let table_idx = i % db.data.num_udt_tables;
    let row_idx = get_partition_idx(db, i / db.data.num_udt_tables).await;

    let insert_cql = dispatch_udt_insert(table_idx, row_idx);
    db.execute(insert_cql).await?
}

/// Delete from all tables (simple + UDT)
pub async fn delete_all(db, i) {
    let total = db.data.total_tables;
    let table_idx = i % total;
    let row_idx = get_partition_idx(db, i / total).await;

    if table_idx < db.data.num_simple_tables {
        let table = db.data.simple_tables[table_idx];
        let key_count = table.pk_count + table.ck_count;
        let key_values = [];
        let key_i = 0;
        while key_i < key_count {
            let seed = hash2(row_idx, key_i);
            key_values.push(gen_value(table.col_types[key_i], seed).await);
            key_i += 1;
        }
        db.execute_prepared(table.del, key_values).await?
    } else {
        let udt_idx = table_idx - db.data.num_simple_tables;
        let table_meta = db.data.udt_tables[udt_idx];
        let del_cql = gen_udt_delete_cql(table_meta, udt_idx, row_idx);
        db.execute(del_cql).await?
    }
}

/// Update all tables (simple via prepared UPDATE, UDT via upsert INSERT)
pub async fn update_all(db, i) {
    let total = db.data.total_tables;
    let table_idx = i % total;
    let row_idx = get_partition_idx(db, i / total).await;

    if table_idx < db.data.num_simple_tables {
        let table = db.data.simple_tables[table_idx];
        if table.upd == "" {
            let values = gen_row_values(table, row_idx).await;
            db.execute_prepared(table.insert, values).await?
        } else {
            let key_count = table.pk_count + table.ck_count;
            let update_values = [];
            let update_col_idx = key_count;
            let update_seed = hash2(row_idx, update_col_idx + i);
            update_values.push(gen_value(table.col_types[update_col_idx], update_seed).await);
            let key_i = 0;
            while key_i < key_count {
                let seed = hash2(row_idx, key_i);
                update_values.push(gen_value(table.col_types[key_i], seed).await);
                key_i += 1;
            }
            db.execute_prepared(table.upd, update_values).await?
        }
    } else {
        let udt_idx = table_idx - db.data.num_simple_tables;
        let insert_cql = dispatch_udt_insert(udt_idx, row_idx);
        db.execute(insert_cql).await?
    }
}

/// Write with table windowing. Only writes to tables in the active window.
/// When windowing shifts, new tables become active while others go idle.
pub async fn write_windowed(db, i) {
    let table_idx = get_table_window_idx(db, i).await;
    let row_idx = get_partition_idx(db, i / db.data.table_group_size).await;

    if table_idx < db.data.num_simple_tables {
        let table = db.data.simple_tables[table_idx];
        let values = gen_row_values(table, row_idx).await;
        db.execute_prepared(table.insert, values).await?
    } else {
        let udt_idx = table_idx - db.data.num_simple_tables;
        let insert_cql = dispatch_udt_insert(udt_idx, row_idx);
        db.execute(insert_cql).await?
    }
}

/// Read with table windowing. Only reads from tables in the active window.
pub async fn read_windowed(db, i) {
    let table_idx = get_table_window_idx(db, i).await;
    let row_idx = get_partition_idx(db, i / db.data.table_group_size).await;

    if table_idx < db.data.num_simple_tables {
        let table = db.data.simple_tables[table_idx];
        let key_count = table.pk_count + table.ck_count;
        let key_values = [];
        let key_i = 0;
        while key_i < key_count {
            let seed = hash2(row_idx, key_i);
            key_values.push(gen_value(table.col_types[key_i], seed).await);
            key_i += 1;
        }
        db.execute_prepared(table.sel, key_values).await?
    } else {
        let udt_idx = table_idx - db.data.num_simple_tables;
        let sel_cql = dispatch_udt_select(udt_idx, row_idx);
        db.execute(sel_cql).await?
    }
}

/// Delete with table windowing. Only deletes from tables in the active window.
pub async fn delete_windowed(db, i) {
    let table_idx = get_table_window_idx(db, i).await;
    let row_idx = get_partition_idx(db, i / db.data.table_group_size).await;

    if table_idx < db.data.num_simple_tables {
        let table = db.data.simple_tables[table_idx];
        let key_count = table.pk_count + table.ck_count;
        let key_values = [];
        let key_i = 0;
        while key_i < key_count {
            let seed = hash2(row_idx, key_i);
            key_values.push(gen_value(table.col_types[key_i], seed).await);
            key_i += 1;
        }
        db.execute_prepared(table.del, key_values).await?
    } else {
        let udt_idx = table_idx - db.data.num_simple_tables;
        let table_meta = db.data.udt_tables[udt_idx];
        let del_cql = gen_udt_delete_cql(table_meta, udt_idx, row_idx);
        db.execute(del_cql).await?
    }
}

/// Payment workflow simulation. Simulates a real payment processing flow:
/// 1. Create a transaction (UDT table: transactions, idx=49)
/// 2. Create a settlement  (UDT table: settlements, idx=40)
/// 3. Create a receipt      (UDT table: receipts, idx=29)
/// Each step uses CQL literal INSERT. All 3 share the same seed for correlated data.
pub async fn payment_workflow(db, i) {
    let seed = get_partition_idx(db, i).await;

    // Step 1: Create transaction
    let txn_cql = dispatch_udt_insert(49, seed);
    db.execute(txn_cql).await?;

    // Step 2: Create settlement
    let settle_cql = dispatch_udt_insert(40, seed);
    db.execute(settle_cql).await?;

    // Step 3: Create receipt
    let receipt_cql = dispatch_udt_insert(29, seed);
    db.execute(receipt_cql).await?;
}
